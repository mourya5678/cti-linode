{
  "version": 3,
  "sources": ["../../../../../node_modules/@reach/descendants/src/index.tsx", "../../../../../node_modules/@reach/auto-id/src/index.ts", "../../../../../node_modules/@reach/tabs/src/index.tsx"],
  "sourcesContent": ["import React, { useCallback, useContext, useMemo, useState } from \"react\";\nimport {\n  createNamedContext,\n  noop,\n  useIsomorphicLayoutEffect,\n  usePrevious,\n} from \"@reach/utils\";\n\nexport function createDescendantContext<DescendantType extends Descendant>(\n  name: string,\n  initialValue = {}\n) {\n  type T = DescendantContextValue<DescendantType>;\n  const descendants: DescendantType[] = [];\n  return createNamedContext<T>(name, {\n    descendants,\n    registerDescendant: noop,\n    unregisterDescendant: noop,\n    ...initialValue,\n  });\n}\n\n/**\n * This hook registers our descendant by passing it into an array. We can then\n * search that array by to find its index when registering it in the component.\n * We use this for focus management, keyboard navigation, and typeahead\n * functionality for some components.\n *\n * The hook accepts the element node and (optionally) a key. The key is useful\n * if multiple descendants have identical text values and we need to\n * differentiate siblings for some reason.\n *\n * Our main goals with this are:\n *   1) maximum composability,\n *   2) minimal API friction\n *   3) SSR compatibility*\n *   4) concurrent safe\n *   5) index always up-to-date with the tree despite changes\n *   6) works with memoization of any component in the tree (hopefully)\n *\n * * As for SSR, the good news is that we don't actually need the index on the\n * server for most use-cases, as we are only using it to determine the order of\n * composed descendants for keyboard navigation. However, in the few cases where\n * this is not the case, we can require an explicit index from the app.\n */\nexport function useDescendant<DescendantType extends Descendant>(\n  descendant: Omit<DescendantType, \"index\">,\n  context: React.Context<DescendantContextValue<DescendantType>>,\n  indexProp?: number\n) {\n  let [, forceUpdate] = useState();\n  let { registerDescendant, unregisterDescendant, descendants } = useContext(\n    context\n  );\n\n  // This will initially return -1 because we haven't registered the descendant\n  // on the first render. After we register, this will then return the correct\n  // index on the following render and we will re-register descendants\n  // so that everything is up-to-date before the user interacts with a\n  // collection.\n  let index =\n    indexProp ??\n    descendants.findIndex((item) => item.element === descendant.element);\n\n  let previousDescendants = usePrevious(descendants);\n\n  // We also need to re-register descendants any time ANY of the other\n  // descendants have changed. My brain was melting when I wrote this and it\n  // feels a little off, but checking in render and using the result in the\n  // effect's dependency array works well enough.\n  let someDescendantsHaveChanged = descendants.some((descendant, index) => {\n    return descendant.element !== previousDescendants?.[index]?.element;\n  });\n\n  // Prevent any flashing\n  useIsomorphicLayoutEffect(() => {\n    if (!descendant.element) forceUpdate({});\n    registerDescendant({\n      ...descendant,\n      index,\n    } as DescendantType);\n    return () => unregisterDescendant(descendant.element);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    registerDescendant,\n    unregisterDescendant,\n    index,\n    someDescendantsHaveChanged,\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    ...Object.values(descendant),\n  ]);\n\n  return index;\n}\n\nexport function useDescendantsInit<DescendantType extends Descendant>() {\n  return useState<DescendantType[]>([]);\n}\n\nexport function useDescendants<DescendantType extends Descendant>(\n  ctx: React.Context<DescendantContextValue<DescendantType>>\n) {\n  return useContext(ctx).descendants;\n}\n\nexport function DescendantProvider<DescendantType extends Descendant>({\n  context: Ctx,\n  children,\n  items,\n  set,\n}: {\n  context: React.Context<DescendantContextValue<DescendantType>>;\n  children: React.ReactNode;\n  items: DescendantType[];\n  set: React.Dispatch<React.SetStateAction<DescendantType[]>>;\n}) {\n  let registerDescendant = useCallback(\n    ({\n      element,\n      index: explicitIndex,\n      ...rest\n    }: Omit<DescendantType, \"index\"> & { index?: number | undefined }) => {\n      if (!element) {\n        return;\n      }\n\n      set((items) => {\n        let newItems: DescendantType[];\n        if (explicitIndex != null) {\n          newItems = [\n            ...items,\n            {\n              ...rest,\n              element,\n              index: explicitIndex,\n            } as DescendantType,\n          ];\n        } else if (items.length === 0) {\n          // If there are no items, register at index 0 and bail.\n          newItems = [\n            ...items,\n            {\n              ...rest,\n              element,\n              index: 0,\n            } as DescendantType,\n          ];\n        } else if (items.find((item) => item.element === element)) {\n          // If the element is already registered, just use the same array\n          newItems = items;\n        } else {\n          // When registering a descendant, we need to make sure we insert in\n          // into the array in the same order that it appears in the DOM. So as\n          // new descendants are added or maybe some are removed, we always know\n          // that the array is up-to-date and correct.\n          //\n          // So here we look at our registered descendants and see if the new\n          // element we are adding appears earlier than an existing descendant's\n          // DOM node via `node.compareDocumentPosition`. If it does, we insert\n          // the new element at this index. Because `registerDescendant` will be\n          // called in an effect every time the descendants state value changes,\n          // we should be sure that this index is accurate when descendent\n          // elements come or go from our component.\n          let index = items.findIndex((item) => {\n            if (!item.element || !element) {\n              return false;\n            }\n            // Does this element's DOM node appear before another item in the\n            // array in our DOM tree? If so, return true to grab the index at\n            // this point in the array so we know where to insert the new\n            // element.\n            return Boolean(\n              item.element.compareDocumentPosition(element as Node) &\n                Node.DOCUMENT_POSITION_PRECEDING\n            );\n          });\n\n          let newItem = {\n            ...rest,\n            element,\n            index,\n          } as DescendantType;\n\n          // If an index is not found we will push the element to the end.\n          if (index === -1) {\n            newItems = [...items, newItem];\n          } else {\n            newItems = [\n              ...items.slice(0, index),\n              newItem,\n              ...items.slice(index),\n            ];\n          }\n        }\n        return newItems.map((item, index) => ({ ...item, index }));\n      });\n    },\n    // set is a state setter initialized by the useDescendants hook.\n    // We can safely ignore the lint warning here because it will not change\n    // between renders.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  let unregisterDescendant = useCallback(\n    (element: DescendantType[\"element\"]) => {\n      if (!element) {\n        return;\n      }\n\n      set((items) => items.filter((item) => element !== item.element));\n    },\n    // set is a state setter initialized by the useDescendants hook.\n    // We can safely ignore the lint warning here because it will not change\n    // between renders.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  return (\n    <Ctx.Provider\n      value={useMemo(() => {\n        return {\n          descendants: items,\n          registerDescendant,\n          unregisterDescendant,\n        };\n      }, [items, registerDescendant, unregisterDescendant])}\n    >\n      {children}\n    </Ctx.Provider>\n  );\n}\n\n/**\n * Testing this as an abstraction for compound components that use keyboard\n * navigation. Hoping this will help us prevent bugs and mismatched behavior\n * across various components, but it may also prove to be too messy of an\n * abstraction in the end.\n *\n * Currently used in:\n *   - Tabs\n *   - Accordion\n *\n * @param context\n * @param options\n */\nexport function useDescendantKeyDown<\n  DescendantType extends Descendant,\n  K extends keyof DescendantType = keyof DescendantType\n>(\n  context: React.Context<DescendantContextValue<DescendantType>>,\n  options: {\n    currentIndex: number | null | undefined;\n    key?: K | \"option\";\n    filter?: (descendant: DescendantType) => boolean;\n    orientation?: \"vertical\" | \"horizontal\" | \"both\";\n    rotate?: boolean;\n    rtl?: boolean;\n    callback(nextOption: DescendantType | DescendantType[K]): void;\n  }\n) {\n  let { descendants } = useContext(context);\n  let {\n    callback,\n    currentIndex,\n    filter,\n    key = \"index\" as K,\n    orientation = \"vertical\",\n    rotate = true,\n    rtl = false,\n  } = options;\n  let index = currentIndex ?? -1;\n\n  return function handleKeyDown(event: React.KeyboardEvent) {\n    if (\n      ![\n        \"ArrowDown\",\n        \"ArrowUp\",\n        \"ArrowLeft\",\n        \"ArrowRight\",\n        \"PageUp\",\n        \"PageDown\",\n        \"Home\",\n        \"End\",\n      ].includes(event.key)\n    ) {\n      return;\n    }\n\n    // If we use a filter function, we need to re-index our descendants array\n    // so that filtered descendent elements aren't selected.\n    let selectableDescendants = filter\n      ? descendants.filter(filter)\n      : descendants;\n\n    // Current index should map to the updated array vs. the original\n    // descendants array.\n    if (filter) {\n      index = selectableDescendants.findIndex(\n        (descendant) => descendant.index === currentIndex\n      );\n    }\n\n    // We need some options for any of this to work!\n    if (!selectableDescendants.length) {\n      return;\n    }\n\n    function getNextOption() {\n      let atBottom = index === selectableDescendants.length - 1;\n      return atBottom\n        ? rotate\n          ? getFirstOption()\n          : selectableDescendants[index]\n        : selectableDescendants[(index + 1) % selectableDescendants.length];\n    }\n\n    function getPreviousOption() {\n      let atTop = index === 0;\n      return atTop\n        ? rotate\n          ? getLastOption()\n          : selectableDescendants[index]\n        : selectableDescendants[\n            (index - 1 + selectableDescendants.length) %\n              selectableDescendants.length\n          ];\n    }\n\n    function getFirstOption() {\n      return selectableDescendants[0];\n    }\n\n    function getLastOption() {\n      return selectableDescendants[selectableDescendants.length - 1];\n    }\n\n    switch (event.key) {\n      case \"ArrowDown\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          let next = getNextOption();\n          callback(key === \"option\" ? next : next[key]);\n        }\n        break;\n      case \"ArrowUp\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          let prev = getPreviousOption();\n          callback(key === \"option\" ? prev : prev[key]);\n        }\n        break;\n      case \"ArrowLeft\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          let nextOrPrev = (rtl ? getNextOption : getPreviousOption)();\n          callback(key === \"option\" ? nextOrPrev : nextOrPrev[key]);\n        }\n        break;\n      case \"ArrowRight\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          let prevOrNext = (rtl ? getPreviousOption : getNextOption)();\n          callback(key === \"option\" ? prevOrNext : prevOrNext[key]);\n        }\n        break;\n      case \"PageUp\":\n        event.preventDefault();\n        let prevOrFirst = (event.ctrlKey\n          ? getPreviousOption\n          : getFirstOption)();\n        callback(key === \"option\" ? prevOrFirst : prevOrFirst[key]);\n        break;\n      case \"Home\":\n        event.preventDefault();\n        let first = getFirstOption();\n        callback(key === \"option\" ? first : first[key]);\n        break;\n      case \"PageDown\":\n        event.preventDefault();\n        let nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();\n        callback(key === \"option\" ? nextOrLast : nextOrLast[key]);\n        break;\n      case \"End\":\n        event.preventDefault();\n        let last = getLastOption();\n        callback(key === \"option\" ? last : last[key]);\n        break;\n    }\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\ntype SomeElement<T> = T extends Element ? T : HTMLElement;\n\nexport type Descendant<ElementType = HTMLElement> = {\n  element: SomeElement<ElementType> | null;\n  index: number;\n};\n\nexport interface DescendantContextValue<DescendantType extends Descendant> {\n  descendants: DescendantType[];\n  registerDescendant(descendant: DescendantType): void;\n  unregisterDescendant(element: DescendantType[\"element\"]): void;\n}\n", "/*\n * Welcome to @reach/auto-id!\n\n * Let's see if we can make sense of why this hook exists and its\n * implementation.\n *\n * Some background:\n *   1. Accessibiliy APIs rely heavily on element IDs\n *   2. Requiring developers to put IDs on every element in Reach UI is both\n *      cumbersome and error-prone\n *   3. With a component model, we can generate IDs for them!\n *\n * Solution 1: Generate random IDs.\n *\n * This works great as long as you don't server render your app. When React (in\n * the client) tries to reuse the markup from the server, the IDs won't match\n * and React will then recreate the entire DOM tree.\n *\n * Solution 2: Increment an integer\n *\n * This sounds great. Since we're rendering the exact same tree on the server\n * and client, we can increment a counter and get a deterministic result between\n * client and server. Also, JS integers can go up to nine-quadrillion. I'm\n * pretty sure the tab will be closed before an app never needs\n * 10 quadrillion IDs!\n *\n * Problem solved, right?\n *\n * Ah, but there's a catch! React's concurrent rendering makes this approach\n * non-deterministic. While the client and server will end up with the same\n * elements in the end, depending on suspense boundaries (and possibly some user\n * input during the initial render) the incrementing integers won't always match\n * up.\n *\n * Solution 3: Don't use IDs at all on the server; patch after first render.\n *\n * What we've done here is solution 2 with some tricks. With this approach, the\n * ID returned is an empty string on the first render. This way the server and\n * client have the same markup no matter how wild the concurrent rendering may\n * have gotten.\n *\n * After the render, we patch up the components with an incremented ID. This\n * causes a double render on any components with `useId`. Shouldn't be a problem\n * since the components using this hook should be small, and we're only updating\n * the ID attribute on the DOM, nothing big is happening.\n *\n * It doesn't have to be an incremented number, though--we could do generate\n * random strings instead, but incrementing a number is probably the cheapest\n * thing we can do.\n *\n * Additionally, we only do this patchup on the very first client render ever.\n * Any calls to `useId` that happen dynamically in the client will be\n * populated immediately with a value. So, we only get the double render after\n * server hydration and never again, SO BACK OFF ALRIGHT?\n */\n\nimport { useState, useEffect } from \"react\";\nimport { useIsomorphicLayoutEffect } from \"@reach/utils\";\n\nlet serverHandoffComplete = false;\nlet id = 0;\nconst genId = () => ++id;\n\n/**\n * useId\n *\n * Autogenerate IDs to facilitate WAI-ARIA and server rendering.\n *\n * Note: The returned ID will initially be `null` and will update after a\n * component mounts. Users may need to supply their own ID if they need\n * consistent values for SSR.\n *\n * @see Docs https://reacttraining.com/reach-ui/auto-id\n */\nexport const useId = (idFromProps?: string | null) => {\n  /*\n   * If this instance isn't part of the initial render, we don't have to do the\n   * double render/patch-up dance. We can just generate the ID and return it.\n   */\n  const initialId = idFromProps || (serverHandoffComplete ? genId() : null);\n\n  const [id, setId] = useState(initialId);\n\n  useIsomorphicLayoutEffect(() => {\n    if (id === null) {\n      /*\n       * Patch the ID after render. We do this in `useLayoutEffect` to avoid any\n       * rendering flicker, though it'll make the first render slower (unlikely\n       * to matter, but you're welcome to measure your app and let us know if\n       * it's a problem).\n       */\n      setId(genId());\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  useEffect(() => {\n    if (serverHandoffComplete === false) {\n      /*\n       * Flag all future uses of `useId` to skip the update dance. This is in\n       * `useEffect` because it goes after `useLayoutEffect`, ensuring we don't\n       * accidentally bail out of the patch-up dance prematurely.\n       */\n      serverHandoffComplete = true;\n    }\n  }, []);\n  return id != null ? String(id) : undefined;\n};\n", "/**\n * Welcome to @reach/tabs!\n *\n * An accessible tabs component.\n *\n * The `Tab` and `TabPanel` elements are associated by their order in the tree.\n * None of the components are empty wrappers, each is associated with a real DOM\n * element in the document, giving you maximum control over styling and composition.\n *\n * You can render any other elements you want inside of `Tabs`, but `TabList`\n * should only render `Tab` elements, and `TabPanels` should only render\n * `TabPanel` elements.\n *\n * @see Docs     https://reacttraining.com/reach-ui/tabs\n * @see Source   https://github.com/reach/reach-ui/tree/main/packages/tabs\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel\n */\n\nimport React, {\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  Children,\n} from \"react\";\nimport PropTypes from \"prop-types\";\nimport {\n  createDescendantContext,\n  Descendant,\n  DescendantProvider,\n  useDescendant,\n  useDescendantKeyDown,\n  useDescendantsInit,\n  useDescendants,\n} from \"@reach/descendants\";\nimport {\n  boolOrBoolString,\n  checkStyles,\n  cloneValidElement,\n  createNamedContext,\n  forwardRefWithAs,\n  getElementComputedStyle,\n  isNumber,\n  isFunction,\n  makeId,\n  memoWithAs,\n  noop,\n  useControlledSwitchWarning,\n  useControlledState,\n  useEventCallback,\n  useForkedRef,\n  useIsomorphicLayoutEffect,\n  useUpdateEffect,\n  wrapEvent,\n} from \"@reach/utils\";\nimport { useId } from \"@reach/auto-id\";\n\nconst TabsDescendantsContext = createDescendantContext<TabDescendant>(\n  \"TabsDescendantsContext\"\n);\n\nconst TabPanelDescendantsContext = createDescendantContext<TabPanelDescendant>(\n  \"TabPanelDescendantsContext\"\n);\nconst TabsContext = createNamedContext(\n  \"TabsContext\",\n  {} as InternalTabsContextValue\n);\n\nexport enum TabsKeyboardActivation {\n  Auto = \"auto\",\n  Manual = \"manual\",\n}\n\nexport enum TabsOrientation {\n  Horizontal = \"horizontal\",\n  Vertical = \"vertical\",\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Tabs\n *\n * The parent component of the tab interface.\n *\n * @see Docs https://reacttraining.com/reach-ui/tabs#tabs\n */\nexport const Tabs = forwardRefWithAs<TabsProps, \"div\">(function Tabs(\n  {\n    as: Comp = \"div\",\n    children,\n    defaultIndex,\n    orientation = TabsOrientation.Horizontal,\n    index: controlledIndex = undefined,\n    keyboardActivation = TabsKeyboardActivation.Auto,\n    onChange,\n    readOnly = false,\n    ...props\n  },\n  ref\n) {\n  let isControlled = useRef(controlledIndex != null);\n  useControlledSwitchWarning(controlledIndex, \"index\", \"Tabs\");\n\n  let _id = useId(props.id);\n  let id = props.id ?? makeId(\"tabs\", _id);\n\n  // We only manage focus if the user caused the update vs. a new controlled\n  // index coming in.\n  let userInteractedRef = useRef(false);\n\n  let selectedPanelRef = useRef<HTMLElement | null>(null);\n\n  let isRTL = useRef(false);\n\n  let [selectedIndex, setSelectedIndex] = useControlledState(\n    controlledIndex,\n    defaultIndex ?? 0\n  );\n\n  let [focusedIndex, setFocusedIndex] = useState(-1);\n\n  let [tabs, setTabs] = useDescendantsInit<TabDescendant>();\n\n  let context: InternalTabsContextValue = useMemo(() => {\n    return {\n      focusedIndex,\n      id,\n      isControlled: isControlled.current,\n      isRTL,\n      keyboardActivation,\n      onFocusPanel() {\n        selectedPanelRef.current?.focus();\n      },\n      onSelectTab: readOnly\n        ? noop\n        : (index: number) => {\n            userInteractedRef.current = true;\n            onChange && onChange(index);\n            setSelectedIndex(index);\n          },\n      onSelectTabWithKeyboard: readOnly\n        ? noop\n        : (index: number) => {\n            userInteractedRef.current = true;\n            switch (keyboardActivation) {\n              case TabsKeyboardActivation.Manual:\n                tabs[index].element?.focus();\n                return;\n              case TabsKeyboardActivation.Auto:\n              default:\n                onChange && onChange(index);\n                setSelectedIndex(index);\n                return;\n            }\n          },\n      orientation,\n      selectedIndex,\n      selectedPanelRef,\n      setFocusedIndex,\n      setSelectedIndex,\n      userInteractedRef,\n    };\n  }, [\n    focusedIndex,\n    id,\n    keyboardActivation,\n    onChange,\n    orientation,\n    readOnly,\n    selectedIndex,\n    setSelectedIndex,\n    tabs,\n  ]);\n\n  useEffect(() => checkStyles(\"tabs\"), []);\n\n  return (\n    <DescendantProvider\n      context={TabsDescendantsContext}\n      items={tabs}\n      set={setTabs}\n    >\n      <TabsContext.Provider value={context}>\n        <Comp\n          {...props}\n          ref={ref}\n          data-reach-tabs=\"\"\n          data-orientation={orientation}\n          id={props.id}\n        >\n          {isFunction(children)\n            ? children({ focusedIndex, id, selectedIndex })\n            : children}\n        </Comp>\n      </TabsContext.Provider>\n    </DescendantProvider>\n  );\n});\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/tabs#tabs-props\n */\nexport type TabsProps = {\n  /**\n   * Tabs expects `<TabList>` and `<TabPanels>` as children. The order doesn't\n   * matter, you can have tabs on the top or the bottom. In fact, you could have\n   * tabs on both the bottom and the top at the same time. You can have random\n   * elements inside as well.\n   *\n   * You can also pass a render function to access data relevant to nested\n   * components.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/tabs#tabs-children\n   */\n  children: React.ReactNode | ((props: TabsContextValue) => React.ReactNode);\n  /**\n   * Like form inputs, a tab's state can be controlled by the owner. Make sure\n   * to include an `onChange` as well, or else the tabs will not be interactive.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/tabs#tabs-index\n   */\n  index?: number;\n  /**\n   * Describes the activation mode when navigating a tablist with a keyboard.\n   * When set to `\"auto\"`, a tab panel is activated automatically when a tab is\n   * highlighted using arrow keys. When set to `\"manual\"`, the user must\n   * activate the tab panel with either the `Spacebar` or `Enter` keys. Defaults\n   * to `\"auto\"`.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/tabs#tabs-keyboardactivation\n   */\n  keyboardActivation?: TabsKeyboardActivation;\n  /**\n   * @see Docs https://reacttraining.com/reach-ui/tabs#tabs-readonly\n   */\n  readOnly?: boolean;\n  /**\n   * Starts the tabs at a specific index.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/tabs#tabs-defaultindex\n   */\n  defaultIndex?: number;\n  /**\n   * Allows you to switch the orientation of the tabs relative to their tab\n   * panels. This value can either be `\"horizontal\"`\n   * (`TabsOrientation.Horizontal`) or `\"vertical\"`\n   * (`TabsOrientation.Vertical`). Defaults to `\"horizontal\"`.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/tabs#tabs-orientation\n   * @see MDN  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Logical_Properties\n   */\n  orientation?: TabsOrientation;\n  /**\n   * Calls back with the tab index whenever the user changes tabs, allowing your\n   * app to synchronize with it.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/tabs#tabs-onchange\n   */\n  onChange?: (index: number) => void;\n};\n\nif (__DEV__) {\n  Tabs.displayName = \"Tabs\";\n  Tabs.propTypes = {\n    children: PropTypes.node.isRequired,\n    onChange: PropTypes.func,\n    orientation: PropTypes.oneOf(Object.values(TabsOrientation)),\n    index: (props, name, compName, location, propName) => {\n      let val = props[name];\n      if (\n        props.index > -1 &&\n        props.onChange == null &&\n        props.readOnly !== true\n      ) {\n        return new Error(\n          \"You provided a value prop to `\" +\n            compName +\n            \"` without an `onChange` handler. This will render a read-only tabs element. If the tabs should be mutable use `defaultIndex`. Otherwise, set `onChange`.\"\n        );\n      } else if (val != null && !isNumber(val)) {\n        return new Error(\n          `Invalid prop \\`${propName}\\` supplied to \\`${compName}\\`. Expected \\`number\\`, received \\`${\n            Array.isArray(val) ? \"array\" : typeof val\n          }\\`.`\n        );\n      }\n      return null;\n    },\n    defaultIndex: PropTypes.number,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * TabList\n *\n * The parent component of the tabs.\n *\n * @see Docs https://reacttraining.com/reach-ui/tabs#tablist\n */\nconst TabListImpl = forwardRefWithAs<TabListProps, \"div\">(function TabList(\n  { children, as: Comp = \"div\", onKeyDown, ...props },\n  forwardedRef\n) {\n  const {\n    focusedIndex,\n    isControlled,\n    isRTL,\n    keyboardActivation,\n    onSelectTabWithKeyboard,\n    orientation,\n    selectedIndex,\n    setSelectedIndex,\n  } = useContext(TabsContext);\n  let tabs = useDescendants(TabsDescendantsContext);\n\n  let ownRef = useRef<HTMLElement | null>(null);\n  let ref = useForkedRef(forwardedRef, ownRef);\n\n  useEffect(() => {\n    if (\n      ownRef.current &&\n      ((ownRef.current.ownerDocument &&\n        ownRef.current.ownerDocument.dir === \"rtl\") ||\n        getElementComputedStyle(ownRef.current, \"direction\") === \"rtl\")\n    ) {\n      isRTL.current = true;\n    }\n  }, [isRTL]);\n\n  let handleKeyDown = useEventCallback(\n    wrapEvent(\n      onKeyDown,\n      useDescendantKeyDown(TabsDescendantsContext, {\n        currentIndex:\n          keyboardActivation === TabsKeyboardActivation.Manual\n            ? focusedIndex\n            : selectedIndex,\n        orientation,\n        rotate: true,\n        callback: onSelectTabWithKeyboard,\n        filter: (tab) => !tab.disabled,\n        rtl: isRTL.current,\n      })\n    )\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    // In the event an uncontrolled component's selected index is disabled,\n    // (this should only happen if the first tab is disabled and no default\n    // index is set), we need to override the selection to the next selectable\n    // index value.\n    if (!isControlled && boolOrBoolString(tabs[selectedIndex]?.disabled)) {\n      let next = tabs.find((tab) => !tab.disabled);\n      if (next) {\n        setSelectedIndex(next.index);\n      }\n    }\n  }, [tabs, isControlled, selectedIndex, setSelectedIndex]);\n\n  return (\n    <Comp\n      // The element that serves as the container for the set of tabs has role\n      // `tablist`\n      // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel\n      role=\"tablist\"\n      // If the `tablist` element is vertically oriented, it has the property\n      // `aria-orientation` set to `\"vertical\"`. The default value of\n      // `aria-orientation` for a tablist element is `\"horizontal\"`.\n      // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel\n      aria-orientation={orientation}\n      {...props}\n      data-reach-tab-list=\"\"\n      ref={ref}\n      onKeyDown={handleKeyDown}\n    >\n      {Children.map(children, (child, index) => {\n        // TODO: Remove in 1.0\n        return cloneValidElement(child, {\n          isSelected: index === selectedIndex,\n        });\n      })}\n    </Comp>\n  );\n});\n\nif (__DEV__) {\n  TabListImpl.displayName = \"TabList\";\n  TabListImpl.propTypes = {\n    as: PropTypes.any,\n    children: PropTypes.node,\n  };\n}\n\nconst TabList = memoWithAs(TabListImpl);\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/tabs#tablist-props\n */\nexport type TabListProps = {\n  /**\n   * `TabList` expects multiple `Tab` elements as children.\n   *\n   * `TabPanels` expects multiple `TabPanel` elements as children.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/tabs#tablist-children\n   */\n  children?: React.ReactNode;\n};\n\nif (__DEV__) {\n  TabList.displayName = \"TabList\";\n}\n\nexport { TabList };\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Tab\n *\n * The interactive element that changes the selected panel.\n *\n * @see Docs https://reacttraining.com/reach-ui/tabs#tab\n */\nexport const Tab = forwardRefWithAs<\n  // TODO: Remove this when cloneElement is removed\n  TabProps & { isSelected?: boolean },\n  \"button\"\n>(function Tab(\n  {\n    children,\n    isSelected: _,\n    as: Comp = \"button\",\n    index: indexProp,\n    disabled,\n    onBlur,\n    onFocus,\n    ...props\n  },\n  forwardedRef\n) {\n  const {\n    id: tabsId,\n    onSelectTab,\n    orientation,\n    selectedIndex,\n    userInteractedRef,\n    setFocusedIndex,\n  } = useContext(TabsContext);\n  const ownRef = useRef<HTMLElement | null>(null);\n  const ref = useForkedRef(forwardedRef, ownRef);\n  const index = useDescendant(\n    {\n      element: ownRef.current!,\n      disabled: !!disabled,\n    },\n    TabsDescendantsContext,\n    indexProp\n  );\n  const htmlType =\n    Comp === \"button\" && props.type == null ? \"button\" : props.type;\n\n  const isSelected = index === selectedIndex;\n\n  function onSelect() {\n    onSelectTab(index);\n  }\n\n  useUpdateEffect(() => {\n    if (isSelected && ownRef.current && userInteractedRef.current) {\n      userInteractedRef.current = false;\n      ownRef.current.focus();\n    }\n  }, [isSelected, userInteractedRef]);\n\n  let handleFocus = useEventCallback(\n    wrapEvent(onFocus, () => {\n      setFocusedIndex(index);\n    })\n  );\n\n  let handleBlur = useEventCallback(\n    wrapEvent(onFocus, () => {\n      setFocusedIndex(-1);\n    })\n  );\n\n  return (\n    <Comp\n      // Each element with role `tab` has the property `aria-controls` referring\n      // to its associated `tabpanel` element.\n      // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel\n      aria-controls={makeId(tabsId, \"panel\", index)}\n      aria-disabled={disabled}\n      // The active tab element has the state `aria-selected` set to `true` and\n      // all other tab elements have it set to `false`.\n      // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel\n      aria-selected={isSelected}\n      // Each element that serves as a tab has role `tab` and is contained\n      // within the element with role `tablist`.\n      // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel\n      role=\"tab\"\n      tabIndex={isSelected ? 0 : -1}\n      {...props}\n      ref={ref}\n      data-reach-tab=\"\"\n      data-orientation={orientation}\n      data-selected={isSelected ? \"\" : undefined}\n      disabled={disabled}\n      id={makeId(tabsId, \"tab\", index)}\n      onClick={onSelect}\n      onFocus={handleFocus}\n      onBlur={handleBlur}\n      type={htmlType}\n    >\n      {children}\n    </Comp>\n  );\n});\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/tabs#tab-props\n */\nexport type TabProps = {\n  /**\n   * `Tab` can receive any type of children.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/tabs#tab-children\n   */\n  children?: React.ReactNode;\n  /**\n   * Disables a tab when true. Clicking will not work and keyboard navigation\n   * will skip over it.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/tabs#tab-disabled\n   */\n  disabled?: boolean;\n  index?: number;\n};\n\nif (__DEV__) {\n  Tab.displayName = \"Tab\";\n  Tab.propTypes = {\n    children: PropTypes.node,\n    disabled: PropTypes.bool,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * TabPanels\n *\n * The parent component of the panels.\n *\n * @see Docs https://reacttraining.com/reach-ui/tabs#tabpanels\n */\nconst TabPanelsImpl = forwardRefWithAs<TabPanelsProps, \"div\">(\n  function TabPanels({ children, as: Comp = \"div\", ...props }, forwardedRef) {\n    let ownRef = useRef();\n    let ref = useForkedRef(ownRef, forwardedRef);\n    let [tabPanels, setTabPanels] = useDescendantsInit<TabPanelDescendant>();\n\n    return (\n      <DescendantProvider\n        context={TabPanelDescendantsContext}\n        items={tabPanels}\n        set={setTabPanels}\n      >\n        <Comp {...props} ref={ref} data-reach-tab-panels=\"\">\n          {children}\n        </Comp>\n      </DescendantProvider>\n    );\n  }\n);\n\nif (__DEV__) {\n  TabPanelsImpl.displayName = \"TabPanels\";\n  TabPanelsImpl.propTypes = {\n    as: PropTypes.any,\n    children: PropTypes.node,\n  };\n}\n\nconst TabPanels = memoWithAs(TabPanelsImpl);\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/tabs#tabpanels-props\n */\nexport type TabPanelsProps = TabListProps & {};\n\nif (__DEV__) {\n  TabPanels.displayName = \"TabPanels\";\n}\n\nexport { TabPanels };\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * TabPanel\n *\n * The panel that displays when it's corresponding tab is active.\n *\n * @see Docs https://reacttraining.com/reach-ui/tabs#tabpanel\n */\nexport const TabPanel = forwardRefWithAs<TabPanelProps, \"div\">(\n  function TabPanel(\n    { children, \"aria-label\": ariaLabel, as: Comp = \"div\", ...props },\n    forwardedRef\n  ) {\n    let { selectedPanelRef, selectedIndex, id: tabsId } = useContext(\n      TabsContext\n    );\n    let ownRef = useRef<HTMLElement | null>(null);\n\n    let index = useDescendant(\n      { element: ownRef.current! },\n      TabPanelDescendantsContext\n    );\n\n    let id = makeId(tabsId, \"panel\", index);\n\n    // Because useDescendant will always return -1 on the first render,\n    // `isSelected` will briefly be false for all tabs. We set a tab panel's\n    // hidden attribute based `isSelected` being false, meaning that all tabs\n    // are initially hidden. This makes it impossible for consumers to do\n    // certain things, like focus an element inside the active tab panel when\n    // the page loads. So what we can do is track that a panel is \"ready\" to be\n    // hidden once effects are run (descendants work their magic in\n    // useLayoutEffect, so we can set our ref in useEffecct to run later). We\n    // can use a ref instead of state because we're always geting a re-render\n    // anyway thanks to descendants. This is a little more coupled to the\n    // implementation details of descendants than I'd like, but we'll add a test\n    // to (hopefully) catch any regressions.\n    let isSelected = index === selectedIndex;\n    let readyToHide = useRef(false);\n    let hidden = readyToHide.current ? !isSelected : false;\n    React.useEffect(() => {\n      readyToHide.current = true;\n    }, []);\n\n    let ref = useForkedRef(\n      forwardedRef,\n      ownRef,\n      isSelected ? selectedPanelRef : null\n    );\n\n    return (\n      <Comp\n        // Each element with role `tabpanel` has the property `aria-labelledby`\n        // referring to its associated tab element.\n        aria-labelledby={makeId(tabsId, \"tab\", index)}\n        hidden={hidden}\n        // Each element that contains the content panel for a tab has role\n        // `tabpanel`.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel\n        role=\"tabpanel\"\n        tabIndex={isSelected ? 0 : -1}\n        {...props}\n        ref={ref}\n        data-reach-tab-panel=\"\"\n        id={id}\n      >\n        {children}\n      </Comp>\n    );\n  }\n);\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/tabs#tabpanel-props\n */\nexport type TabPanelProps = {\n  /**\n   * `TabPanel` can receive any type of children.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/tabs#tabpanel-children\n   */\n  children?: React.ReactNode;\n};\n\nif (__DEV__) {\n  TabPanel.displayName = \"TabPanel\";\n  TabPanel.propTypes = {\n    as: PropTypes.any,\n    children: PropTypes.node,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A hook that exposes data for a given `Tabs` component to its descendants.\n *\n * @see Docs https://reacttraining.com/reach-ui/tabs#usetabscontext\n */\nexport function useTabsContext(): TabsContextValue {\n  let { focusedIndex, id, selectedIndex } = useContext(TabsContext);\n  return useMemo(\n    () => ({\n      focusedIndex,\n      id,\n      selectedIndex,\n    }),\n    [focusedIndex, id, selectedIndex]\n  );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\ntype TabDescendant = Descendant<HTMLElement> & {\n  disabled: boolean;\n};\n\ntype TabPanelDescendant = Descendant<HTMLElement>;\n\nexport type TabsContextValue = {\n  focusedIndex: number;\n  id: string;\n  selectedIndex: number;\n};\n\ntype InternalTabsContextValue = {\n  focusedIndex: number;\n  id: string;\n  isControlled: boolean;\n  isRTL: React.MutableRefObject<boolean>;\n  keyboardActivation: TabsKeyboardActivation;\n  onFocusPanel: () => void;\n  onSelectTab: (index: number) => void;\n  onSelectTabWithKeyboard: (index: number) => void;\n  orientation: TabsOrientation;\n  selectedIndex: number;\n  selectedPanelRef: React.MutableRefObject<HTMLElement | null>;\n  setFocusedIndex: React.Dispatch<React.SetStateAction<number>>;\n  setSelectedIndex: React.Dispatch<React.SetStateAction<number>>;\n  userInteractedRef: React.MutableRefObject<boolean>;\n};\n"],
  "mappings": "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",
  "names": ["createDescendantContext", "name", "initialValue", "descendants", "createNamedContext", "registerDescendant", "noop", "unregisterDescendant", "useDescendant", "descendant", "context", "indexProp", "useState", "forceUpdate", "useContext", "index", "findIndex", "item", "element", "previousDescendants", "usePrevious", "someDescendantsHaveChanged", "some", "useIsomorphicLayoutEffect", "Object", "values", "useDescendantsInit", "useDescendants", "ctx", "DescendantProvider", "Ctx", "children", "items", "set", "useCallback", "explicitIndex", "rest", "newItems", "length", "find", "Boolean", "compareDocumentPosition", "Node", "DOCUMENT_POSITION_PRECEDING", "newItem", "slice", "map", "filter", "React", "Provider", "value", "useMemo", "useDescendantKeyDown", "options", "callback", "currentIndex", "key", "orientation", "rotate", "rtl", "handleKeyDown", "event", "includes", "selectableDescendants", "getNextOption", "atBottom", "getFirstOption", "getPreviousOption", "atTop", "getLastOption", "preventDefault", "next", "prev", "nextOrPrev", "prevOrNext", "prevOrFirst", "ctrlKey", "first", "nextOrLast", "last", "serverHandoffComplete", "id", "genId", "useId", "idFromProps", "initialId", "useState", "setId", "useIsomorphicLayoutEffect", "useEffect", "String", "undefined", "TabsDescendantsContext", "createDescendantContext", "TabPanelDescendantsContext", "TabsContext", "createNamedContext", "TabsKeyboardActivation", "TabsOrientation", "Tabs", "forwardRefWithAs", "ref", "as", "Comp", "children", "defaultIndex", "orientation", "Horizontal", "index", "controlledIndex", "undefined", "keyboardActivation", "Auto", "onChange", "readOnly", "props", "isControlled", "useRef", "useControlledSwitchWarning", "_id", "useId", "id", "makeId", "userInteractedRef", "selectedPanelRef", "isRTL", "useControlledState", "selectedIndex", "setSelectedIndex", "useState", "focusedIndex", "setFocusedIndex", "useDescendantsInit", "tabs", "setTabs", "context", "useMemo", "current", "onFocusPanel", "focus", "onSelectTab", "noop", "onSelectTabWithKeyboard", "Manual", "element", "useEffect", "checkStyles", "React", "DescendantProvider", "items", "set", "Provider", "value", "isFunction", "displayName", "propTypes", "PropTypes", "node", "isRequired", "func", "oneOf", "Object", "values", "name", "compName", "location", "propName", "val", "Error", "isNumber", "Array", "isArray", "number", "TabListImpl", "TabList", "forwardedRef", "onKeyDown", "useContext", "useDescendants", "ownRef", "useForkedRef", "ownerDocument", "dir", "getElementComputedStyle", "handleKeyDown", "useEventCallback", "wrapEvent", "useDescendantKeyDown", "currentIndex", "rotate", "callback", "filter", "tab", "disabled", "rtl", "useIsomorphicLayoutEffect", "boolOrBoolString", "next", "find", "role", "Children", "map", "child", "cloneValidElement", "isSelected", "any", "memoWithAs", "Tab", "_", "indexProp", "onBlur", "onFocus", "tabsId", "useDescendant", "htmlType", "type", "onSelect", "useUpdateEffect", "handleFocus", "handleBlur", "tabIndex", "onClick", "bool", "TabPanelsImpl", "TabPanels", "tabPanels", "setTabPanels", "TabPanel", "ariaLabel", "readyToHide", "hidden", "useTabsContext"]
}
