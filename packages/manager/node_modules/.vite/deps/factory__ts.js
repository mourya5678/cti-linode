import {
  __commonJS
} from "./chunk-LFBQMW2U.js";

// ../../node_modules/factory.ts/lib/shared.js
var require_shared = __commonJS({
  "../../node_modules/factory.ts/lib/shared.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uniq = exports.recursivePartialOverride = void 0;
    function recursivePartialOverride(x, y) {
      if (y === void 0 || y === null)
        return x;
      const objProto = Object.getPrototypeOf({});
      if (Object.getPrototypeOf(y) != objProto)
        return y;
      let v = Object.assign({}, x);
      let yKeys = Object.keys(y);
      const allKeys = uniq(Object.keys(v).concat(yKeys));
      for (const key of allKeys) {
        if (yKeys.indexOf(key) >= 0) {
          const itemKeyVal = y[key];
          if (null != itemKeyVal && typeof itemKeyVal === "object") {
            const baseKeyVal = v[key];
            v[key] = recursivePartialOverride(baseKeyVal, itemKeyVal);
          } else {
            v[key] = itemKeyVal;
          }
        }
      }
      return v;
    }
    exports.recursivePartialOverride = recursivePartialOverride;
    function uniq(ts) {
      const out = [];
      for (const v of ts) {
        if (out.indexOf(v) < 0) {
          out.push(v);
        }
      }
      return out;
    }
    exports.uniq = uniq;
  }
});

// ../../node_modules/kind-of/index.js
var require_kind_of = __commonJS({
  "../../node_modules/kind-of/index.js"(exports, module) {
    var toString = Object.prototype.toString;
    module.exports = function kindOf(val) {
      if (val === void 0)
        return "undefined";
      if (val === null)
        return "null";
      var type = typeof val;
      if (type === "boolean")
        return "boolean";
      if (type === "string")
        return "string";
      if (type === "number")
        return "number";
      if (type === "symbol")
        return "symbol";
      if (type === "function") {
        return isGeneratorFn(val) ? "generatorfunction" : "function";
      }
      if (isArray(val))
        return "array";
      if (isBuffer(val))
        return "buffer";
      if (isArguments(val))
        return "arguments";
      if (isDate(val))
        return "date";
      if (isError(val))
        return "error";
      if (isRegexp(val))
        return "regexp";
      switch (ctorName(val)) {
        case "Symbol":
          return "symbol";
        case "Promise":
          return "promise";
        case "WeakMap":
          return "weakmap";
        case "WeakSet":
          return "weakset";
        case "Map":
          return "map";
        case "Set":
          return "set";
        case "Int8Array":
          return "int8array";
        case "Uint8Array":
          return "uint8array";
        case "Uint8ClampedArray":
          return "uint8clampedarray";
        case "Int16Array":
          return "int16array";
        case "Uint16Array":
          return "uint16array";
        case "Int32Array":
          return "int32array";
        case "Uint32Array":
          return "uint32array";
        case "Float32Array":
          return "float32array";
        case "Float64Array":
          return "float64array";
      }
      if (isGeneratorObj(val)) {
        return "generator";
      }
      type = toString.call(val);
      switch (type) {
        case "[object Object]":
          return "object";
        case "[object Map Iterator]":
          return "mapiterator";
        case "[object Set Iterator]":
          return "setiterator";
        case "[object String Iterator]":
          return "stringiterator";
        case "[object Array Iterator]":
          return "arrayiterator";
      }
      return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
    };
    function ctorName(val) {
      return typeof val.constructor === "function" ? val.constructor.name : null;
    }
    function isArray(val) {
      if (Array.isArray)
        return Array.isArray(val);
      return val instanceof Array;
    }
    function isError(val) {
      return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
    }
    function isDate(val) {
      if (val instanceof Date)
        return true;
      return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
    }
    function isRegexp(val) {
      if (val instanceof RegExp)
        return true;
      return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
    }
    function isGeneratorFn(name, val) {
      return ctorName(name) === "GeneratorFunction";
    }
    function isGeneratorObj(val) {
      return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
    }
    function isArguments(val) {
      try {
        if (typeof val.length === "number" && typeof val.callee === "function") {
          return true;
        }
      } catch (err) {
        if (err.message.indexOf("callee") !== -1) {
          return true;
        }
      }
      return false;
    }
    function isBuffer(val) {
      if (val.constructor && typeof val.constructor.isBuffer === "function") {
        return val.constructor.isBuffer(val);
      }
      return false;
    }
  }
});

// ../../node_modules/shallow-clone/index.js
var require_shallow_clone = __commonJS({
  "../../node_modules/shallow-clone/index.js"(exports, module) {
    "use strict";
    var valueOf = Symbol.prototype.valueOf;
    var typeOf = require_kind_of();
    function clone(val, deep) {
      switch (typeOf(val)) {
        case "array":
          return val.slice();
        case "object":
          return Object.assign({}, val);
        case "date":
          return new val.constructor(Number(val));
        case "map":
          return new Map(val);
        case "set":
          return new Set(val);
        case "buffer":
          return cloneBuffer(val);
        case "symbol":
          return cloneSymbol(val);
        case "arraybuffer":
          return cloneArrayBuffer(val);
        case "float32array":
        case "float64array":
        case "int16array":
        case "int32array":
        case "int8array":
        case "uint16array":
        case "uint32array":
        case "uint8clampedarray":
        case "uint8array":
          return cloneTypedArray(val);
        case "regexp":
          return cloneRegExp(val);
        case "error":
          return Object.create(val);
        default: {
          return val;
        }
      }
    }
    function cloneRegExp(val) {
      const flags = val.flags !== void 0 ? val.flags : /\w+$/.exec(val) || void 0;
      const re = new val.constructor(val.source, flags);
      re.lastIndex = val.lastIndex;
      return re;
    }
    function cloneArrayBuffer(val) {
      const res = new val.constructor(val.byteLength);
      new Uint8Array(res).set(new Uint8Array(val));
      return res;
    }
    function cloneTypedArray(val, deep) {
      return new val.constructor(val.buffer, val.byteOffset, val.length);
    }
    function cloneBuffer(val) {
      const len = val.length;
      const buf = Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : Buffer.from(len);
      val.copy(buf);
      return buf;
    }
    function cloneSymbol(val) {
      return valueOf ? Object(valueOf.call(val)) : {};
    }
    module.exports = clone;
  }
});

// ../../node_modules/isobject/index.js
var require_isobject = __commonJS({
  "../../node_modules/isobject/index.js"(exports, module) {
    "use strict";
    module.exports = function isObject(val) {
      return val != null && typeof val === "object" && Array.isArray(val) === false;
    };
  }
});

// ../../node_modules/is-plain-object/index.js
var require_is_plain_object = __commonJS({
  "../../node_modules/is-plain-object/index.js"(exports, module) {
    "use strict";
    var isObject = require_isobject();
    function isObjectObject(o) {
      return isObject(o) === true && Object.prototype.toString.call(o) === "[object Object]";
    }
    module.exports = function isPlainObject(o) {
      var ctor, prot;
      if (isObjectObject(o) === false)
        return false;
      ctor = o.constructor;
      if (typeof ctor !== "function")
        return false;
      prot = ctor.prototype;
      if (isObjectObject(prot) === false)
        return false;
      if (prot.hasOwnProperty("isPrototypeOf") === false) {
        return false;
      }
      return true;
    };
  }
});

// ../../node_modules/clone-deep/index.js
var require_clone_deep = __commonJS({
  "../../node_modules/clone-deep/index.js"(exports, module) {
    "use strict";
    var clone = require_shallow_clone();
    var typeOf = require_kind_of();
    var isPlainObject = require_is_plain_object();
    function cloneDeep(val, instanceClone) {
      switch (typeOf(val)) {
        case "object":
          return cloneObjectDeep(val, instanceClone);
        case "array":
          return cloneArrayDeep(val, instanceClone);
        default: {
          return clone(val);
        }
      }
    }
    function cloneObjectDeep(val, instanceClone) {
      if (typeof instanceClone === "function") {
        return instanceClone(val);
      }
      if (instanceClone || isPlainObject(val)) {
        const res = new val.constructor();
        for (let key in val) {
          res[key] = cloneDeep(val[key], instanceClone);
        }
        return res;
      }
      return val;
    }
    function cloneArrayDeep(val, instanceClone) {
      const res = new val.constructor(val.length);
      for (let i = 0; i < val.length; i++) {
        res[i] = cloneDeep(val[i], instanceClone);
      }
      return res;
    }
    module.exports = cloneDeep;
  }
});

// ../../node_modules/factory.ts/lib/sync.js
var require_sync = __commonJS({
  "../../node_modules/factory.ts/lib/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeFactoryWithRequired = exports.makeFactory = exports.each = exports.val = exports.Factory = exports.Derived = exports.Generator = void 0;
    var shared_1 = require_shared();
    var cloneDeep = require_clone_deep();
    var Generator = class {
      constructor(func) {
        this.func = func;
      }
      build(seq) {
        return this.func(seq);
      }
    };
    exports.Generator = Generator;
    var Derived = class {
      constructor(func) {
        this.func = func;
      }
      build(owner, seq) {
        const ret = this.func(owner, seq);
        return ret;
      }
    };
    exports.Derived = Derived;
    var Factory = class {
      constructor(builder, config) {
        this.builder = builder;
        this.config = config;
        this.getStartingSequenceNumber = () => this.config && this.config.startingSequenceNumber || 0;
        this.build = (item) => {
          const seqNum = this.seqNum;
          this.seqNum++;
          const base = buildBase(seqNum, this.builder);
          let v = Object.assign({}, base.value);
          if (item) {
            v = shared_1.recursivePartialOverride(v, item);
          }
          const keys = Object.keys(item || {});
          for (const der of base.derived) {
            if (keys.indexOf(der.key) < 0) {
              v[der.key] = der.derived.build(v, seqNum);
            }
          }
          return v;
        };
        this.buildList = (count, item) => {
          const ts = Array(count);
          for (let i = 0; i < count; i++) {
            ts[i] = this.build(item);
          }
          return ts;
        };
        this.seqNum = this.getStartingSequenceNumber();
      }
      resetSequenceNumber() {
        this.seqNum = this.getStartingSequenceNumber();
      }
      extend(def) {
        const builder = Object.assign({}, this.builder, def);
        return new Factory(builder, this.config);
      }
      combine(other) {
        const builder = Object.assign({}, this.builder, other.builder);
        return new Factory(builder, this.config);
      }
      withDerivation(kOut, f) {
        const partial = {};
        partial[kOut] = new Derived(f);
        return this.extend(partial);
      }
      withDerivation1(kInput, kOut, f) {
        const partial = {};
        partial[kOut] = new Derived((t, i) => f(t[kInput[0]], i));
        return this.extend(partial);
      }
      withDerivation2(kInput, kOut, f) {
        const partial = {};
        partial[kOut] = new Derived((t, i) => f(t[kInput[0]], t[kInput[1]], i));
        return this.extend(partial);
      }
      withDerivation3(kInput, kOut, f) {
        const partial = {};
        partial[kOut] = new Derived((t, i) => f(t[kInput[0]], t[kInput[1]], t[kInput[2]], i));
        return this.extend(partial);
      }
      withDerivation4(kInput, kOut, f) {
        const partial = {};
        partial[kOut] = new Derived((t, i) => f(t[kInput[0]], t[kInput[1]], t[kInput[2]], t[kInput[3]], i));
        return this.extend(partial);
      }
      withDerivation5(kInput, kOut, f) {
        const partial = {};
        partial[kOut] = new Derived((t, i) => f(t[kInput[0]], t[kInput[1]], t[kInput[2]], t[kInput[3]], t[kInput[4]], i));
        return this.extend(partial);
      }
    };
    exports.Factory = Factory;
    function val(val2) {
      return new Generator(() => val2);
    }
    exports.val = val;
    function each(f) {
      return new Generator(f);
    }
    exports.each = each;
    function buildBase(seqNum, builder) {
      const t = {};
      const keys = Object.getOwnPropertyNames(builder);
      const derived = [];
      for (const key of keys) {
        const v = builder[key];
        let value = v;
        if (!!v && typeof v === "object") {
          if (v.constructor === Generator) {
            value = v.build(seqNum);
          } else if (v.constructor == Derived) {
            derived.push({ key, derived: v });
          } else {
            value = cloneDeep(v);
          }
        }
        t[key] = value;
      }
      return { value: t, derived };
    }
    function makeFactory(builder, config) {
      return new Factory(builder, config);
    }
    exports.makeFactory = makeFactory;
    function makeFactoryWithRequired(builder, config) {
      return new Factory(builder, config);
    }
    exports.makeFactoryWithRequired = makeFactoryWithRequired;
  }
});

// ../../node_modules/factory.ts/lib/async.js
var require_async = __commonJS({
  "../../node_modules/factory.ts/lib/async.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeFactoryFromSync = exports.makeFactoryWithRequired = exports.makeFactory = exports.each = exports.val = exports.TransformFactory = exports.Factory = exports.Derived = exports.Generator = exports.lift = void 0;
    var shared_1 = require_shared();
    var Sync = require_sync();
    var cloneDeep = require_clone_deep();
    function isPromise(t) {
      return typeof t["then"] === "function";
    }
    function lift(t) {
      if (isPromise(t)) {
        return t;
      } else {
        return Promise.resolve(t);
      }
    }
    exports.lift = lift;
    var Generator = class {
      constructor(func) {
        this.func = func;
      }
      build(seq) {
        return lift(this.func(seq));
      }
    };
    exports.Generator = Generator;
    var Derived = class {
      constructor(func) {
        this.func = func;
      }
      build(owner, seq) {
        return lift(this.func(owner, seq));
      }
    };
    exports.Derived = Derived;
    var Factory = class {
      constructor(builder, config) {
        this.builder = builder;
        this.config = config;
        this.getStartingSequenceNumber = () => this.config && this.config.startingSequenceNumber || 0;
        this.build = (item) => __awaiter(this, void 0, void 0, function* () {
          const seqNum = this.seqNum;
          this.seqNum++;
          const base = yield buildBase(seqNum, this.builder);
          let v = Object.assign({}, base.value);
          if (item) {
            v = shared_1.recursivePartialOverride(v, item);
          }
          const keys = Object.keys(item || {});
          for (const der of base.derived) {
            if (keys.indexOf(der.key) < 0) {
              v[der.key] = yield der.derived.build(v, seqNum);
            }
          }
          return lift(v);
        });
        this.buildList = (count, item) => __awaiter(this, void 0, void 0, function* () {
          const ts = Array(count);
          for (let i = 0; i < count; i++) {
            ts[i] = yield this.build(item);
          }
          return ts;
        });
        this.seqNum = this.getStartingSequenceNumber();
      }
      resetSequenceNumber() {
        this.seqNum = this.getStartingSequenceNumber();
      }
      extend(def) {
        const builder = Object.assign({}, this.builder, def);
        return new Factory(builder, this.config);
      }
      combine(other) {
        const builder = Object.assign({}, this.builder, other.builder);
        return new Factory(builder, this.config);
      }
      transform(fn) {
        return new TransformFactory(this, fn);
      }
      withDerivation(kOut, f) {
        const partial = {};
        partial[kOut] = new Derived(f);
        return this.extend(partial);
      }
      withDerivation1(kInput, kOut, f) {
        const partial = {};
        partial[kOut] = new Derived((t, i) => f(t[kInput[0]], i));
        return this.extend(partial);
      }
      withDerivation2(kInput, kOut, f) {
        const partial = {};
        partial[kOut] = new Derived((t, i) => f(t[kInput[0]], t[kInput[1]], i));
        return this.extend(partial);
      }
      withDerivation3(kInput, kOut, f) {
        const partial = {};
        partial[kOut] = new Derived((t, i) => f(t[kInput[0]], t[kInput[1]], t[kInput[2]], i));
        return this.extend(partial);
      }
      withDerivation4(kInput, kOut, f) {
        const partial = {};
        partial[kOut] = new Derived((t, i) => f(t[kInput[0]], t[kInput[1]], t[kInput[2]], t[kInput[3]], i));
        return this.extend(partial);
      }
      withDerivation5(kInput, kOut, f) {
        const partial = {};
        partial[kOut] = new Derived((t, i) => f(t[kInput[0]], t[kInput[1]], t[kInput[2]], t[kInput[3]], t[kInput[4]], i));
        return this.extend(partial);
      }
    };
    exports.Factory = Factory;
    var TransformFactory = class {
      constructor(inner, transform) {
        this.inner = inner;
        this.transform = transform;
        this.build = (item) => __awaiter(this, void 0, void 0, function* () {
          const v = yield this.inner.build(item);
          const u = yield lift(this.transform(v));
          return u;
        });
        this.buildList = (count, item) => __awaiter(this, void 0, void 0, function* () {
          const vs = yield this.inner.buildList(count, item);
          return Promise.all(vs.map(this.transform).map(lift));
        });
      }
    };
    exports.TransformFactory = TransformFactory;
    function val(val2) {
      return new Generator(() => val2);
    }
    exports.val = val;
    function each(f) {
      return new Generator(f);
    }
    exports.each = each;
    function buildBase(seqNum, builder) {
      return __awaiter(this, void 0, void 0, function* () {
        const t = {};
        const keys = Object.getOwnPropertyNames(builder);
        const derived = [];
        for (const key of keys) {
          const v = builder[key];
          let value = v;
          if (!!v && typeof v === "object") {
            if (isPromise(v)) {
              value = yield v;
            } else if (v.constructor === Generator) {
              value = yield v.build(seqNum);
            } else if (v.constructor == Derived) {
              derived.push({ key, derived: v });
            } else if (v.constructor === Sync.Generator) {
              value = v.build(seqNum);
            } else if (v.constructor == Sync.Derived) {
              derived.push({ key, derived: new Derived(v.func) });
            } else {
              value = cloneDeep(v);
            }
          }
          t[key] = value;
        }
        return { value: t, derived };
      });
    }
    function makeFactory(builder, config) {
      return new Factory(builder, config);
    }
    exports.makeFactory = makeFactory;
    function makeFactoryWithRequired(builder, config) {
      return new Factory(builder, config);
    }
    exports.makeFactoryWithRequired = makeFactoryWithRequired;
    function makeFactoryFromSync(builder, config) {
      return new Factory(builder, config);
    }
    exports.makeFactoryFromSync = makeFactoryFromSync;
  }
});

// ../../node_modules/factory.ts/lib/pipeline.js
var require_pipeline = __commonJS({
  "../../node_modules/factory.ts/lib/pipeline.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Pipeline = void 0;
    var Async = require_async();
    var Pipeline = class {
      constructor(current) {
        this.current = current;
      }
      static start() {
        return new Pipeline(Promise.resolve({}));
      }
      //add<T,U>(factory: Async.IFactory<T,U> | Async.FactoryFunc<T,U>, val: Parti (p:P) => Partial<T>)
      addValues(val) {
        return new Pipeline(this.current.then((c) => __awaiter(this, void 0, void 0, function* () {
          const v = typeof val === "function" ? yield Async.lift(val(c)) : val;
          return Object.assign(Object.assign({}, c), v);
        })));
      }
      // NOTE: want to combine all addFactory() methods, but
      // Typescript and or ts-node seems to have problems
      // also want use object { key: partial } instead
      // but can't get the types right
      addFactoryFunc(factory, key, partial) {
        return new Pipeline(this.current.then((c) => __awaiter(this, void 0, void 0, function* () {
          const p = typeof partial === "function" ? yield Async.lift(partial(c)) : partial;
          const val = yield factory(p);
          const newV = {};
          newV[key] = val;
          return Object.assign(Object.assign({}, c), newV);
        })));
      }
      addFactory(factory, key, partial) {
        return this.addFactoryFunc((v) => factory.build(v), key, partial);
      }
      addTxFactory(factory, key, partial) {
        return this.addFactoryFunc((v) => factory.build(v), key, partial);
      }
      then(onfulfilled, onrejected) {
        return this.current.then(onfulfilled, onrejected);
      }
    };
    exports.Pipeline = Pipeline;
  }
});

// ../../node_modules/factory.ts/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/factory.ts/lib/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeFactory = exports.each = exports.val = exports.Factory = exports.Derived = exports.Generator = exports.Pipeline = exports.Sync = exports.Async = void 0;
    var Async = require_async();
    exports.Async = Async;
    var Sync = require_sync();
    exports.Sync = Sync;
    var Pipeline = require_pipeline();
    exports.Pipeline = Pipeline;
    var sync_1 = require_sync();
    Object.defineProperty(exports, "Generator", { enumerable: true, get: function() {
      return sync_1.Generator;
    } });
    Object.defineProperty(exports, "Derived", { enumerable: true, get: function() {
      return sync_1.Derived;
    } });
    Object.defineProperty(exports, "Factory", { enumerable: true, get: function() {
      return sync_1.Factory;
    } });
    Object.defineProperty(exports, "val", { enumerable: true, get: function() {
      return sync_1.val;
    } });
    Object.defineProperty(exports, "each", { enumerable: true, get: function() {
      return sync_1.each;
    } });
    Object.defineProperty(exports, "makeFactory", { enumerable: true, get: function() {
      return sync_1.makeFactory;
    } });
  }
});
export default require_lib();
/*! Bundled license information:

shallow-clone/index.js:
  (*!
   * shallow-clone <https://github.com/jonschlinkert/shallow-clone>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

isobject/index.js:
  (*!
   * isobject <https://github.com/jonschlinkert/isobject>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-plain-object/index.js:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=factory__ts.js.map
