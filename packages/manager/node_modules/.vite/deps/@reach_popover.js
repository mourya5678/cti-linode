import {
  observe_rect_esm_default,
  require_tabbable
} from "./chunk-LUXDPJAP.js";
import {
  getOwnerDocument,
  useForkedRef,
  useIsomorphicLayoutEffect
} from "./chunk-P6EZSIYQ.js";
import "./chunk-6GLVATRU.js";
import {
  require_react_dom
} from "./chunk-66PEM4UL.js";
import {
  require_prop_types
} from "./chunk-PLEWTTGR.js";
import "./chunk-NGRKVEHQ.js";
import {
  require_react
} from "./chunk-CPU6GBAM.js";
import {
  __toESM
} from "./chunk-LFBQMW2U.js";

// ../../node_modules/@reach/popover/dist/popover.esm.js
var import_react3 = __toESM(require_react());

// ../../node_modules/@reach/portal/dist/portal.esm.js
var import_react = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
var Portal = function Portal2(_ref) {
  var children = _ref.children, _ref$type = _ref.type, type = _ref$type === void 0 ? "reach-portal" : _ref$type;
  var mountNode = (0, import_react.useRef)(null);
  var portalNode = (0, import_react.useRef)(null);
  var _useState = (0, import_react.useState)(), forceUpdate = _useState[1];
  useIsomorphicLayoutEffect(function() {
    if (!mountNode.current)
      return;
    var ownerDocument = mountNode.current.ownerDocument;
    portalNode.current = ownerDocument === null || ownerDocument === void 0 ? void 0 : ownerDocument.createElement(type);
    ownerDocument.body.appendChild(portalNode.current);
    forceUpdate({});
    return function() {
      if (portalNode.current && portalNode.current.ownerDocument) {
        portalNode.current.ownerDocument.body.removeChild(portalNode.current);
      }
    };
  }, [type]);
  return portalNode.current ? (0, import_react_dom.createPortal)(children, portalNode.current) : import_react.default.createElement("span", {
    ref: mountNode
  });
};
if (true) {
  Portal.displayName = "Portal";
}
var portal_esm_default = Portal;

// ../../node_modules/@reach/rect/dist/rect.esm.js
var import_react2 = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
var Rect = function Rect2(_ref) {
  var onChange = _ref.onChange, _ref$observe = _ref.observe, observe = _ref$observe === void 0 ? true : _ref$observe, children = _ref.children;
  var ref = (0, import_react2.useRef)(null);
  var rect = useRect(ref, observe, onChange);
  return children({
    ref,
    rect
  });
};
if (true) {
  Rect.displayName = "Rect";
  Rect.propTypes = {
    children: import_prop_types.default.func.isRequired,
    observe: import_prop_types.default.bool,
    onChange: import_prop_types.default.func
  };
}
function useRect(nodeRef, observe, onChange) {
  if (observe === void 0) {
    observe = true;
  }
  var _useState = (0, import_react2.useState)(nodeRef.current), element = _useState[0], setElement = _useState[1];
  var initialRectIsSet = (0, import_react2.useRef)(false);
  var initialRefIsSet = (0, import_react2.useRef)(false);
  var _useState2 = (0, import_react2.useState)(null), rect = _useState2[0], setRect = _useState2[1];
  var onChangeRef = (0, import_react2.useRef)();
  useIsomorphicLayoutEffect(function() {
    onChangeRef.current = onChange;
    if (nodeRef.current !== element) {
      setElement(nodeRef.current);
    }
  });
  useIsomorphicLayoutEffect(function() {
    if (element && !initialRectIsSet.current) {
      initialRectIsSet.current = true;
      setRect(element.getBoundingClientRect());
    }
  }, [element]);
  useIsomorphicLayoutEffect(function() {
    var observer;
    var elem = element;
    if (!initialRefIsSet.current) {
      initialRefIsSet.current = true;
      elem = nodeRef.current;
    }
    if (!elem) {
      if (true) {
        console.warn("You need to place the ref");
      }
      return cleanup;
    }
    observer = observe_rect_esm_default(elem, function(rect2) {
      onChangeRef.current && onChangeRef.current(rect2);
      setRect(rect2);
    });
    observe && observer.observe();
    return cleanup;
    function cleanup() {
      observer && observer.unobserve();
    }
  }, [observe, element]);
  return rect;
}

// ../../node_modules/@reach/popover/dist/popover.esm.js
var import_tabbable = __toESM(require_tabbable());
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var Popover = (0, import_react3.forwardRef)(function Popover2(props, ref) {
  return import_react3.default.createElement(portal_esm_default, null, import_react3.default.createElement(PopoverImpl, Object.assign({
    ref
  }, props)));
});
if (true) {
  Popover.displayName = "Popover";
}
var PopoverImpl = (0, import_react3.forwardRef)(function PopoverImpl2(_ref, forwardedRef) {
  var targetRef = _ref.targetRef, _ref$position = _ref.position, position = _ref$position === void 0 ? positionDefault : _ref$position, _ref$unstable_observa = _ref.unstable_observableRefs, unstable_observableRefs = _ref$unstable_observa === void 0 ? [] : _ref$unstable_observa, props = _objectWithoutPropertiesLoose(_ref, ["targetRef", "position", "unstable_observableRefs"]);
  var popoverRef = (0, import_react3.useRef)(null);
  var popoverRect = useRect(popoverRef);
  var targetRect = useRect(targetRef);
  var ref = useForkedRef(popoverRef, forwardedRef);
  useSimulateTabNavigationForReactTree(targetRef, popoverRef);
  return import_react3.default.createElement("div", Object.assign({
    "data-reach-popover": "",
    ref
  }, props, {
    style: _extends({
      position: "absolute"
    }, getStyles.apply(void 0, [position, targetRect, popoverRect].concat(unstable_observableRefs)), props.style)
  }));
});
if (true) {
  PopoverImpl.displayName = "PopoverImpl";
}
function getStyles(position, targetRect, popoverRect) {
  for (var _len = arguments.length, unstable_observableRefs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    unstable_observableRefs[_key - 3] = arguments[_key];
  }
  return popoverRect ? position.apply(void 0, [targetRect, popoverRect].concat(unstable_observableRefs.map(function(ref) {
    return ref.current;
  }))) : {
    visibility: "hidden"
  };
}
function getTopPosition(targetRect, popoverRect) {
  var _getCollisions = getCollisions(targetRect, popoverRect), directionUp = _getCollisions.directionUp;
  return {
    top: directionUp ? targetRect.top - popoverRect.height + window.pageYOffset + "px" : targetRect.top + targetRect.height + window.pageYOffset + "px"
  };
}
var positionDefault = function positionDefault2(targetRect, popoverRect) {
  if (!targetRect || !popoverRect) {
    return {};
  }
  var _getCollisions2 = getCollisions(targetRect, popoverRect), directionRight = _getCollisions2.directionRight;
  return _extends({
    left: directionRight ? targetRect.right - popoverRect.width + window.pageXOffset + "px" : targetRect.left + window.pageXOffset + "px"
  }, getTopPosition(targetRect, popoverRect));
};
var positionRight = function positionRight2(targetRect, popoverRect) {
  if (!targetRect || !popoverRect) {
    return {};
  }
  var _getCollisions3 = getCollisions(targetRect, popoverRect), directionLeft = _getCollisions3.directionLeft;
  return _extends({
    left: directionLeft ? targetRect.left + window.pageXOffset + "px" : targetRect.right - popoverRect.width + window.pageXOffset + "px"
  }, getTopPosition(targetRect, popoverRect));
};
var positionMatchWidth = function positionMatchWidth2(targetRect, popoverRect) {
  if (!targetRect || !popoverRect) {
    return {};
  }
  return _extends({
    width: targetRect.width,
    left: targetRect.left
  }, getTopPosition(targetRect, popoverRect));
};
function getCollisions(targetRect, popoverRect, offsetLeft, offsetBottom) {
  if (offsetLeft === void 0) {
    offsetLeft = 0;
  }
  if (offsetBottom === void 0) {
    offsetBottom = 0;
  }
  var collisions = {
    top: targetRect.top - popoverRect.height < 0,
    right: window.innerWidth < targetRect.left + popoverRect.width - offsetLeft,
    bottom: window.innerHeight < targetRect.bottom + popoverRect.height - offsetBottom,
    left: targetRect.left + targetRect.width - popoverRect.width < 0
  };
  var directionRight = collisions.right && !collisions.left;
  var directionLeft = collisions.left && !collisions.right;
  var directionUp = collisions.bottom && !collisions.top;
  var directionDown = collisions.top && !collisions.bottom;
  return {
    directionRight,
    directionLeft,
    directionUp,
    directionDown
  };
}
function useSimulateTabNavigationForReactTree(triggerRef, popoverRef) {
  var ownerDocument = getOwnerDocument(triggerRef.current);
  function handleKeyDown(event) {
    if (event.key === "Tab" && popoverRef.current && (0, import_tabbable.default)(popoverRef.current).length === 0) {
      return;
    }
    if (event.key === "Tab" && event.shiftKey) {
      if (shiftTabbedFromElementAfterTrigger(event)) {
        focusLastTabbableInPopover(event);
      } else if (shiftTabbedOutOfPopover(event)) {
        focusTriggerRef(event);
      } else if (shiftTabbedToBrowserChrome(event)) {
        disableTabbablesInPopover();
      }
    } else if (event.key === "Tab") {
      if (tabbedFromTriggerToPopover()) {
        focusFirstPopoverTabbable(event);
      } else if (tabbedOutOfPopover()) {
        focusTabbableAfterTrigger(event);
      } else if (tabbedToBrowserChrome(event)) {
        disableTabbablesInPopover();
      }
    }
  }
  (0, import_react3.useEffect)(function() {
    if (ownerDocument) {
      ownerDocument.addEventListener("keydown", handleKeyDown);
      return function() {
        ownerDocument.removeEventListener("keydown", handleKeyDown);
      };
    }
    return;
  }, []);
  function getElementAfterTrigger() {
    var elements = ownerDocument && (0, import_tabbable.default)(ownerDocument);
    var targetIndex = elements && triggerRef.current ? elements.indexOf(triggerRef.current) : -1;
    var elementAfterTrigger = elements && elements[targetIndex + 1];
    return popoverRef.current && popoverRef.current.contains(elementAfterTrigger || null) ? false : elementAfterTrigger;
  }
  function tabbedFromTriggerToPopover() {
    return triggerRef.current && ownerDocument ? triggerRef.current === ownerDocument.activeElement : false;
  }
  function focusFirstPopoverTabbable(event) {
    var elements = popoverRef.current && (0, import_tabbable.default)(popoverRef.current);
    if (elements && elements[0]) {
      event.preventDefault();
      elements[0].focus();
    }
  }
  function tabbedOutOfPopover() {
    var inPopover = popoverRef.current && ownerDocument ? popoverRef.current.contains(ownerDocument.activeElement || null) : false;
    if (inPopover) {
      var elements = popoverRef.current && (0, import_tabbable.default)(popoverRef.current);
      return Boolean(elements && ownerDocument && elements[elements.length - 1] === ownerDocument.activeElement);
    }
    return false;
  }
  function focusTabbableAfterTrigger(event) {
    var elementAfterTrigger = getElementAfterTrigger();
    if (elementAfterTrigger) {
      event.preventDefault();
      elementAfterTrigger.focus();
    }
  }
  function shiftTabbedFromElementAfterTrigger(event) {
    if (!event.shiftKey)
      return;
    var elementAfterTrigger = getElementAfterTrigger();
    return event.target === elementAfterTrigger;
  }
  function focusLastTabbableInPopover(event) {
    var elements = popoverRef.current && (0, import_tabbable.default)(popoverRef.current);
    var last = elements && elements[elements.length - 1];
    if (last) {
      event.preventDefault();
      last.focus();
    }
  }
  function shiftTabbedOutOfPopover(event) {
    var elements = popoverRef.current && (0, import_tabbable.default)(popoverRef.current);
    if (elements) {
      return elements.length === 0 ? false : event.target === elements[0];
    }
    return false;
  }
  function focusTriggerRef(event) {
    var _triggerRef$current;
    event.preventDefault();
    (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : _triggerRef$current.focus();
  }
  function tabbedToBrowserChrome(event) {
    var elements = ownerDocument && popoverRef.current ? (0, import_tabbable.default)(ownerDocument).filter(function(element) {
      return !popoverRef.current.contains(element);
    }) : null;
    return elements ? event.target === elements[elements.length - 1] : false;
  }
  function shiftTabbedToBrowserChrome(event) {
    return ownerDocument ? event.target === (0, import_tabbable.default)(ownerDocument)[0] : false;
  }
  var restoreTabIndexTuplés = [];
  function disableTabbablesInPopover() {
    var elements = popoverRef.current && (0, import_tabbable.default)(popoverRef.current);
    if (elements) {
      elements.forEach(function(element) {
        restoreTabIndexTuplés.push([element, element.tabIndex]);
        element.tabIndex = -1;
      });
      ownerDocument && ownerDocument.addEventListener("focusin", enableTabbablesInPopover);
    }
  }
  function enableTabbablesInPopover() {
    ownerDocument && ownerDocument.removeEventListener("focusin", enableTabbablesInPopover);
    restoreTabIndexTuplés.forEach(function(_ref2) {
      var element = _ref2[0], tabIndex = _ref2[1];
      element.tabIndex = tabIndex;
    });
  }
}
var popover_esm_default = Popover;
export {
  popover_esm_default as default,
  getCollisions,
  positionDefault,
  positionMatchWidth,
  positionRight
};
//# sourceMappingURL=@reach_popover.js.map
