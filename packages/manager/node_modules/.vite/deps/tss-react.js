import {
  Global,
  __unsafe_useEmotionCache,
  css,
  getRegisteredStyles,
  init_emotion_react_browser_esm,
  init_emotion_serialize_browser_esm,
  init_emotion_utils_browser_esm,
  insertStyles,
  keyframes,
  serializeStyles
} from "./chunk-LMS2CM5M.js";
import "./chunk-AXR745JJ.js";
import "./chunk-S5Y2Q5O2.js";
import "./chunk-NGRKVEHQ.js";
import {
  require_react
} from "./chunk-CPU6GBAM.js";
import {
  __toESM
} from "./chunk-LFBQMW2U.js";

// ../../node_modules/tss-react/esm/makeStyles.js
var import_react2 = __toESM(require_react());

// ../../node_modules/tss-react/esm/tools/polyfills/Object.fromEntries.js
var objectFromEntries = !Object.fromEntries ? (entries) => {
  if (!entries || !entries[Symbol.iterator]) {
    throw new Error("Object.fromEntries() requires a single iterable argument");
  }
  const o = {};
  Object.keys(entries).forEach((key) => {
    const [k, v] = entries[key];
    o[k] = v;
  });
  return o;
} : Object.fromEntries;

// ../../node_modules/tss-react/esm/tools/objectKeys.js
function objectKeys(o) {
  return Object.keys(o);
}

// ../../node_modules/tss-react/esm/tools/assert.js
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}

// ../../node_modules/tss-react/esm/tools/typeGuard.js
function typeGuard(_value, isMatched) {
  return isMatched;
}

// ../../node_modules/tss-react/esm/tools/classnames.js
var classnames = (args) => {
  const len = args.length;
  let i = 0;
  let cls = "";
  for (; i < len; i++) {
    const arg = args[i];
    if (arg == null)
      continue;
    let toAdd;
    switch (typeof arg) {
      case "boolean":
        break;
      case "object": {
        if (Array.isArray(arg)) {
          toAdd = classnames(arg);
        } else {
          assert(!typeGuard(arg, false));
          if (arg.styles !== void 0 && arg.name !== void 0) {
            console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.");
          }
          toAdd = "";
          for (const k in arg) {
            if (arg[k] && k) {
              toAdd && (toAdd += " ");
              toAdd += k;
            }
          }
        }
        break;
      }
      default: {
        toAdd = arg;
      }
    }
    if (toAdd) {
      cls && (cls += " ");
      cls += toAdd;
    }
  }
  return cls;
};

// ../../node_modules/tss-react/esm/cssAndCx.js
init_emotion_serialize_browser_esm();
init_emotion_utils_browser_esm();

// ../../node_modules/tss-react/esm/tools/useGuaranteedMemo.js
var import_react = __toESM(require_react());
function useGuaranteedMemo(fn, deps) {
  const ref = (0, import_react.useRef)();
  if (!ref.current || deps.length !== ref.current.prevDeps.length || ref.current.prevDeps.map((v, i) => v === deps[i]).indexOf(false) >= 0) {
    ref.current = {
      "v": fn(),
      "prevDeps": [...deps]
    };
  }
  return ref.current.v;
}

// ../../node_modules/tss-react/esm/types.js
function matchCSSObject(arg) {
  return arg instanceof Object && !("styles" in arg) && !("length" in arg) && !("__emotion_styles" in arg);
}

// ../../node_modules/tss-react/esm/cssAndCx.js
var { createCssAndCx } = (() => {
  function merge(registered, css2, className) {
    const registeredStyles = [];
    const rawClassName = getRegisteredStyles(registered, registeredStyles, className);
    if (registeredStyles.length < 2) {
      return className;
    }
    return rawClassName + css2(registeredStyles);
  }
  function createCssAndCx2(params) {
    const { cache } = params;
    const css2 = (...args) => {
      const serialized = serializeStyles(args, cache.registered);
      insertStyles(cache, serialized, false);
      const className = `${cache.key}-${serialized.name}`;
      scope: {
        const arg = args[0];
        if (!matchCSSObject(arg)) {
          break scope;
        }
        increaseSpecificityToTakePrecedenceOverMediaQueries.saveClassNameCSSObjectMapping(cache, className, arg);
      }
      return className;
    };
    const cx = (...args) => {
      const className = classnames(args);
      const feat27FixedClassnames = increaseSpecificityToTakePrecedenceOverMediaQueries.fixClassName(cache, className, css2);
      return merge(cache.registered, css2, feat27FixedClassnames);
    };
    return { css: css2, cx };
  }
  return { createCssAndCx: createCssAndCx2 };
})();
function createUseCssAndCx(params) {
  const { useCache } = params;
  function useCssAndCx() {
    const cache = useCache();
    const { css: css2, cx } = useGuaranteedMemo(() => createCssAndCx({ cache }), [cache]);
    return { css: css2, cx };
  }
  return { useCssAndCx };
}
var increaseSpecificityToTakePrecedenceOverMediaQueries = (() => {
  const cssObjectMapByCache = /* @__PURE__ */ new WeakMap();
  return {
    "saveClassNameCSSObjectMapping": (cache, className, cssObject) => {
      let cssObjectMap = cssObjectMapByCache.get(cache);
      if (cssObjectMap === void 0) {
        cssObjectMap = /* @__PURE__ */ new Map();
        cssObjectMapByCache.set(cache, cssObjectMap);
      }
      cssObjectMap.set(className, cssObject);
    },
    "fixClassName": (() => {
      function fix(classNameCSSObjects) {
        let isThereAnyMediaQueriesInPreviousClasses = false;
        return classNameCSSObjects.map(([className, cssObject]) => {
          if (cssObject === void 0) {
            return className;
          }
          let out;
          if (!isThereAnyMediaQueriesInPreviousClasses) {
            out = className;
            for (const key in cssObject) {
              if (key.startsWith("@media")) {
                isThereAnyMediaQueriesInPreviousClasses = true;
                break;
              }
            }
          } else {
            out = {
              "&&": cssObject
            };
          }
          return out;
        });
      }
      return (cache, className, css2) => {
        const cssObjectMap = cssObjectMapByCache.get(cache);
        return classnames(fix(className.split(" ").map((className2) => [
          className2,
          cssObjectMap == null ? void 0 : cssObjectMap.get(className2)
        ])).map((classNameOrCSSObject) => typeof classNameOrCSSObject === "string" ? classNameOrCSSObject : css2(classNameOrCSSObject)));
      };
    })()
  };
})();

// ../../node_modules/tss-react/esm/tools/getDependencyArrayRef.js
function getDependencyArrayRef(obj) {
  if (!(obj instanceof Object) || typeof obj === "function") {
    return obj;
  }
  const arr = [];
  for (const key in obj) {
    const value = obj[key];
    const typeofValue = typeof value;
    if (!(typeofValue === "string" || typeofValue === "number" && !isNaN(value) || typeofValue === "boolean" || value === void 0 || value === null)) {
      return obj;
    }
    arr.push(`${key}:${typeofValue}_${value}`);
  }
  return "xSqLiJdLMd9s" + arr.join("|");
}

// ../../node_modules/tss-react/esm/mergeClasses.js
function mergeClasses(classesFromUseStyles, classesFromProps, cx) {
  if (!(classesFromProps instanceof Object)) {
    return classesFromUseStyles;
  }
  const out = {};
  objectKeys(classesFromUseStyles).forEach((ruleName) => out[ruleName] = cx(classesFromUseStyles[ruleName], classesFromProps[ruleName]));
  objectKeys(classesFromProps).forEach((ruleName) => {
    if (ruleName in classesFromUseStyles) {
      return;
    }
    const className = classesFromProps[ruleName];
    if (typeof className !== "string") {
      return;
    }
    out[ruleName] = className;
  });
  return out;
}

// ../../node_modules/tss-react/esm/makeStyles.js
var import_react3 = __toESM(require_react());
init_emotion_react_browser_esm();
"use client";
var counter = 0;
function createMakeStyles(params) {
  const { useTheme, cache: cacheProvidedAtInception } = params;
  function useCache() {
    const contextualCache = __unsafe_useEmotionCache();
    const cacheExplicitlyProvidedForTss = useCacheProvidedByProvider();
    const cacheToBeUsed = cacheProvidedAtInception ?? cacheExplicitlyProvidedForTss ?? contextualCache;
    if (cacheToBeUsed === null) {
      throw new Error([
        "In order to get SSR working with tss-react you need to explicitly provide an Emotion cache.",
        "MUI users be aware: This is not an error strictly related to tss-react, with or without tss-react,",
        "MUI needs an Emotion cache to be provided for SSR to work.",
        "Here is the MUI documentation related to SSR setup: https://mui.com/material-ui/guides/server-rendering/",
        "TSS provides helper that makes the process of setting up SSR easier: https://docs.tss-react.dev/ssr"
      ].join("\n"));
    }
    return cacheToBeUsed;
  }
  const { useCssAndCx } = createUseCssAndCx({ useCache });
  function makeStyles(params2) {
    const { name: nameOrWrappedName, uniqId = counter++ } = params2 ?? {};
    const name = typeof nameOrWrappedName !== "object" ? nameOrWrappedName : Object.keys(nameOrWrappedName)[0];
    return function(cssObjectByRuleNameOrGetCssObjectByRuleName) {
      const getCssObjectByRuleName = typeof cssObjectByRuleNameOrGetCssObjectByRuleName === "function" ? cssObjectByRuleNameOrGetCssObjectByRuleName : () => cssObjectByRuleNameOrGetCssObjectByRuleName;
      return function useStyles2(params3, styleOverrides) {
        var _a, _b;
        const theme = useTheme();
        const { css: css2, cx } = useCssAndCx();
        const cache = useCache();
        let classes = (0, import_react2.useMemo)(() => {
          const refClassesCache = {};
          const refClasses = typeof Proxy !== "undefined" && new Proxy({}, {
            "get": (_target, propertyKey) => {
              if (typeof propertyKey === "symbol") {
                assert(false);
              }
              return refClassesCache[propertyKey] = `${cache.key}-${uniqId}${name !== void 0 ? `-${name}` : ""}-${propertyKey}-ref`;
            }
          });
          const cssObjectByRuleName = getCssObjectByRuleName(theme, params3, refClasses || {});
          const classes2 = objectFromEntries(objectKeys(cssObjectByRuleName).map((ruleName) => {
            const cssObject = cssObjectByRuleName[ruleName];
            if (!cssObject.label) {
              cssObject.label = `${name !== void 0 ? `${name}-` : ""}${ruleName}`;
            }
            return [
              ruleName,
              `${css2(cssObject)}${typeGuard(ruleName, ruleName in refClassesCache) ? ` ${refClassesCache[ruleName]}` : ""}`
            ];
          }));
          objectKeys(refClassesCache).forEach((ruleName) => {
            if (ruleName in classes2) {
              return;
            }
            classes2[ruleName] = refClassesCache[ruleName];
          });
          return classes2;
        }, [cache, css2, cx, theme, getDependencyArrayRef(params3)]);
        const propsClasses = styleOverrides == null ? void 0 : styleOverrides.props.classes;
        classes = (0, import_react2.useMemo)(() => mergeClasses(classes, propsClasses, cx), [classes, getDependencyArrayRef(propsClasses), cx]);
        {
          let cssObjectByRuleNameOrGetCssObjectByRuleName2 = void 0;
          try {
            cssObjectByRuleNameOrGetCssObjectByRuleName2 = name !== void 0 ? (_b = (_a = theme.components) == null ? void 0 : _a[name]) == null ? void 0 : _b.styleOverrides : void 0;
          } catch {
          }
          const themeClasses = (0, import_react2.useMemo)(() => {
            if (!cssObjectByRuleNameOrGetCssObjectByRuleName2) {
              return void 0;
            }
            const themeClasses2 = {};
            for (const ruleName in cssObjectByRuleNameOrGetCssObjectByRuleName2) {
              const cssObjectOrGetCssObject = cssObjectByRuleNameOrGetCssObjectByRuleName2[ruleName];
              if (!(cssObjectOrGetCssObject instanceof Object)) {
                continue;
              }
              themeClasses2[ruleName] = css2(typeof cssObjectOrGetCssObject === "function" ? cssObjectOrGetCssObject({
                theme,
                "ownerState": styleOverrides == null ? void 0 : styleOverrides.ownerState,
                ...styleOverrides == null ? void 0 : styleOverrides.props
              }) : cssObjectOrGetCssObject);
            }
            return themeClasses2;
          }, [
            cssObjectByRuleNameOrGetCssObjectByRuleName2 === void 0 ? void 0 : JSON.stringify(cssObjectByRuleNameOrGetCssObjectByRuleName2),
            getDependencyArrayRef(styleOverrides == null ? void 0 : styleOverrides.props),
            getDependencyArrayRef(styleOverrides == null ? void 0 : styleOverrides.ownerState),
            css2
          ]);
          classes = (0, import_react2.useMemo)(() => mergeClasses(classes, themeClasses, cx), [classes, themeClasses, cx]);
        }
        return {
          classes,
          theme,
          css: css2,
          cx
        };
      };
    };
  }
  function useStyles() {
    const theme = useTheme();
    const { css: css2, cx } = useCssAndCx();
    return { theme, css: css2, cx };
  }
  return { makeStyles, useStyles };
}
var reactContext = (0, import_react3.createContext)(void 0);
function useCacheProvidedByProvider() {
  const cacheExplicitlyProvidedForTss = (0, import_react3.useContext)(reactContext);
  return cacheExplicitlyProvidedForTss;
}
function TssCacheProvider(props) {
  const { children, value } = props;
  return import_react2.default.createElement(reactContext.Provider, { value }, children);
}

// ../../node_modules/tss-react/esm/withStyles.js
var import_react5 = __toESM(require_react());

// ../../node_modules/tss-react/esm/tools/capitalize.js
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// ../../node_modules/tss-react/esm/withStyles.js
function createWithStyles(params) {
  const { useTheme, cache } = params;
  const { makeStyles } = createMakeStyles({ useTheme, cache });
  function withStyles(Component, cssObjectByRuleNameOrGetCssObjectByRuleName, params2) {
    const Component_ = typeof Component === "string" ? (() => {
      const tag = Component;
      const Out2 = function({ children, ...props }) {
        return (0, import_react5.createElement)(tag, props, children);
      };
      Object.defineProperty(Out2, "name", {
        "value": capitalize(tag)
      });
      return Out2;
    })() : Component;
    const name = (() => {
      {
        const { name: nameOrWrappedName } = params2 ?? {};
        if (nameOrWrappedName !== void 0) {
          return typeof nameOrWrappedName !== "object" ? nameOrWrappedName : Object.keys(nameOrWrappedName)[0];
        }
      }
      {
        const displayName = Component_.displayName;
        if (typeof displayName === "string" && displayName !== "") {
          return displayName;
        }
      }
      {
        const { name: name2 } = Component_;
        if (name2) {
          return name2;
        }
      }
    })();
    const useStyles = makeStyles({ ...params2, name })(typeof cssObjectByRuleNameOrGetCssObjectByRuleName === "function" ? (theme, props, classes) => incorporateMediaQueries(cssObjectByRuleNameOrGetCssObjectByRuleName(theme, props, classes)) : incorporateMediaQueries(cssObjectByRuleNameOrGetCssObjectByRuleName));
    function getHasNonRootClasses(classes) {
      for (const name2 in classes) {
        if (name2 === "root") {
          continue;
        }
        return true;
      }
      return false;
    }
    const Out = (0, import_react5.forwardRef)(function(props, ref) {
      const { className, classes: _classes, ...rest } = props;
      const { classes, cx } = useStyles(props, { props });
      return import_react5.default.createElement(Component_, { ref, className: getHasNonRootClasses(classes) ? className : cx(classes.root, className), ...typeof Component === "string" ? {} : { classes }, ...rest });
    });
    if (name !== void 0) {
      Out.displayName = `${capitalize(name)}WithStyles`;
      Object.defineProperty(Out, "name", { "value": Out.displayName });
    }
    return Out;
  }
  return { withStyles };
}
function incorporateMediaQueries(cssObjectByRuleNameWithMediaQueries) {
  const cssObjectByRuleName = {};
  const cssObjectByRuleNameWithMediaQueriesByMediaQuery = {};
  Object.keys(cssObjectByRuleNameWithMediaQueries).forEach((ruleNameOrMediaQuery) => (ruleNameOrMediaQuery.startsWith("@media") ? cssObjectByRuleNameWithMediaQueriesByMediaQuery : cssObjectByRuleName)[ruleNameOrMediaQuery] = cssObjectByRuleNameWithMediaQueries[ruleNameOrMediaQuery]);
  Object.keys(cssObjectByRuleNameWithMediaQueriesByMediaQuery).forEach((mediaQuery) => {
    const cssObjectByRuleNameBis = cssObjectByRuleNameWithMediaQueriesByMediaQuery[mediaQuery];
    Object.keys(cssObjectByRuleNameBis).forEach((ruleName) => cssObjectByRuleName[ruleName] = {
      ...cssObjectByRuleName[ruleName] ?? {},
      [mediaQuery]: cssObjectByRuleNameBis[ruleName]
    });
  });
  return cssObjectByRuleName;
}

// ../../node_modules/tss-react/esm/index.js
init_emotion_react_browser_esm();

// ../../node_modules/tss-react/esm/GlobalStyles.js
var import_react6 = __toESM(require_react());
init_emotion_react_browser_esm();
"use client";
function GlobalStyles(props) {
  const { styles } = props;
  return import_react6.default.createElement(Global, { styles: css(styles) });
}

// ../../node_modules/tss-react/esm/index.js
"use client";
function createMakeAndWithStyles(params) {
  return {
    ...createMakeStyles(params),
    ...createWithStyles(params)
  };
}
export {
  GlobalStyles,
  TssCacheProvider,
  createMakeAndWithStyles,
  createMakeStyles,
  createWithStyles,
  keyframes
};
//# sourceMappingURL=tss-react.js.map
