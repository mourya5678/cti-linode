{
  "version": 3,
  "sources": ["../../src/operators/filter.ts", "../../src/operator/filter.ts", "../../src/add/operator/filter.ts"],
  "sourcesContent": ["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\nimport { OperatorFunction, MonoTypeOperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function filter<T, S extends T>(predicate: (value: T, index: number) => value is S,\n                                       thisArg?: any): OperatorFunction<T, S>;\nexport function filter<T>(predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nexport function filter<T>(predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): MonoTypeOperatorFunction<T> {\n  return function filterOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new FilterOperator(predicate, thisArg));\n  };\n}\n\nclass FilterOperator<T> implements Operator<T, T> {\n  constructor(private predicate: (value: T, index: number) => boolean,\n              private thisArg?: any) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass FilterSubscriber<T> extends Subscriber<T> {\n\n  count: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private predicate: (value: T, index: number) => boolean,\n              private thisArg: any) {\n    super(destination);\n  }\n\n  // the try catch block below is left specifically for\n  // optimization and perf reasons. a tryCatcher is not necessary here.\n  protected _next(value: T) {\n    let result: any;\n    try {\n      result = this.predicate.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    if (result) {\n      this.destination.next(value);\n    }\n  }\n}", "\nimport { Observable } from '../Observable';\nimport { filter as higherOrderFilter } from '../operators/filter';\n\n/* tslint:disable:max-line-length */\nexport function filter<T, S extends T>(this: Observable<T>,\n                                       predicate: (value: T, index: number) => value is S,\n                                       thisArg?: any): Observable<S>;\nexport function filter<T>(this: Observable<T>,\n                          predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): Observable<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nexport function filter<T>(this: Observable<T>, predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): Observable<T> {\n  return higherOrderFilter(predicate, thisArg)(this);\n}\n", "\nimport { Observable } from '../../Observable';\nimport { filter } from '../../operator/filter';\n\nObservable.prototype.filter = filter;\n\ndeclare module '../../Observable' {\n  interface Observable<T> {\n    filter: typeof filter;\n  }\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;AACA,QAAA,eAAA;AAmDA,aAAA,OAA0B,WACA,SAAa;AACrC,aAAO,SAAA,uBAAgC,QAAqB;AAC1D,eAAO,OAAO,KAAK,IAAI,eAAe,WAAW,OAAO,CAAC;MAC3D;IACF;AALgB,YAAA,SAAM;AAOtB,QAAA,iBAAA,WAAA;AACE,eAAAA,gBAAoB,WACA,SAAa;AADb,aAAA,YAAA;AACA,aAAA,UAAA;MACpB;AAEA,MAAAA,gBAAA,UAAA,OAAA,SAAK,YAA2B,QAAW;AACzC,eAAO,OAAO,UAAU,IAAI,iBAAiB,YAAY,KAAK,WAAW,KAAK,OAAO,CAAC;MACxF;AACF,aAAAA;IAAA,EARA;AAeA,QAAA,mBAAA,SAAA,QAAA;AAAkC,gBAAAC,mBAAA,MAAA;AAIhC,eAAAA,kBAAY,aACQ,WACA,SAAY;AAC9B,eAAA,KAAA,MAAM,WAAW;AAFC,aAAA,YAAA;AACA,aAAA,UAAA;AAJpB,aAAA,QAAgB;MAMhB;AAIU,MAAAA,kBAAA,UAAA,QAAV,SAAgB,OAAQ;AACtB,YAAI;AACJ,YAAI;AACF,mBAAS,KAAK,UAAU,KAAK,KAAK,SAAS,OAAO,KAAK,OAAO;QAChE,SAAS,KAAP;AACA,eAAK,YAAY,MAAM,GAAG;AAC1B;QACF;AACA,YAAI,QAAQ;AACV,eAAK,YAAY,KAAK,KAAK;QAC7B;MACF;AACF,aAAAA;IAAA,EAxBkC,aAAA,UAAU;;;;;;;;ACxE5C,QAAAC,YAAA;AAkDA,aAAA,OAA+C,WACrB,SAAa;AACrC,aAAOA,UAAA,OAAkB,WAAW,OAAO,EAAE,IAAI;IACnD;AAHgB,YAAA,SAAM;;;;;ACnDtB,IAAA,eAAA;AACA,IAAA,WAAA;AAEA,aAAA,WAAW,UAAU,SAAS,SAAA;",
  "names": ["FilterOperator", "FilterSubscriber", "filter_1"]
}
