{
  "version": 3,
  "sources": ["../../../../../node_modules/@reach/menu-button/node_modules/@reach/utils/src/index.tsx", "../../../../../node_modules/@reach/menu-button/node_modules/@reach/auto-id/src/index.tsx", "../../../../../node_modules/@reach/menu-button/node_modules/@reach/portal/src/index.tsx", "../../../../../node_modules/@reach/menu-button/node_modules/@reach/rect/src/index.tsx", "../../../../../node_modules/@reach/menu-button/node_modules/@reach/popover/src/index.tsx", "../../../../../node_modules/@reach/menu-button/node_modules/@reach/descendants/src/index.tsx", "../../../../../node_modules/@reach/menu-button/src/index.tsx"],
  "sourcesContent": ["/* eslint-disable no-restricted-globals, eqeqeq  */\n\nimport React, {\n  cloneElement,\n  createContext,\n  isValidElement,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport warning from \"warning\";\nimport {\n  As,\n  AssignableRef,\n  ComponentWithAs,\n  ComponentWithForwardedRef,\n  DistributiveOmit,\n  ElementByTag,\n  ElementTagNameMap,\n  ForwardRefExoticComponentWithAs,\n  ForwardRefWithAsRenderFunction,\n  FunctionComponentWithAs,\n  MemoExoticComponentWithAs,\n  PropsFromAs,\n  PropsWithAs,\n  SingleOrArray,\n  ThenArg,\n} from \"./types\";\n\n/**\n * React currently throws a warning when using useLayoutEffect on the server.\n * To get around it, we can conditionally useEffect on the server (no-op) and\n * useLayoutEffect in the browser. We occasionally need useLayoutEffect to\n * ensure we don't get a render flash for certain operations, but we may also\n * need affected components to render on the server. One example is when setting\n * a component's descendants to retrieve their index values.\n *\n * Important to note that using this hook as an escape hatch will break the\n * eslint dependency warnings unless you rename the import to `useLayoutEffect`.\n * Use sparingly only when the effect won't effect the rendered HTML to avoid\n * any server/client mismatch.\n *\n * If a useLayoutEffect is needed and the result would create a mismatch, it's\n * likely that the component in question shouldn't be rendered on the server at\n * all, so a better approach would be to lazily render those in a parent\n * component after client-side hydration.\n *\n * TODO: We are calling useLayoutEffect in a couple of places that will likely\n * cause some issues for SSR users, whether the warning shows or not. Audit and\n * fix these.\n *\n * https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\n * https://github.com/reduxjs/react-redux/blob/master/src/utils/useIsomorphicLayoutEffect.js\n *\n * @param effect\n * @param deps\n */\nexport const useIsomorphicLayoutEffect = canUseDOM()\n  ? React.useLayoutEffect\n  : React.useEffect;\n\nlet checkedPkgs: { [key: string]: boolean } = {};\n\n/**\n * Copy of Facebook's warning package.\n */\nexport { warning };\n\n/**\n * When in dev mode, checks that styles for a given @reach package are loaded.\n *\n * @param packageName Name of the package to check.\n * @example checkStyles(\"dialog\") will check for styles for @reach/dialog\n */\n// @ts-ignore\nlet checkStyles: (packageName: string) => void = noop;\n\nif (__DEV__) {\n  // In CJS files, process.env.NODE_ENV is stripped from our build, but we need\n  // it to prevent style checks from clogging up user logs while testing.\n  // This is a workaround until we can tweak the build a bit to accommodate.\n  let { env } =\n    typeof process !== \"undefined\"\n      ? process\n      : { env: { NODE_ENV: \"development\" } };\n\n  checkStyles = function checkStyles(packageName: string) {\n    // only check once per package\n    if (checkedPkgs[packageName]) return;\n    checkedPkgs[packageName] = true;\n\n    if (\n      env.NODE_ENV !== \"test\" &&\n      parseInt(\n        window\n          .getComputedStyle(document.body)\n          .getPropertyValue(`--reach-${packageName}`),\n        10\n      ) !== 1\n    ) {\n      console.warn(\n        `@reach/${packageName} styles not found. If you are using a bundler like webpack or parcel include this in the entry file of your app before any of your own styles:\n\n    import \"@reach/${packageName}/styles.css\";\n\n  Otherwise you'll need to include them some other way:\n\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"node_modules/@reach/${packageName}/styles.css\" />\n\n  For more information visit https://ui.reach.tech/styling.\n  `\n      );\n    }\n  };\n}\n\nexport { checkStyles };\n\n/**\n * Ponyfill for the global object in some environments.\n *\n * @link https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n */\nexport const ponyfillGlobal =\n  typeof window != \"undefined\" && window.Math == Math\n    ? window\n    : typeof self != \"undefined\" && self.Math == Math\n    ? self\n    : // eslint-disable-next-line no-new-func\n      Function(\"return this\")();\n\n/**\n * Passes or assigns an arbitrary value to a ref function or object.\n *\n * @param ref\n * @param value\n */\nexport function assignRef<RefValueType = any>(\n  ref: AssignableRef<RefValueType> | null | undefined,\n  value: any\n) {\n  if (ref == null) return;\n  if (isFunction(ref)) {\n    ref(value);\n  } else {\n    try {\n      ref.current = value;\n    } catch (error) {\n      throw new Error(`Cannot assign value \"${value}\" to ref \"${ref}\"`);\n    }\n  }\n}\n\n/**\n * Checks true|\"true\" vs false|\"false\"\n *\n * @param value\n */\nexport function boolOrBoolString(value: any): value is \"true\" | true {\n  return value === \"true\" ? true : isBoolean(value) ? value : false;\n}\n\nexport function canUseDOM() {\n  return !!(\n    typeof window !== \"undefined\" &&\n    window.document &&\n    window.document.createElement\n  );\n}\n\n/**\n * Type-safe clone element\n *\n * @param element\n * @param props\n * @param children\n */\nexport function cloneValidElement<Props>(\n  element: React.ReactElement<Props> | React.ReactNode,\n  props?: Partial<Props> & React.Attributes,\n  ...children: React.ReactNode[]\n): React.ReactElement<Props> | React.ReactNode {\n  return isValidElement(element)\n    ? cloneElement(element, props, ...children)\n    : element;\n}\n\nexport function createNamedContext<ContextValueType>(\n  name: string,\n  defaultValue: ContextValueType\n): React.Context<ContextValueType> {\n  const Ctx = createContext<ContextValueType>(defaultValue);\n  Ctx.displayName = name;\n  return Ctx;\n}\n\n/**\n * This is a hack for sure. The thing is, getting a component to intelligently\n * infer props based on a component or JSX string passed into an `as` prop is\n * kind of a huge pain. Getting it to work and satisfy the constraints of\n * `forwardRef` seems dang near impossible. To avoid needing to do this awkward\n * type song-and-dance every time we want to forward a ref into a component\n * that accepts an `as` prop, we abstract all of that mess to this function for\n * the time time being.\n */\nexport function forwardRefWithAs<Props, ComponentType extends As = \"div\">(\n  render: ForwardRefWithAsRenderFunction<ComponentType, Props>\n) {\n  return React.forwardRef(render) as ForwardRefExoticComponentWithAs<\n    ComponentType,\n    Props\n  >;\n}\n\nexport function memoWithAs<Props, ComponentType extends As = \"div\">(\n  Component: FunctionComponentWithAs<ComponentType, Props>,\n  propsAreEqual?: (\n    prevProps: Readonly<React.PropsWithChildren<Props>>,\n    nextProps: Readonly<React.PropsWithChildren<Props>>\n  ) => boolean\n) {\n  return React.memo(Component, propsAreEqual) as MemoExoticComponentWithAs<\n    ComponentType,\n    Props\n  >;\n}\n\n/**\n * Get the size of the working document minus the scrollbar offset.\n *\n * @param element\n */\nexport function getDocumentDimensions(\n  element?: HTMLElement | null | undefined\n) {\n  if (!canUseDOM()) return { width: 0, height: 0 };\n  let doc = element ? getOwnerDocument(element)! : document;\n  let win = element ? getOwnerWindow(element)! : window;\n  return {\n    width: doc.documentElement.clientWidth || win.innerWidth,\n    height: doc.documentElement.clientHeight || win.innerHeight,\n  };\n}\n\n/**\n * Get the scoll position of the global window object relative to a given node.\n *\n * @param element\n */\nexport function getScrollPosition(element?: HTMLElement | null | undefined) {\n  if (!canUseDOM()) return { scrollX: 0, scrollY: 0 };\n  let win = element ? getOwnerWindow(element)! : window;\n  return {\n    scrollX: win.scrollX,\n    scrollY: win.scrollY,\n  };\n}\n\n/**\n * Get a computed style value by property, backwards compatible with IE\n * @param element\n * @param styleProp\n */\nexport function getElementComputedStyle(\n  element: HTMLElement & {\n    currentStyle?: Record<string, string>;\n  },\n  styleProp: string\n) {\n  let y: string | null = null;\n  let doc = getOwnerDocument(element);\n  if (element.currentStyle) {\n    y = element.currentStyle[styleProp];\n  } else if (\n    doc &&\n    doc.defaultView &&\n    isFunction(doc.defaultView.getComputedStyle)\n  ) {\n    y = doc.defaultView\n      .getComputedStyle(element, null)\n      .getPropertyValue(styleProp);\n  }\n  return y;\n}\n\n/**\n * Get an element's owner document. Useful when components are used in iframes\n * or other environments like dev tools.\n *\n * @param element\n */\nexport function getOwnerDocument<T extends HTMLElement = HTMLElement>(\n  element: T | null\n) {\n  return element && element.ownerDocument\n    ? element.ownerDocument\n    : canUseDOM()\n    ? document\n    : null;\n}\n\nexport function getOwnerWindow<T extends HTMLElement = HTMLElement>(\n  element: T | null\n) {\n  let doc = element ? getOwnerDocument(element) : null;\n  return doc ? doc.defaultView || window : null;\n}\n\n/**\n * Get the scrollbar offset distance.\n *\n * TODO: Remove in 1.0 (we used this in public examples)\n */\nexport function getScrollbarOffset() {\n  try {\n    if (window.innerWidth > document.documentElement.clientWidth) {\n      return window.innerWidth - document.documentElement.clientWidth;\n    }\n  } catch (err) {}\n  return 0;\n}\n\n/**\n * Checks whether or not a value is a boolean.\n *\n * @param value\n */\nexport function isBoolean(value: any): value is boolean {\n  return typeof value === \"boolean\";\n}\n\n/**\n * Checks whether or not a value is a function.\n *\n * @param value\n */\nexport function isFunction(value: any): value is Function {\n  return !!(value && {}.toString.call(value) == \"[object Function]\");\n}\n\n/**\n * Checks whether or not a value is a number.\n *\n * @param value\n */\nexport function isNumber(value: any): value is number {\n  return typeof value === \"number\" && !isNaN(value);\n}\n\n/**\n * Detects right clicks\n *\n * @param nativeEvent\n */\nexport function isRightClick(\n  nativeEvent: MouseEvent | PointerEvent | TouchEvent\n) {\n  return \"which\" in nativeEvent\n    ? nativeEvent.which === 3\n    : \"button\" in nativeEvent\n    ? (nativeEvent as any).button === 2\n    : false;\n}\n\n/**\n * Checks whether or not a value is a string.\n *\n * @param value\n */\nexport function isString(value: any): value is string {\n  return typeof value === \"string\";\n}\n\n/**\n * Joins strings to format IDs for compound components.\n *\n * @param args\n */\nexport function makeId(...args: (string | number | null | undefined)[]) {\n  return args.filter((val) => val != null).join(\"--\");\n}\n\n/**\n * No-op function.\n */\nexport function noop(): void {}\n\n/**\n * Convert our state strings for HTML data attributes.\n * No need for a fancy kebab-caser here, we know what our state strings are!\n *\n * @param state\n */\nexport function stateToAttributeString(state: any) {\n  return String(state)\n    .replace(/([\\s_]+)/g, \"-\")\n    .toLowerCase();\n}\n\n/**\n * Check if a component is controlled or uncontrolled and return the correct\n * state value and setter accordingly. If the component state is controlled by\n * the app, the setter is a noop.\n *\n * @param controlledValue\n * @param defaultValue\n */\nexport function useControlledState<T = any>(\n  controlledValue: T | undefined,\n  defaultValue: T\n): [T, React.Dispatch<React.SetStateAction<T>>] {\n  let controlledRef = useRef(controlledValue != null);\n  let [valueState, setValue] = useState(defaultValue);\n  let set: React.Dispatch<React.SetStateAction<T>> = useCallback((n) => {\n    if (!controlledRef.current) {\n      setValue(n);\n    }\n  }, []);\n  return [controlledRef.current ? (controlledValue as T) : valueState, set];\n}\n\n/**\n * Logs a warning in dev mode when a component switches from controlled to\n * uncontrolled, or vice versa\n *\n * A single prop should typically be used to determine whether or not a\n * component is controlled or not.\n *\n * @param controlledValue\n * @param controlledPropName\n * @param componentName\n */\nlet useControlledSwitchWarning: (\n  controlledValue: any,\n  controlledPropName: string,\n  componentName: string\n) => void = noop;\n\nif (__DEV__) {\n  useControlledSwitchWarning = function useControlledSwitchWarning(\n    controlledValue,\n    controlledPropName,\n    componentName\n  ) {\n    let controlledRef = useRef(controlledValue != null);\n    let nameCache = useRef({ componentName, controlledPropName });\n    useEffect(() => {\n      nameCache.current = { componentName, controlledPropName };\n    }, [componentName, controlledPropName]);\n\n    useEffect(() => {\n      let { current: wasControlled } = controlledRef;\n      let { componentName, controlledPropName } = nameCache.current;\n      let isControlled = controlledValue != null;\n      if (wasControlled !== isControlled) {\n        console.error(\n          `A component is changing an ${\n            wasControlled ? \"\" : \"un\"\n          }controlled \\`${controlledPropName}\\` state of ${componentName} to be ${\n            wasControlled ? \"un\" : \"\"\n          }controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled ${componentName} element for the lifetime of the component.\nMore info: https://fb.me/react-controlled-components`\n        );\n      }\n    }, [controlledValue]);\n  };\n}\n\nexport { useControlledSwitchWarning };\n\nlet useCheckStyles: (packageName: string) => void = noop;\n\nif (__DEV__) {\n  useCheckStyles = function useCheckStyles(pkg: string) {\n    let name = useRef(pkg);\n    useEffect(() => void (name.current = pkg), [pkg]);\n    useEffect(() => checkStyles(name.current), []);\n  };\n}\n\nexport { useCheckStyles };\n\n/**\n * React hook for creating a value exactly once.\n * @see https://github.com/Andarist/use-constant\n */\nexport function useConstant<ValueType>(fn: () => ValueType): ValueType {\n  const ref = React.useRef<{ v: ValueType }>();\n  if (!ref.current) {\n    ref.current = { v: fn() };\n  }\n  return ref.current.v;\n}\n\n/**\n * @param callback\n */\nexport function useEventCallback<E extends Event | React.SyntheticEvent>(\n  callback: (event: E, ...args: any[]) => void\n) {\n  const ref = useRef(callback);\n  useIsomorphicLayoutEffect(() => {\n    ref.current = callback;\n  });\n  return useCallback(\n    (event: E, ...args: any[]) => ref.current(event, ...args),\n    []\n  );\n}\n\n/**\n * @param callback\n */\nexport function useCallbackProp<F extends Function>(callback: F | undefined) {\n  const ref = useRef(callback);\n  useEffect(() => {\n    ref.current = callback;\n  });\n  return (useCallback(\n    (...args: any[]) => ref.current && ref.current(...args),\n    []\n  ) as unknown) as F;\n}\n\n/**\n * Adds a DOM event listener\n *\n * @param eventName\n * @param listener\n * @param element\n */\nexport function useEventListener<K extends keyof WindowEventMap>(\n  eventName: K,\n  listener: (event: WindowEventMap[K]) => any,\n  element: HTMLElement | Document | Window | EventTarget = window\n) {\n  const savedHandler = useRef(listener);\n  useEffect(() => {\n    savedHandler.current = listener;\n  }, [listener]);\n\n  useEffect(() => {\n    const isSupported = element && element.addEventListener;\n    if (!isSupported) {\n      if (__DEV__) {\n        console.warn(\"Event listener not supported on the element provided\");\n      }\n      return;\n    }\n\n    function eventListener(event: WindowEventMap[K]) {\n      savedHandler.current(event);\n    }\n\n    element.addEventListener(eventName, eventListener as any);\n    return () => {\n      element.removeEventListener(eventName, eventListener as any);\n    };\n  }, [eventName, element]);\n}\n\n/**\n * Detect when focus changes in our document.\n *\n * @param handleChange\n * @param when\n * @param ownerDocument\n */\nexport function useFocusChange(\n  handleChange: (\n    activeElement: Element | null,\n    previousActiveElement: Element | null,\n    event?: FocusEvent\n  ) => void = console.log,\n  when: \"focus\" | \"blur\" = \"focus\",\n  ownerDocument: Document = document\n) {\n  let lastActiveElement = useRef(ownerDocument.activeElement);\n\n  useEffect(() => {\n    lastActiveElement.current = ownerDocument.activeElement;\n\n    function onChange(event: FocusEvent) {\n      if (lastActiveElement.current !== ownerDocument.activeElement) {\n        handleChange(\n          ownerDocument.activeElement,\n          lastActiveElement.current,\n          event\n        );\n        lastActiveElement.current = ownerDocument.activeElement;\n      }\n    }\n\n    ownerDocument.addEventListener(when, onChange, true);\n\n    return () => {\n      ownerDocument.removeEventListener(when, onChange);\n    };\n  }, [when, handleChange, ownerDocument]);\n}\n\n/**\n * Forces a re-render, similar to `forceUpdate` in class components.\n */\nexport function useForceUpdate() {\n  let [, dispatch] = useState<{}>(Object.create(null));\n  return useCallback(() => {\n    dispatch(Object.create(null));\n  }, []);\n}\n\n/**\n * Passes or assigns a value to multiple refs (typically a DOM node). Useful for\n * dealing with components that need an explicit ref for DOM calculations but\n * also forwards refs assigned by an app.\n *\n * @param refs Refs to fork\n */\nexport function useForkedRef<RefValueType = any>(\n  ...refs: (AssignableRef<RefValueType> | null | undefined)[]\n) {\n  return useMemo(() => {\n    if (refs.every((ref) => ref == null)) {\n      return null;\n    }\n    return (node: any) => {\n      refs.forEach((ref) => {\n        assignRef(ref, node);\n      });\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [...refs]);\n}\n\n/**\n * Returns the previous value of a reference after a component update.\n *\n * @param value\n */\nexport function usePrevious<ValueType = any>(value: ValueType) {\n  const ref = useRef<ValueType | null>(null);\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n}\n\n/**\n * Call an effect after a component update, skipping the initial mount.\n *\n * @param effect Effect to call\n * @param deps Effect dependency list\n */\nexport function useUpdateEffect(\n  effect: React.EffectCallback,\n  deps?: React.DependencyList\n) {\n  const mounted = useRef(false);\n  useEffect(() => {\n    if (mounted.current) {\n      effect();\n    } else {\n      mounted.current = true;\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n}\n\n/**\n * Just a lil state logger\n *\n * @param state\n * @param DEBUG\n */\nlet useStateLogger: (state: string, DEBUG: boolean) => void = noop;\n\nif (__DEV__) {\n  useStateLogger = function useStateLogger(state, DEBUG = false) {\n    let debugRef = useRef(DEBUG);\n    useEffect(() => {\n      debugRef.current = DEBUG;\n    }, [DEBUG]);\n    useEffect(() => {\n      if (debugRef.current) {\n        console.group(\"State Updated\");\n        console.log(\n          \"%c\" + state,\n          \"font-weight: normal; font-size: 120%; font-style: italic;\"\n        );\n        console.groupEnd();\n      }\n    }, [state]);\n  };\n}\n\nexport { useStateLogger };\n\n/**\n * Wraps a lib-defined event handler and a user-defined event handler, returning\n * a single handler that allows a user to prevent lib-defined handlers from\n * firing.\n *\n * @param theirHandler User-supplied event handler\n * @param ourHandler Library-supplied event handler\n */\nexport function wrapEvent<EventType extends React.SyntheticEvent | Event>(\n  theirHandler: ((event: EventType) => any) | undefined,\n  ourHandler: (event: EventType) => any\n): (event: EventType) => any {\n  return (event) => {\n    theirHandler && theirHandler(event);\n    if (!event.defaultPrevented) {\n      return ourHandler(event);\n    }\n  };\n}\n\n// Export types\nexport {\n  As,\n  AssignableRef,\n  ComponentWithAs,\n  ComponentWithForwardedRef,\n  DistributiveOmit,\n  ElementByTag,\n  ElementTagNameMap,\n  ForwardRefExoticComponentWithAs,\n  FunctionComponentWithAs,\n  MemoExoticComponentWithAs,\n  PropsFromAs,\n  PropsWithAs,\n  SingleOrArray,\n  ThenArg,\n};\n", "/*\n * Welcome to @reach/auto-id!\n\n * Let's see if we can make sense of why this hook exists and its\n * implementation.\n *\n * Some background:\n *   1. Accessibiliy APIs rely heavily on element IDs\n *   2. Requiring developers to put IDs on every element in Reach UI is both\n *      cumbersome and error-prone\n *   3. With a component model, we can generate IDs for them!\n *\n * Solution 1: Generate random IDs.\n *\n * This works great as long as you don't server render your app. When React (in\n * the client) tries to reuse the markup from the server, the IDs won't match\n * and React will then recreate the entire DOM tree.\n *\n * Solution 2: Increment an integer\n *\n * This sounds great. Since we're rendering the exact same tree on the server\n * and client, we can increment a counter and get a deterministic result between\n * client and server. Also, JS integers can go up to nine-quadrillion. I'm\n * pretty sure the tab will be closed before an app never needs\n * 10 quadrillion IDs!\n *\n * Problem solved, right?\n *\n * Ah, but there's a catch! React's concurrent rendering makes this approach\n * non-deterministic. While the client and server will end up with the same\n * elements in the end, depending on suspense boundaries (and possibly some user\n * input during the initial render) the incrementing integers won't always match\n * up.\n *\n * Solution 3: Don't use IDs at all on the server; patch after first render.\n *\n * What we've done here is solution 2 with some tricks. With this approach, the\n * ID returned is an empty string on the first render. This way the server and\n * client have the same markup no matter how wild the concurrent rendering may\n * have gotten.\n *\n * After the render, we patch up the components with an incremented ID. This\n * causes a double render on any components with `useId`. Shouldn't be a problem\n * since the components using this hook should be small, and we're only updating\n * the ID attribute on the DOM, nothing big is happening.\n *\n * It doesn't have to be an incremented number, though--we could do generate\n * random strings instead, but incrementing a number is probably the cheapest\n * thing we can do.\n *\n * Additionally, we only do this patchup on the very first client render ever.\n * Any calls to `useId` that happen dynamically in the client will be\n * populated immediately with a value. So, we only get the double render after\n * server hydration and never again, SO BACK OFF ALRIGHT?\n */\n\nimport { useState, useEffect } from \"react\";\nimport { useIsomorphicLayoutEffect } from \"@reach/utils\";\n\nlet serverHandoffComplete = false;\nlet id = 0;\nconst genId = () => ++id;\n\n/**\n * useId\n *\n * Autogenerate IDs to facilitate WAI-ARIA and server rendering.\n *\n * Note: The returned ID will initially be `null` and will update after a\n * component mounts. Users may need to supply their own ID if they need\n * consistent values for SSR.\n *\n * @see Docs https://reach.tech/auto-id\n */\nexport const useId = (idFromProps?: string | null) => {\n  /*\n   * If this instance isn't part of the initial render, we don't have to do the\n   * double render/patch-up dance. We can just generate the ID and return it.\n   */\n  const initialId = idFromProps || (serverHandoffComplete ? genId() : null);\n\n  const [id, setId] = useState(initialId);\n\n  useIsomorphicLayoutEffect(() => {\n    if (id === null) {\n      /*\n       * Patch the ID after render. We do this in `useLayoutEffect` to avoid any\n       * rendering flicker, though it'll make the first render slower (unlikely\n       * to matter, but you're welcome to measure your app and let us know if\n       * it's a problem).\n       */\n      setId(genId());\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  useEffect(() => {\n    if (serverHandoffComplete === false) {\n      /*\n       * Flag all future uses of `useId` to skip the update dance. This is in\n       * `useEffect` because it goes after `useLayoutEffect`, ensuring we don't\n       * accidentally bail out of the patch-up dance prematurely.\n       */\n      serverHandoffComplete = true;\n    }\n  }, []);\n  return id != null ? String(id) : undefined;\n};\n", "/**\n * Welcome to @reach/portal!\n *\n * Creates and appends a DOM node to the end of `document.body` and renders a\n * React tree into it. Useful for rendering a natural React element hierarchy\n * with a different DOM hierarchy to prevent parent styles from clipping or\n * hiding content (for popovers, dropdowns, and modals).\n *\n * @see Docs   https://reach.tech/portal\n * @see Source https://github.com/reach/reach-ui/tree/main/packages/portal\n * @see React  https://reactjs.org/docs/portals.html\n */\n\nimport React, { useRef } from \"react\";\nimport { useIsomorphicLayoutEffect, useForceUpdate } from \"@reach/utils\";\nimport { createPortal } from \"react-dom\";\n\n/**\n * Portal\n *\n * @see Docs https://reach.tech/portal#portal\n */\nconst Portal: React.FC<PortalProps> = ({ children, type = \"reach-portal\" }) => {\n  let mountNode = useRef<HTMLDivElement | null>(null);\n  let portalNode = useRef<HTMLElement | null>(null);\n  let forceUpdate = useForceUpdate();\n\n  useIsomorphicLayoutEffect(() => {\n    // This ref may be null when a hot-loader replaces components on the page\n    if (!mountNode.current) return;\n    // It's possible that the content of the portal has, itself, been portaled.\n    // In that case, it's important to append to the correct document element.\n    const ownerDocument = mountNode.current!.ownerDocument;\n    portalNode.current = ownerDocument?.createElement(type)!;\n    ownerDocument!.body.appendChild(portalNode.current);\n    forceUpdate();\n    return () => {\n      if (portalNode.current && portalNode.current.ownerDocument) {\n        portalNode.current.ownerDocument.body.removeChild(portalNode.current);\n      }\n    };\n  }, [type, forceUpdate]);\n\n  return portalNode.current ? (\n    createPortal(children, portalNode.current)\n  ) : (\n    <span ref={mountNode} />\n  );\n};\n\n/**\n * @see Docs https://reach.tech/portal#portal-props\n */\nexport type PortalProps = {\n  /**\n   * Regular React children.\n   *\n   * @see Docs https://reach.tech/portal#portal-children\n   */\n  children: React.ReactNode;\n  /**\n   * The DOM element type to render.\n   *\n   * @see Docs https://reach.tech/portal#portal-type\n   */\n  type?: string;\n};\n\nif (__DEV__) {\n  Portal.displayName = \"Portal\";\n}\n\nexport default Portal;\n", "/**\n * Welcome to @reach/rect!\n *\n * Measures DOM elements (aka. bounding client rect).\n *\n * @see getBoundingClientRect https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\n * @see Docs                  https://reach.tech/rect\n * @see Source                https://github.com/reach/reach-ui/tree/main/packages/rect\n */\n\nimport React, { useRef, useState } from \"react\";\nimport PropTypes from \"prop-types\";\nimport observeRect from \"@reach/observe-rect\";\nimport { useIsomorphicLayoutEffect } from \"@reach/utils\";\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Rect\n *\n * @param props\n */\nexport const Rect: React.FC<RectProps> = ({\n  onChange,\n  observe = true,\n  children,\n}) => {\n  const ref = useRef<HTMLElement | null>(null);\n  const rect = useRect(ref, observe, onChange);\n  return children({ ref, rect });\n};\n\n/**\n * @see Docs https://reach.tech/rect#rect-props\n */\nexport type RectProps = {\n  /**\n   * Tells `Rect` to observe the position of the node or not. While observing,\n   * the `children` render prop may call back very quickly (especially while\n   * scrolling) so it can be important for performance to avoid observing when\n   * you don't need to.\n   *\n   * This is typically used for elements that pop over other elements (like a\n   * dropdown menu), so you don't need to observe all the time, only when the\n   * popup is active.\n   *\n   * Pass `true` to observe, `false` to ignore.\n   *\n   * @see Docs https://reach.tech/rect#rect-observe\n   */\n  observe?: boolean;\n  /**\n   * Calls back whenever the `rect` of the element changes.\n   *\n   * @see Docs https://reach.tech/rect#rect-onchange\n   */\n  onChange?: (rect: PRect) => void;\n  /**\n   * A function that calls back to you with a `ref` to place on an element and\n   * the `rect` measurements of the dom node.\n   *\n   * **Note**: On the first render `rect` will be `undefined` because we can't\n   * measure a node that has not yet been rendered. Make sure your code accounts\n   * for this.\n   *\n   * @see Docs https://reach.tech/rect#rect-onchange\n   */\n  children(args: {\n    rect: PRect | null;\n    ref: React.RefObject<any>;\n  }): JSX.Element;\n};\n\nif (__DEV__) {\n  Rect.displayName = \"Rect\";\n  Rect.propTypes = {\n    children: PropTypes.func.isRequired,\n    observe: PropTypes.bool,\n    onChange: PropTypes.func,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * useRect\n *\n * @param nodeRef\n * @param observe\n * @param onChange\n */\nexport function useRect<T extends Element = HTMLElement>(\n  nodeRef: React.RefObject<T | undefined | null>,\n  observe: boolean = true,\n  onChange?: (rect: DOMRect) => void\n): null | DOMRect {\n  let [element, setElement] = useState(nodeRef.current);\n  let initialRectIsSet = useRef(false);\n  let initialRefIsSet = useRef(false);\n  let [rect, setRect] = useState<DOMRect | null>(null);\n  let onChangeRef = useRef<typeof onChange>();\n\n  useIsomorphicLayoutEffect(() => {\n    onChangeRef.current = onChange;\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current);\n    }\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    if (element && !initialRectIsSet.current) {\n      initialRectIsSet.current = true;\n      setRect(element.getBoundingClientRect());\n    }\n  }, [element]);\n\n  useIsomorphicLayoutEffect(() => {\n    let observer: ReturnType<typeof observeRect>;\n    let elem = element;\n\n    // State initializes before refs are placed, meaning the element state will\n    // be undefined on the first render. We still want the rect on the first\n    // render, so initially we'll use the nodeRef that was passed instead of\n    // state for our measurements.\n    if (!initialRefIsSet.current) {\n      initialRefIsSet.current = true;\n      elem = nodeRef.current;\n    }\n\n    if (!elem) {\n      if (__DEV__) {\n        console.warn(\"You need to place the ref\");\n      }\n      return cleanup;\n    }\n\n    observer = observeRect(elem, (rect) => {\n      onChangeRef.current && onChangeRef.current(rect);\n      setRect(rect);\n    });\n\n    observe && observer.observe();\n    return cleanup;\n\n    function cleanup() {\n      observer && observer.unobserve();\n    }\n  }, [observe, element]);\n\n  return rect;\n}\n\nexport default Rect;\n\nexport type PRect = Partial<DOMRect> & {\n  readonly bottom: number;\n  readonly height: number;\n  readonly left: number;\n  readonly right: number;\n  readonly top: number;\n  readonly width: number;\n};\n", "/**\n * Welcome to @reach/popover!\n */\n\nimport React, { useRef, forwardRef, useEffect } from \"react\";\nimport Portal from \"@reach/portal\";\nimport { useRect, PRect } from \"@reach/rect\";\nimport { getOwnerDocument, useForkedRef } from \"@reach/utils\";\nimport tabbable from \"tabbable\";\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Popover\n */\nconst Popover = forwardRef<HTMLDivElement, PopoverProps>(function Popover(\n  props,\n  ref\n) {\n  return (\n    <Portal>\n      <PopoverImpl ref={ref} {...props} />\n    </Portal>\n  );\n});\n\nexport type PopoverProps = {\n  children: React.ReactNode;\n  targetRef: React.RefObject<HTMLElement>;\n  position?: Position;\n  /**\n   * Render the popover markup, but hide it – used by MenuButton so that it\n   * can have an `aria-controls` attribute even when its menu isn't open, and\n   * used inside `Popover` as a hint that we can tell `useRect` to stop\n   * observing for better performance.\n   */\n  hidden?: boolean;\n  /**\n   * Testing this API so we might accept additional nodes that apps can use to\n   * determine the position of the popover. One example where it may be useful\n   * is for positioning the popover of a listbox where the cursor rests on top\n   * of the selected option. Pretty sure this will change so don't use it\n   * anywehre in public yet!\n   */\n  unstable_observableRefs?: React.RefObject<PossibleNode>[];\n} & React.HTMLAttributes<HTMLDivElement>;\n\nif (__DEV__) {\n  Popover.displayName = \"Popover\";\n}\n\nexport default Popover;\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * PopoverImpl\n *\n * Popover is conditionally rendered so we can't start measuring until it shows\n * up, so useRect needs to live down here not up in Popover\n */\nconst PopoverImpl = forwardRef<HTMLDivElement, PopoverProps>(\n  function PopoverImpl(\n    {\n      targetRef,\n      position = positionDefault,\n      unstable_observableRefs = [],\n      ...props\n    },\n    forwardedRef\n  ) {\n    const popoverRef = useRef<HTMLDivElement>(null);\n    const popoverRect = useRect(popoverRef, !props.hidden);\n    const targetRect = useRect(targetRef, !props.hidden);\n    const ref = useForkedRef(popoverRef, forwardedRef);\n\n    useSimulateTabNavigationForReactTree(targetRef, popoverRef);\n\n    return (\n      <div\n        data-reach-popover=\"\"\n        ref={ref}\n        {...props}\n        style={{\n          position: \"absolute\",\n          ...getStyles(\n            position,\n            targetRect,\n            popoverRect,\n            ...unstable_observableRefs\n          ),\n          ...props.style,\n        }}\n      />\n    );\n  }\n);\n\nif (__DEV__) {\n  PopoverImpl.displayName = \"PopoverImpl\";\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction getStyles(\n  position: Position,\n  targetRect: PRect | null,\n  popoverRect: PRect | null,\n  ...unstable_observableRefs: React.RefObject<PossibleNode>[]\n): React.CSSProperties {\n  return popoverRect\n    ? position(\n        targetRect,\n        popoverRect,\n        ...unstable_observableRefs.map((ref) => ref.current)\n      )\n    : { visibility: \"hidden\" };\n}\n\nfunction getTopPosition(targetRect: PRect, popoverRect: PRect) {\n  const { directionUp } = getCollisions(targetRect, popoverRect);\n  return {\n    top: directionUp\n      ? `${targetRect.top - popoverRect.height + window.pageYOffset}px`\n      : `${targetRect.top + targetRect.height + window.pageYOffset}px`,\n  };\n}\n\nexport const positionDefault: Position = (targetRect, popoverRect) => {\n  if (!targetRect || !popoverRect) {\n    return {};\n  }\n\n  const { directionRight } = getCollisions(targetRect, popoverRect);\n  return {\n    left: directionRight\n      ? `${targetRect.right - popoverRect.width + window.pageXOffset}px`\n      : `${targetRect.left + window.pageXOffset}px`,\n    ...getTopPosition(targetRect, popoverRect),\n  };\n};\n\nexport const positionRight: Position = (targetRect, popoverRect) => {\n  if (!targetRect || !popoverRect) {\n    return {};\n  }\n\n  const { directionLeft } = getCollisions(targetRect, popoverRect);\n  return {\n    left: directionLeft\n      ? `${targetRect.left + window.pageXOffset}px`\n      : `${targetRect.right - popoverRect.width + window.pageXOffset}px`,\n    ...getTopPosition(targetRect, popoverRect),\n  };\n};\n\nexport const positionMatchWidth: Position = (targetRect, popoverRect) => {\n  if (!targetRect || !popoverRect) {\n    return {};\n  }\n\n  return {\n    width: targetRect.width,\n    left: targetRect.left,\n    ...getTopPosition(targetRect, popoverRect),\n  };\n};\n\nexport function getCollisions(\n  targetRect: PRect,\n  popoverRect: PRect,\n  offsetLeft: number = 0,\n  offsetBottom: number = 0\n) {\n  const collisions = {\n    top: targetRect.top - popoverRect.height < 0,\n    right: window.innerWidth < targetRect.left + popoverRect.width - offsetLeft,\n    bottom:\n      window.innerHeight <\n      targetRect.bottom + popoverRect.height - offsetBottom,\n    left: targetRect.left + targetRect.width - popoverRect.width < 0,\n  };\n\n  const directionRight = collisions.right && !collisions.left;\n  const directionLeft = collisions.left && !collisions.right;\n  const directionUp = collisions.bottom && !collisions.top;\n  const directionDown = collisions.top && !collisions.bottom;\n\n  return { directionRight, directionLeft, directionUp, directionDown };\n}\n\n// Heads up, my jQuery past haunts this function. This hook scopes the tab\n// order to the React element tree, instead of the DOM tree. This way, when the\n// user navigates with tab from the targetRef, the tab order moves into the\n// popup, and then out of the popup back to the rest of the document.\n// (We call targetRef, triggerRef inside this function to avoid confusion with\n// event.target)\nfunction useSimulateTabNavigationForReactTree<\n  T extends HTMLElement = HTMLElement,\n  P extends HTMLElement = HTMLElement\n>(triggerRef: React.RefObject<T>, popoverRef: React.RefObject<P>) {\n  const ownerDocument = getOwnerDocument(triggerRef.current);\n\n  function handleKeyDown(event: KeyboardEvent) {\n    if (\n      event.key === \"Tab\" &&\n      popoverRef.current &&\n      tabbable(popoverRef.current).length === 0\n    ) {\n      return;\n    }\n\n    if (event.key === \"Tab\" && event.shiftKey) {\n      if (shiftTabbedFromElementAfterTrigger(event)) {\n        focusLastTabbableInPopover(event);\n      } else if (shiftTabbedOutOfPopover(event)) {\n        focusTriggerRef(event);\n      } else if (shiftTabbedToBrowserChrome(event)) {\n        disableTabbablesInPopover();\n      }\n    } else if (event.key === \"Tab\") {\n      if (tabbedFromTriggerToPopover()) {\n        focusFirstPopoverTabbable(event);\n      } else if (tabbedOutOfPopover()) {\n        focusTabbableAfterTrigger(event);\n      } else if (tabbedToBrowserChrome(event)) {\n        disableTabbablesInPopover();\n      }\n    }\n  }\n\n  useEffect(() => {\n    if (ownerDocument) {\n      ownerDocument.addEventListener(\"keydown\", handleKeyDown);\n      return () => {\n        ownerDocument.removeEventListener(\"keydown\", handleKeyDown);\n      };\n    }\n    return;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  function getElementAfterTrigger() {\n    const elements = ownerDocument && tabbable(ownerDocument);\n    const targetIndex =\n      elements && triggerRef.current\n        ? elements.indexOf(triggerRef.current)\n        : -1;\n    const elementAfterTrigger = elements && elements[targetIndex + 1];\n    return popoverRef.current &&\n      popoverRef.current.contains(elementAfterTrigger || null)\n      ? false\n      : elementAfterTrigger;\n  }\n\n  function tabbedFromTriggerToPopover() {\n    return triggerRef.current && ownerDocument\n      ? triggerRef.current === ownerDocument.activeElement\n      : false;\n  }\n\n  function focusFirstPopoverTabbable(event: KeyboardEvent) {\n    const elements = popoverRef.current && tabbable(popoverRef.current);\n    if (elements && elements[0]) {\n      event.preventDefault();\n      elements[0].focus();\n    }\n  }\n\n  function tabbedOutOfPopover() {\n    const inPopover =\n      popoverRef.current && ownerDocument\n        ? popoverRef.current.contains(ownerDocument.activeElement || null)\n        : false;\n    if (inPopover) {\n      const elements = popoverRef.current && tabbable(popoverRef.current);\n      return Boolean(\n        elements &&\n          ownerDocument &&\n          elements[elements.length - 1] === ownerDocument.activeElement\n      );\n    }\n    return false;\n  }\n\n  function focusTabbableAfterTrigger(event: KeyboardEvent) {\n    const elementAfterTrigger = getElementAfterTrigger();\n    if (elementAfterTrigger) {\n      event.preventDefault();\n      elementAfterTrigger.focus();\n    }\n  }\n\n  function shiftTabbedFromElementAfterTrigger(event: KeyboardEvent) {\n    if (!event.shiftKey) return;\n    const elementAfterTrigger = getElementAfterTrigger();\n    return event.target === elementAfterTrigger;\n  }\n\n  function focusLastTabbableInPopover(event: KeyboardEvent) {\n    const elements = popoverRef.current && tabbable(popoverRef.current);\n    const last = elements && elements[elements.length - 1];\n    if (last) {\n      event.preventDefault();\n      last.focus();\n    }\n  }\n\n  function shiftTabbedOutOfPopover(event: KeyboardEvent) {\n    const elements = popoverRef.current && tabbable(popoverRef.current);\n    if (elements) {\n      return elements.length === 0 ? false : event.target === elements[0];\n    }\n    return false;\n  }\n\n  function focusTriggerRef(event: KeyboardEvent) {\n    event.preventDefault();\n    triggerRef.current?.focus();\n  }\n\n  function tabbedToBrowserChrome(event: KeyboardEvent) {\n    const elements =\n      ownerDocument && popoverRef.current\n        ? tabbable(ownerDocument).filter(\n            (element) => !popoverRef.current!.contains(element)\n          )\n        : null;\n    return elements ? event.target === elements[elements.length - 1] : false;\n  }\n\n  function shiftTabbedToBrowserChrome(event: KeyboardEvent) {\n    // we're assuming the popover will never contain the first tabbable\n    // element, and it better not, because the trigger needs to be tabbable!\n    return ownerDocument ? event.target === tabbable(ownerDocument)[0] : false;\n  }\n\n  let restoreTabIndexTuplés: [HTMLElement, number][] = [];\n\n  function disableTabbablesInPopover() {\n    const elements = popoverRef.current && tabbable(popoverRef.current);\n    if (elements) {\n      elements.forEach((element) => {\n        restoreTabIndexTuplés.push([element, element.tabIndex]);\n        element.tabIndex = -1;\n      });\n      ownerDocument &&\n        ownerDocument.addEventListener(\"focusin\", enableTabbablesInPopover);\n    }\n  }\n\n  function enableTabbablesInPopover() {\n    ownerDocument &&\n      ownerDocument.removeEventListener(\"focusin\", enableTabbablesInPopover);\n    restoreTabIndexTuplés.forEach(([element, tabIndex]) => {\n      element.tabIndex = tabIndex;\n    });\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\nexport type Position = (\n  targetRect?: PRect | null,\n  popoverRect?: PRect | null,\n  ...unstable_observableNodes: PossibleNode[]\n) => React.CSSProperties;\n\ntype PossibleNode = null | undefined | HTMLElement | SVGElement;\n", "import React, { useCallback, useContext, useMemo, useState } from \"react\";\nimport {\n  createNamedContext,\n  noop,\n  useForceUpdate,\n  useIsomorphicLayoutEffect,\n  usePrevious,\n} from \"@reach/utils\";\n\nexport function createDescendantContext<DescendantType extends Descendant>(\n  name: string,\n  initialValue = {}\n) {\n  type T = DescendantContextValue<DescendantType>;\n  const descendants: DescendantType[] = [];\n  return createNamedContext<T>(name, {\n    descendants,\n    registerDescendant: noop,\n    unregisterDescendant: noop,\n    ...initialValue,\n  });\n}\n\n/**\n * This hook registers our descendant by passing it into an array. We can then\n * search that array by to find its index when registering it in the component.\n * We use this for focus management, keyboard navigation, and typeahead\n * functionality for some components.\n *\n * The hook accepts the element node and (optionally) a key. The key is useful\n * if multiple descendants have identical text values and we need to\n * differentiate siblings for some reason.\n *\n * Our main goals with this are:\n *   1) maximum composability,\n *   2) minimal API friction\n *   3) SSR compatibility*\n *   4) concurrent safe\n *   5) index always up-to-date with the tree despite changes\n *   6) works with memoization of any component in the tree (hopefully)\n *\n * * As for SSR, the good news is that we don't actually need the index on the\n * server for most use-cases, as we are only using it to determine the order of\n * composed descendants for keyboard navigation. However, in the few cases where\n * this is not the case, we can require an explicit index from the app.\n */\nexport function useDescendant<DescendantType extends Descendant>(\n  descendant: Omit<DescendantType, \"index\">,\n  context: React.Context<DescendantContextValue<DescendantType>>,\n  indexProp?: number\n) {\n  let forceUpdate = useForceUpdate();\n  let { registerDescendant, unregisterDescendant, descendants } = useContext(\n    context\n  );\n\n  // This will initially return -1 because we haven't registered the descendant\n  // on the first render. After we register, this will then return the correct\n  // index on the following render and we will re-register descendants\n  // so that everything is up-to-date before the user interacts with a\n  // collection.\n  let index =\n    indexProp ??\n    descendants.findIndex((item) => item.element === descendant.element);\n\n  let previousDescendants = usePrevious(descendants);\n\n  // We also need to re-register descendants any time ANY of the other\n  // descendants have changed. My brain was melting when I wrote this and it\n  // feels a little off, but checking in render and using the result in the\n  // effect's dependency array works well enough.\n  let someDescendantsHaveChanged = descendants.some((descendant, index) => {\n    return descendant.element !== previousDescendants?.[index]?.element;\n  });\n\n  // Prevent any flashing\n  useIsomorphicLayoutEffect(() => {\n    if (!descendant.element) forceUpdate();\n    registerDescendant({\n      ...descendant,\n      index,\n    } as DescendantType);\n    return () => unregisterDescendant(descendant.element);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    forceUpdate,\n    index,\n    registerDescendant,\n    someDescendantsHaveChanged,\n    unregisterDescendant,\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    ...Object.values(descendant),\n  ]);\n\n  return index;\n}\n\nexport function useDescendantsInit<DescendantType extends Descendant>() {\n  return useState<DescendantType[]>([]);\n}\n\nexport function useDescendants<DescendantType extends Descendant>(\n  ctx: React.Context<DescendantContextValue<DescendantType>>\n) {\n  return useContext(ctx).descendants;\n}\n\nexport function DescendantProvider<DescendantType extends Descendant>({\n  context: Ctx,\n  children,\n  items,\n  set,\n}: {\n  context: React.Context<DescendantContextValue<DescendantType>>;\n  children: React.ReactNode;\n  items: DescendantType[];\n  set: React.Dispatch<React.SetStateAction<DescendantType[]>>;\n}) {\n  let registerDescendant = useCallback(\n    ({\n      element,\n      index: explicitIndex,\n      ...rest\n    }: Omit<DescendantType, \"index\"> & { index?: number | undefined }) => {\n      if (!element) {\n        return;\n      }\n\n      set((items) => {\n        let newItems: DescendantType[];\n        if (explicitIndex != null) {\n          newItems = [\n            ...items,\n            {\n              ...rest,\n              element,\n              index: explicitIndex,\n            } as DescendantType,\n          ];\n        } else if (items.length === 0) {\n          // If there are no items, register at index 0 and bail.\n          newItems = [\n            ...items,\n            {\n              ...rest,\n              element,\n              index: 0,\n            } as DescendantType,\n          ];\n        } else if (items.find((item) => item.element === element)) {\n          // If the element is already registered, just use the same array\n          newItems = items;\n        } else {\n          // When registering a descendant, we need to make sure we insert in\n          // into the array in the same order that it appears in the DOM. So as\n          // new descendants are added or maybe some are removed, we always know\n          // that the array is up-to-date and correct.\n          //\n          // So here we look at our registered descendants and see if the new\n          // element we are adding appears earlier than an existing descendant's\n          // DOM node via `node.compareDocumentPosition`. If it does, we insert\n          // the new element at this index. Because `registerDescendant` will be\n          // called in an effect every time the descendants state value changes,\n          // we should be sure that this index is accurate when descendent\n          // elements come or go from our component.\n          let index = items.findIndex((item) => {\n            if (!item.element || !element) {\n              return false;\n            }\n            // Does this element's DOM node appear before another item in the\n            // array in our DOM tree? If so, return true to grab the index at\n            // this point in the array so we know where to insert the new\n            // element.\n            return Boolean(\n              item.element.compareDocumentPosition(element as Node) &\n                Node.DOCUMENT_POSITION_PRECEDING\n            );\n          });\n\n          let newItem = {\n            ...rest,\n            element,\n            index,\n          } as DescendantType;\n\n          // If an index is not found we will push the element to the end.\n          if (index === -1) {\n            newItems = [...items, newItem];\n          } else {\n            newItems = [\n              ...items.slice(0, index),\n              newItem,\n              ...items.slice(index),\n            ];\n          }\n        }\n        return newItems.map((item, index) => ({ ...item, index }));\n      });\n    },\n    // set is a state setter initialized by the useDescendants hook.\n    // We can safely ignore the lint warning here because it will not change\n    // between renders.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  let unregisterDescendant = useCallback(\n    (element: DescendantType[\"element\"]) => {\n      if (!element) {\n        return;\n      }\n\n      set((items) => items.filter((item) => element !== item.element));\n    },\n    // set is a state setter initialized by the useDescendants hook.\n    // We can safely ignore the lint warning here because it will not change\n    // between renders.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  return (\n    <Ctx.Provider\n      value={useMemo(() => {\n        return {\n          descendants: items,\n          registerDescendant,\n          unregisterDescendant,\n        };\n      }, [items, registerDescendant, unregisterDescendant])}\n    >\n      {children}\n    </Ctx.Provider>\n  );\n}\n\n/**\n * Testing this as an abstraction for compound components that use keyboard\n * navigation. Hoping this will help us prevent bugs and mismatched behavior\n * across various components, but it may also prove to be too messy of an\n * abstraction in the end.\n *\n * Currently used in:\n *   - Tabs\n *   - Accordion\n *\n * @param context\n * @param options\n */\nexport function useDescendantKeyDown<\n  DescendantType extends Descendant,\n  K extends keyof DescendantType = keyof DescendantType\n>(\n  context: React.Context<DescendantContextValue<DescendantType>>,\n  options: {\n    currentIndex: number | null | undefined;\n    key?: K | \"option\";\n    filter?: (descendant: DescendantType) => boolean;\n    orientation?: \"vertical\" | \"horizontal\" | \"both\";\n    rotate?: boolean;\n    rtl?: boolean;\n    callback(nextOption: DescendantType | DescendantType[K]): void;\n  }\n) {\n  let { descendants } = useContext(context);\n  let {\n    callback,\n    currentIndex,\n    filter,\n    key = \"index\" as K,\n    orientation = \"vertical\",\n    rotate = true,\n    rtl = false,\n  } = options;\n  let index = currentIndex ?? -1;\n\n  return function handleKeyDown(event: React.KeyboardEvent) {\n    if (\n      ![\n        \"ArrowDown\",\n        \"ArrowUp\",\n        \"ArrowLeft\",\n        \"ArrowRight\",\n        \"PageUp\",\n        \"PageDown\",\n        \"Home\",\n        \"End\",\n      ].includes(event.key)\n    ) {\n      return;\n    }\n\n    // If we use a filter function, we need to re-index our descendants array\n    // so that filtered descendent elements aren't selected.\n    let selectableDescendants = filter\n      ? descendants.filter(filter)\n      : descendants;\n\n    // Current index should map to the updated array vs. the original\n    // descendants array.\n    if (filter) {\n      index = selectableDescendants.findIndex(\n        (descendant) => descendant.index === currentIndex\n      );\n    }\n\n    // We need some options for any of this to work!\n    if (!selectableDescendants.length) {\n      return;\n    }\n\n    function getNextOption() {\n      let atBottom = index === selectableDescendants.length - 1;\n      return atBottom\n        ? rotate\n          ? getFirstOption()\n          : selectableDescendants[index]\n        : selectableDescendants[(index + 1) % selectableDescendants.length];\n    }\n\n    function getPreviousOption() {\n      let atTop = index === 0;\n      return atTop\n        ? rotate\n          ? getLastOption()\n          : selectableDescendants[index]\n        : selectableDescendants[\n            (index - 1 + selectableDescendants.length) %\n              selectableDescendants.length\n          ];\n    }\n\n    function getFirstOption() {\n      return selectableDescendants[0];\n    }\n\n    function getLastOption() {\n      return selectableDescendants[selectableDescendants.length - 1];\n    }\n\n    switch (event.key) {\n      case \"ArrowDown\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          let next = getNextOption();\n          callback(key === \"option\" ? next : next[key]);\n        }\n        break;\n      case \"ArrowUp\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          let prev = getPreviousOption();\n          callback(key === \"option\" ? prev : prev[key]);\n        }\n        break;\n      case \"ArrowLeft\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          let nextOrPrev = (rtl ? getNextOption : getPreviousOption)();\n          callback(key === \"option\" ? nextOrPrev : nextOrPrev[key]);\n        }\n        break;\n      case \"ArrowRight\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          let prevOrNext = (rtl ? getPreviousOption : getNextOption)();\n          callback(key === \"option\" ? prevOrNext : prevOrNext[key]);\n        }\n        break;\n      case \"PageUp\":\n        event.preventDefault();\n        let prevOrFirst = (event.ctrlKey\n          ? getPreviousOption\n          : getFirstOption)();\n        callback(key === \"option\" ? prevOrFirst : prevOrFirst[key]);\n        break;\n      case \"Home\":\n        event.preventDefault();\n        let first = getFirstOption();\n        callback(key === \"option\" ? first : first[key]);\n        break;\n      case \"PageDown\":\n        event.preventDefault();\n        let nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();\n        callback(key === \"option\" ? nextOrLast : nextOrLast[key]);\n        break;\n      case \"End\":\n        event.preventDefault();\n        let last = getLastOption();\n        callback(key === \"option\" ? last : last[key]);\n        break;\n    }\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\ntype SomeElement<T> = T extends Element ? T : HTMLElement;\n\nexport type Descendant<ElementType = HTMLElement> = {\n  element: SomeElement<ElementType> | null;\n  index: number;\n};\n\nexport interface DescendantContextValue<DescendantType extends Descendant> {\n  descendants: DescendantType[];\n  registerDescendant(descendant: DescendantType): void;\n  unregisterDescendant(element: DescendantType[\"element\"]): void;\n}\n", "/**\n * Welcome to @reach/menu-button!\n *\n * An accessible dropdown menu for the common dropdown menu button design\n * pattern.\n *\n * @see Docs     https://reach.tech/menu-button\n * @see Source   https://github.com/reach/reach-ui/tree/main/packages/menu-button\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#menubutton\n *\n * TODO: Fix flash when opening a menu button on a screen with another open menu\n */\n\nimport React, {\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n} from \"react\";\nimport PropTypes from \"prop-types\";\nimport { useId } from \"@reach/auto-id\";\nimport Popover, { Position } from \"@reach/popover\";\nimport {\n  createDescendantContext,\n  Descendant,\n  DescendantProvider,\n  useDescendant,\n  useDescendants,\n  useDescendantsInit,\n  useDescendantKeyDown,\n} from \"@reach/descendants\";\nimport {\n  checkStyles,\n  createNamedContext,\n  forwardRefWithAs,\n  getOwnerDocument,\n  isFunction,\n  isString,\n  makeId,\n  noop,\n  useForkedRef,\n  usePrevious,\n  wrapEvent,\n} from \"@reach/utils\";\n\n////////////////////////////////////////////////////////////////////////////////\n// Actions\n\nconst CLEAR_SELECTION_INDEX = \"CLEAR_SELECTION_INDEX\";\nconst CLICK_MENU_ITEM = \"CLICK_MENU_ITEM\";\nconst CLOSE_MENU = \"CLOSE_MENU\";\nconst OPEN_MENU_AT_FIRST_ITEM = \"OPEN_MENU_AT_FIRST_ITEM\";\nconst OPEN_MENU_AT_INDEX = \"OPEN_MENU_AT_INDEX\";\nconst OPEN_MENU_CLEARED = \"OPEN_MENU_CLEARED\";\nconst SEARCH_FOR_ITEM = \"SEARCH_FOR_ITEM\";\nconst SELECT_ITEM_AT_INDEX = \"SELECT_ITEM_AT_INDEX\";\nconst SET_BUTTON_ID = \"SET_BUTTON_ID\";\n\nconst MenuDescendantContext = createDescendantContext<MenuButtonDescendant>(\n  \"MenuDescendantContext\"\n);\nconst MenuContext = createNamedContext<InternalMenuContextValue>(\n  \"MenuContext\",\n  {} as InternalMenuContextValue\n);\n\nconst initialState: MenuButtonState = {\n  // The button ID is needed for aria controls and can be set directly and\n  // updated for top-level use via context. Otherwise a default is set by useId.\n  // TODO: Consider deprecating direct ID in 1.0 in favor of id at the top level\n  //       for passing deterministic IDs to descendent components.\n  buttonId: null,\n\n  // Whether or not the menu is expanded\n  isExpanded: false,\n\n  // When a user begins typing a character string, the selection will change if\n  // a matching item is found\n  typeaheadQuery: \"\",\n\n  // The index of the current selected item. When the selection is cleared a\n  // value of -1 is used.\n  selectionIndex: -1,\n};\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Menu\n *\n * The wrapper component for the other components. No DOM element is rendered.\n *\n * @see Docs https://reach.tech/menu-button#menu\n */\nexport const Menu: React.FC<MenuProps> = ({ id, children }) => {\n  let buttonRef = useRef(null);\n  let menuRef = useRef(null);\n  let popoverRef = useRef(null);\n  let [descendants, setDescendants] = useDescendantsInit<\n    MenuButtonDescendant\n  >();\n  let [state, dispatch] = useReducer(reducer, initialState);\n  let _id = useId(id);\n  let menuId = id || makeId(\"menu\", _id);\n\n  // We use an event listener attached to the window to capture outside clicks\n  // that close the menu. We don't want the initial button click to trigger this\n  // when a menu is closed, so we can track this behavior in a ref for now.\n  // We shouldn't need this when we rewrite with state machine logic.\n  let buttonClickedRef = useRef(false);\n\n  // We will put children callbacks in a ref to avoid triggering endless render\n  // loops when using render props if the app code doesn't useCallback\n  // https://github.com/reach/reach-ui/issues/523\n  let selectCallbacks = useRef([]);\n\n  // If the popover's position overlaps with an option when the popover\n  // initially opens, the mouseup event will trigger a select. To prevent that,\n  // we decide the menu button is only ready to make a selection if the pointer\n  // moves first, otherwise the user is just registering the initial button\n  // click rather than selecting an item. This is similar to a native select\n  // on most platforms, and our menu button popover works similarly.\n  let readyToSelect = useRef(false);\n\n  let context: InternalMenuContextValue = {\n    buttonRef,\n    dispatch,\n    menuId,\n    menuRef,\n    popoverRef,\n    buttonClickedRef,\n    readyToSelect,\n    selectCallbacks,\n    state,\n  };\n\n  // When the menu is open, focus is placed on the menu itself so that\n  // keyboard navigation is still possible.\n  useEffect(() => {\n    if (state.isExpanded) {\n      // @ts-ignore\n      window.__REACH_DISABLE_TOOLTIPS = true;\n      window.requestAnimationFrame(() => {\n        focus(menuRef.current);\n      });\n    } else {\n      // We want to ignore the immediate focus of a tooltip so it doesn't pop\n      // up again when the menu closes, only pops up when focus returns again\n      // to the tooltip (like native OS tooltips).\n      // @ts-ignore\n      window.__REACH_DISABLE_TOOLTIPS = false;\n    }\n  }, [state.isExpanded]);\n\n  useEffect(() => checkStyles(\"menu-button\"), []);\n\n  return (\n    <DescendantProvider\n      context={MenuDescendantContext}\n      items={descendants}\n      set={setDescendants}\n    >\n      <MenuContext.Provider value={context}>\n        {isFunction(children)\n          ? children({\n              isExpanded: state.isExpanded,\n              // TODO: Remove in 1.0\n              isOpen: state.isExpanded,\n            })\n          : children}\n      </MenuContext.Provider>\n    </DescendantProvider>\n  );\n};\n\n/**\n * @see Docs https://reach.tech/menu-button#menu-props\n */\nexport interface MenuProps {\n  /**\n   * Requires two children: a `<MenuButton>` and a `<MenuList>`.\n   *\n   * @see Docs https://reach.tech/menu-button#menu-children\n   */\n  children:\n    | React.ReactNode\n    | ((\n        props: MenuContextValue & {\n          // TODO: Remove in 1.0\n          isOpen: boolean;\n        }\n      ) => React.ReactNode);\n  id?: string;\n}\n\nif (__DEV__) {\n  Menu.displayName = \"Menu\";\n  Menu.propTypes = {\n    children: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * MenuButton\n *\n * Wraps a DOM `button` that toggles the opening and closing of the dropdown\n * menu. Must be rendered inside of a `<Menu>`.\n *\n * @see Docs https://reach.tech/menu-button#menubutton\n */\nexport const MenuButton = forwardRefWithAs<MenuButtonProps, \"button\">(\n  function MenuButton(\n    { as: Comp = \"button\", onKeyDown, onMouseDown, id, ...props },\n    forwardedRef\n  ) {\n    let {\n      buttonRef,\n      buttonClickedRef,\n      menuId,\n      state: { buttonId, isExpanded },\n      dispatch,\n    } = useContext(MenuContext);\n    let ref = useForkedRef(buttonRef, forwardedRef);\n    let items = useDescendants(MenuDescendantContext);\n    let firstNonDisabledIndex = useMemo(\n      () => items.findIndex((item) => !item.disabled),\n      [items]\n    );\n    useEffect(() => {\n      let newButtonId =\n        id != null\n          ? id\n          : menuId\n          ? makeId(\"menu-button\", menuId)\n          : \"menu-button\";\n      if (buttonId !== newButtonId) {\n        dispatch({\n          type: SET_BUTTON_ID,\n          payload: newButtonId,\n        });\n      }\n    }, [buttonId, dispatch, id, menuId]);\n\n    function handleKeyDown(event: React.KeyboardEvent) {\n      switch (event.key) {\n        case \"ArrowDown\":\n        case \"ArrowUp\":\n          event.preventDefault(); // prevent scroll\n          dispatch({\n            type: OPEN_MENU_AT_INDEX,\n            payload: { index: firstNonDisabledIndex },\n          });\n          break;\n        case \"Enter\":\n        case \" \":\n          dispatch({\n            type: OPEN_MENU_AT_INDEX,\n            payload: { index: firstNonDisabledIndex },\n          });\n          break;\n        default:\n          break;\n      }\n    }\n\n    function handleMouseDown(event: React.MouseEvent) {\n      if (!isExpanded) {\n        buttonClickedRef.current = true;\n      }\n      if (isRightClick(event.nativeEvent)) {\n        return;\n      } else if (isExpanded) {\n        dispatch({ type: CLOSE_MENU, payload: { buttonRef } });\n      } else {\n        dispatch({ type: OPEN_MENU_CLEARED });\n      }\n    }\n\n    return (\n      <Comp\n        // When the menu is displayed, the element with role `button` has\n        // `aria-expanded` set to `true`. When the menu is hidden, it is\n        // recommended that `aria-expanded` is not present.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#menubutton\n        aria-expanded={isExpanded ? true : undefined}\n        // The element with role `button` has `aria-haspopup` set to either\n        // `\"menu\"` or `true`.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#menubutton\n        aria-haspopup\n        // Optionally, the element with role `button` has a value specified for\n        // `aria-controls` that refers to the element with role `menu`.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#menubutton\n        aria-controls={menuId}\n        {...props}\n        ref={ref}\n        data-reach-menu-button=\"\"\n        id={buttonId || undefined}\n        onKeyDown={wrapEvent(onKeyDown, handleKeyDown)}\n        onMouseDown={wrapEvent(onMouseDown, handleMouseDown)}\n        type=\"button\"\n      />\n    );\n  }\n);\n\n/**\n * @see Docs https://reach.tech/menu-button#menubutton-props\n */\nexport type MenuButtonProps = React.ButtonHTMLAttributes<HTMLButtonElement> & {\n  /**\n   * Accepts any renderable content.\n   *\n   * @see Docs https://reach.tech/menu-button#menubutton-children\n   */\n  children: React.ReactNode;\n};\n\nif (__DEV__) {\n  MenuButton.displayName = \"MenuButton\";\n  MenuButton.propTypes = {\n    children: PropTypes.node,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * MenuItemImpl\n *\n * MenuItem and MenuLink share most of the same functionality captured here.\n */\nconst MenuItemImpl = forwardRefWithAs<MenuItemImplProps, \"div\">(\n  function MenuItemImpl(\n    {\n      as: Comp,\n      index: indexProp,\n      isLink = false,\n      onClick,\n      onDragStart,\n      onMouseDown,\n      onMouseEnter,\n      onMouseLeave,\n      onMouseMove,\n      onMouseUp,\n      onSelect,\n      disabled,\n      valueText: valueTextProp,\n      ...props\n    },\n    forwardedRef\n  ) {\n    let {\n      buttonRef,\n      dispatch,\n      readyToSelect,\n      selectCallbacks,\n      state: { selectionIndex, isExpanded },\n    } = useContext(MenuContext);\n    let ownRef = useRef<HTMLElement | null>(null);\n    // After the ref is mounted to the DOM node, we check to see if we have an\n    // explicit valueText prop before looking for the node's textContent for\n    // typeahead functionality.\n    let [valueText, setValueText] = useState(valueTextProp || \"\");\n    let setValueTextFromDom = useCallback(\n      (node) => {\n        if (node) {\n          ownRef.current = node;\n          if (\n            !valueTextProp ||\n            (node.textContent && valueText !== node.textContent)\n          ) {\n            setValueText(node.textContent);\n          }\n        }\n      },\n      [valueText, valueTextProp]\n    );\n\n    let ref = useForkedRef(forwardedRef, setValueTextFromDom);\n\n    let mouseEventStarted = useRef(false);\n\n    let index = useDescendant(\n      {\n        element: ownRef.current!,\n        key: valueText,\n        disabled,\n        isLink,\n      },\n      MenuDescendantContext,\n      indexProp\n    );\n    let isSelected = index === selectionIndex && !disabled;\n\n    // Update the callback ref array on every render\n    selectCallbacks.current[index] = onSelect;\n\n    function select() {\n      focus(buttonRef.current);\n      onSelect && onSelect();\n      dispatch({ type: CLICK_MENU_ITEM });\n    }\n\n    function handleClick(event: React.MouseEvent) {\n      if (isLink && !isRightClick(event.nativeEvent)) {\n        if (disabled) {\n          event.preventDefault();\n        } else {\n          select();\n        }\n      }\n    }\n\n    function handleDragStart(event: React.MouseEvent) {\n      // Because we don't preventDefault on mousedown for links (we need the\n      // native click event), clicking and holding on a link triggers a\n      // dragstart which we don't want.\n      if (isLink) {\n        event.preventDefault();\n      }\n    }\n\n    function handleMouseDown(event: React.MouseEvent) {\n      if (isRightClick(event.nativeEvent)) return;\n\n      if (isLink) {\n        // Signal that the mouse is down so we can react call the right function\n        // if the user is clicking on a link.\n        mouseEventStarted.current = true;\n      } else {\n        event.preventDefault();\n      }\n    }\n\n    function handleMouseEnter(event: React.MouseEvent) {\n      if (!isSelected && index != null && !disabled) {\n        dispatch({ type: SELECT_ITEM_AT_INDEX, payload: { index } });\n      }\n    }\n\n    function handleMouseLeave(event: React.MouseEvent) {\n      // Clear out selection when mouse over a non-menu item child.\n      dispatch({ type: CLEAR_SELECTION_INDEX });\n    }\n\n    function handleMouseMove() {\n      readyToSelect.current = true;\n      if (!isSelected && index != null && !disabled) {\n        dispatch({ type: SELECT_ITEM_AT_INDEX, payload: { index } });\n      }\n    }\n\n    function handleMouseUp(event: React.MouseEvent) {\n      if (!readyToSelect.current) {\n        readyToSelect.current = true;\n        return;\n      }\n      if (isRightClick(event.nativeEvent)) return;\n\n      if (isLink) {\n        // If a mousedown event was initiated on a menu link followed by a\n        // mouseup event on the same link, we do nothing; a click event will\n        // come next and handle selection. Otherwise, we trigger a click event.\n        if (mouseEventStarted.current) {\n          mouseEventStarted.current = false;\n        } else if (ownRef.current) {\n          ownRef.current.click();\n        }\n      } else {\n        if (!disabled) {\n          select();\n        }\n      }\n    }\n\n    // When the menu closes, reset readyToSelect for the next interaction.\n    useEffect(() => {\n      if (!isExpanded) {\n        readyToSelect.current = false;\n      }\n    }, [isExpanded, readyToSelect]);\n\n    // Any time a mouseup event occurs anywhere in the document, we reset the\n    // mouseEventStarted ref so we can check it again when needed.\n    useEffect(() => {\n      let ownerDocument = getOwnerDocument(ownRef.current) || document;\n      let listener = () => (mouseEventStarted.current = false);\n      ownerDocument.addEventListener(\"mouseup\", listener);\n      return () => ownerDocument.removeEventListener(\"mouseup\", listener);\n    }, []);\n\n    return (\n      <Comp\n        role=\"menuitem\"\n        id={useMenuItemId(index)}\n        tabIndex={-1}\n        {...props}\n        ref={ref}\n        aria-disabled={disabled || undefined}\n        data-reach-menu-item=\"\"\n        data-selected={isSelected ? \"\" : undefined}\n        data-valuetext={valueText}\n        onClick={wrapEvent(onClick, handleClick)}\n        onDragStart={wrapEvent(onDragStart, handleDragStart)}\n        onMouseDown={wrapEvent(onMouseDown, handleMouseDown)}\n        onMouseEnter={wrapEvent(onMouseEnter, handleMouseEnter)}\n        onMouseLeave={wrapEvent(onMouseLeave, handleMouseLeave)}\n        onMouseMove={wrapEvent(onMouseMove, handleMouseMove)}\n        onMouseUp={wrapEvent(onMouseUp, handleMouseUp)}\n      />\n    );\n  }\n);\n\nexport type MenuItemImplProps = {\n  /**\n   * You can put any type of content inside of a `<MenuItem>`.\n   *\n   * @see Docs https://reach.tech/menu-button#menuitem-children\n   */\n  children: React.ReactNode;\n  /**\n   * Callback that fires when a `MenuItem` is selected.\n   *\n   * @see Docs https://reach.tech/menu-button#menuitem-onselect\n   */\n  onSelect(): void;\n  index?: number;\n  isLink?: boolean;\n  valueText?: string;\n  /**\n   * Whether or not the item is disabled from selection and navigation.\n   *\n   * @see Docs https://reach.tech/menu-button#menuitem-disabled\n   */\n  disabled?: boolean;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * MenuItem\n *\n * Handles menu selection. Must be a direct child of a `<MenuList>`.\n *\n * @see Docs https://reach.tech/menu-button#menuitem\n */\nexport const MenuItem = forwardRefWithAs<MenuItemProps, \"div\">(\n  function MenuItem({ as = \"div\", ...props }, forwardedRef) {\n    return <MenuItemImpl {...props} ref={forwardedRef} as={as} />;\n  }\n);\n\n/**\n * @see Docs https://reach.tech/menu-button#menuitem-props\n */\nexport type MenuItemProps = Omit<MenuItemImplProps, \"isLink\">;\n\nif (__DEV__) {\n  MenuItem.displayName = \"MenuItem\";\n  MenuItem.propTypes = {\n    as: PropTypes.any,\n    onSelect: PropTypes.func.isRequired,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * MenuItems\n *\n * A low-level wrapper for menu items. Compose it with `MenuPopover` for more\n * control over the nested components and their rendered DOM nodes, or if you\n * need to nest arbitrary components between the outer wrapper and your list.\n *\n * @see Docs https://reach.tech/menu-button#menuitems\n */\nexport const MenuItems = forwardRefWithAs<MenuItemsProps, \"div\">(\n  function MenuItems(\n    { as: Comp = \"div\", children, id, onKeyDown, ...props },\n    forwardedRef\n  ) {\n    const {\n      menuId,\n      dispatch,\n      buttonRef,\n      menuRef,\n      selectCallbacks,\n      state: { isExpanded, buttonId, selectionIndex, typeaheadQuery },\n    } = useContext(MenuContext);\n    const menuItems = useDescendants(MenuDescendantContext);\n    const ref = useForkedRef(menuRef, forwardedRef);\n\n    useEffect(() => {\n      // Respond to user char key input with typeahead\n      const match = findItemFromTypeahead(menuItems, typeaheadQuery);\n      if (typeaheadQuery && match != null) {\n        dispatch({\n          type: SELECT_ITEM_AT_INDEX,\n          payload: { index: match },\n        });\n      }\n      let timeout = window.setTimeout(\n        () =>\n          typeaheadQuery && dispatch({ type: SEARCH_FOR_ITEM, payload: \"\" }),\n        1000\n      );\n      return () => window.clearTimeout(timeout);\n    }, [dispatch, menuItems, typeaheadQuery]);\n\n    const prevMenuItemsLength = usePrevious(menuItems.length);\n    const prevSelected = usePrevious(menuItems[selectionIndex]);\n    const prevSelectionIndex = usePrevious(selectionIndex);\n\n    useEffect(() => {\n      if (selectionIndex > menuItems.length - 1) {\n        // If for some reason our selection index is larger than our possible\n        // index range (let's say the last item is selected and the list\n        // dynamically updates), we need to select the last item in the list.\n        dispatch({\n          type: SELECT_ITEM_AT_INDEX,\n          payload: { index: menuItems.length - 1 },\n        });\n      } else if (\n        // Checks if\n        //  - menu length has changed\n        //  - selection index has not changed BUT selected item has changed\n        //\n        // This prevents any dynamic adding/removing of menu items from actually\n        // changing a user's expected selection.\n        prevMenuItemsLength !== menuItems.length &&\n        selectionIndex > -1 &&\n        prevSelected &&\n        prevSelectionIndex === selectionIndex &&\n        menuItems[selectionIndex] !== prevSelected\n      ) {\n        dispatch({\n          type: SELECT_ITEM_AT_INDEX,\n          payload: {\n            index: menuItems.findIndex((i) => i.key === prevSelected.key),\n          },\n        });\n      }\n    }, [\n      dispatch,\n      menuItems,\n      prevMenuItemsLength,\n      prevSelected,\n      prevSelectionIndex,\n      selectionIndex,\n    ]);\n\n    let handleKeyDown = wrapEvent(\n      function handleKeyDown(event: React.KeyboardEvent) {\n        let { key } = event;\n\n        if (!isExpanded) {\n          return;\n        }\n\n        switch (key) {\n          case \"Enter\":\n          case \" \":\n            let selected = menuItems.find(\n              (item) => item.index === selectionIndex\n            );\n            // For links, the Enter key will trigger a click by default, but for\n            // consistent behavior across menu items we'll trigger a click when\n            // the spacebar is pressed.\n            if (selected) {\n              if (selected.isLink && selected.element) {\n                selected.element.click();\n              } else {\n                event.preventDefault();\n                // Focus the button first by default when an item is selected.\n                // We fire the onSelect callback next so the app can manage\n                // focus if needed.\n                focus(buttonRef.current);\n                selectCallbacks.current[selected.index] &&\n                  selectCallbacks.current[selected.index]();\n                dispatch({ type: CLICK_MENU_ITEM });\n              }\n            }\n            break;\n          case \"Escape\":\n            focus(buttonRef.current);\n            dispatch({ type: CLOSE_MENU, payload: { buttonRef } });\n            break;\n          case \"Tab\":\n            // prevent leaving\n            event.preventDefault();\n            break;\n          default:\n            // Check if a user is typing some char keys and respond by setting\n            // the query state.\n            if (isString(key) && key.length === 1) {\n              const query = typeaheadQuery + key.toLowerCase();\n              dispatch({\n                type: SEARCH_FOR_ITEM,\n                payload: query,\n              });\n            }\n            break;\n        }\n      },\n      useDescendantKeyDown(MenuDescendantContext, {\n        currentIndex: selectionIndex,\n        orientation: \"vertical\",\n        rotate: false,\n        filter: (item) => !item.disabled,\n        callback: (index: number) => {\n          dispatch({\n            type: SELECT_ITEM_AT_INDEX,\n            payload: { index },\n          });\n        },\n        key: \"index\",\n      })\n    );\n\n    return (\n      // TODO: Should probably file a but in jsx-a11y, but this is correct\n      // according to https://www.w3.org/TR/wai-aria-practices-1.2/examples/menu-button/menu-button-actions-active-descendant.html\n      // eslint-disable-next-line jsx-a11y/aria-activedescendant-has-tabindex\n      <Comp\n        // Refers to the descendant menuitem element that is visually indicated\n        // as focused.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/examples/menu-button/menu-button-actions-active-descendant.html\n        aria-activedescendant={useMenuItemId(selectionIndex) || undefined}\n        // Refers to the element that contains the accessible name for the\n        // `menu`. The menu is labeled by the menu button.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/examples/menu-button/menu-button-actions-active-descendant.html\n        aria-labelledby={buttonId || undefined}\n        // The element that contains the menu items displayed by activating the\n        // button has role menu.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#menubutton\n        role=\"menu\"\n        tabIndex={-1}\n        {...props}\n        ref={ref}\n        data-reach-menu-items=\"\"\n        id={menuId}\n        onKeyDown={wrapEvent(onKeyDown, handleKeyDown)}\n      >\n        {children}\n      </Comp>\n    );\n  }\n);\n\n/**\n * @see Docs https://reach.tech/menu-button#menuitems-props\n */\nexport type MenuItemsProps = {\n  /**\n   * Can contain only `MenuItem` or a `MenuLink`.\n   *\n   * @see Docs https://reach.tech/menu-button#menuitems-children\n   */\n  children: React.ReactNode;\n} & React.HTMLAttributes<HTMLDivElement>;\n\nif (__DEV__) {\n  MenuItems.displayName = \"MenuItems\";\n  MenuItems.propTypes = {\n    children: PropTypes.node,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * MenuLink\n *\n * Handles linking to a different page in the menu. By default it renders `<a>`,\n * but also accepts any other kind of Link as long as the `Link` uses the\n * `React.forwardRef` API.\n *\n * Must be a direct child of a `<MenuList>`.\n *\n * @see Docs https://reach.tech/menu-button#menulink\n */\nexport const MenuLink = forwardRefWithAs<\n  MenuLinkProps & { component?: any },\n  \"a\"\n>(function MenuLink({ as = \"a\", component, onSelect, ...props }, forwardedRef) {\n  if (component) {\n    console.warn(\n      \"[@reach/menu-button]: Please use the `as` prop instead of `component`.\"\n    );\n  }\n\n  return (\n    <div role=\"none\" tabIndex={-1}>\n      <MenuItemImpl\n        {...props}\n        ref={forwardedRef}\n        data-reach-menu-link=\"\"\n        as={as}\n        isLink={true}\n        onSelect={onSelect || noop}\n      />\n    </div>\n  );\n});\n\n/**\n * @see Docs https://reach.tech/menu-button#menulink-props\n */\nexport type MenuLinkProps = Omit<MenuItemImplProps, \"isLink\" | \"onSelect\"> & {\n  onSelect?(): void;\n};\n\nif (__DEV__) {\n  MenuLink.displayName = \"MenuLink\";\n  MenuLink.propTypes = {\n    as: PropTypes.any,\n    component: PropTypes.any,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * MenuList\n *\n * Wraps a DOM element that renders the menu items. Must be rendered inside of\n * a `<Menu>`.\n *\n * @see Docs https://reach.tech/menu-button#menulist\n */\nexport const MenuList = forwardRef<HTMLDivElement, MenuListProps>(\n  function MenuList({ portal = true, ...props }, forwardedRef) {\n    return (\n      <MenuPopover portal={portal}>\n        <MenuItems {...props} ref={forwardedRef} data-reach-menu-list=\"\" />\n      </MenuPopover>\n    );\n  }\n);\n\n/**\n * @see Docs https://reach.tech/menu-button#menulist-props\n */\nexport type MenuListProps = React.HTMLAttributes<HTMLDivElement> & {\n  /**\n   * Whether or not the popover should be rendered inside a portal. Defaults to\n   * `true`.\n   *\n   * @see Docs https://reach.tech/menu-button#menulist-portal\n   */\n  portal?: boolean;\n  /**\n   * Can contain only `MenuItem` or a `MenuLink`.\n   *\n   * @see Docs https://reach.tech/menu-button#menulist-children\n   */\n  children: React.ReactNode;\n};\n\nif (__DEV__) {\n  MenuList.displayName = \"MenuList\";\n  MenuList.propTypes = {\n    children: PropTypes.node.isRequired,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * MenuPopover\n *\n * A low-level wrapper for the popover that appears when a menu button is open.\n * You can compose it with `MenuItems` for more control over the nested\n * components and their rendered DOM nodes, or if you need to nest arbitrary\n * components between the outer wrapper and your list.\n *\n * @see Docs https://reach.tech/menu-button#menupopover\n */\nexport const MenuPopover = forwardRef<any, MenuPopoverProps>(\n  function MenuPopover(\n    { children, portal = true, position, ...props },\n    forwardedRef\n  ) {\n    const {\n      buttonRef,\n      buttonClickedRef,\n      dispatch,\n      menuRef,\n      popoverRef,\n      state: { isExpanded },\n    } = useContext(MenuContext);\n\n    const ref = useForkedRef(popoverRef, forwardedRef);\n\n    useEffect(() => {\n      function listener(event: MouseEvent) {\n        if (buttonClickedRef.current) {\n          buttonClickedRef.current = false;\n        } else {\n          // We on want to close only if focus rests outside the menu\n          if (isExpanded && popoverRef.current) {\n            if (!popoverRef.current.contains(event.target as Element)) {\n              dispatch({ type: CLOSE_MENU, payload: { buttonRef } });\n            }\n          }\n        }\n      }\n      window.addEventListener(\"mousedown\", listener);\n      return () => {\n        window.removeEventListener(\"mousedown\", listener);\n      };\n    }, [\n      buttonClickedRef,\n      buttonRef,\n      dispatch,\n      isExpanded,\n      menuRef,\n      popoverRef,\n    ]);\n\n    let commonProps = {\n      ref,\n      // TODO: remove in 1.0\n      \"data-reach-menu\": \"\",\n      \"data-reach-menu-popover\": \"\",\n      hidden: !isExpanded,\n      children,\n      ...props,\n    };\n\n    return portal ? (\n      <Popover\n        {...commonProps}\n        targetRef={buttonRef as any}\n        position={position}\n      />\n    ) : (\n      <div {...commonProps} />\n    );\n  }\n);\n\n/**\n * @see Docs https://reach.tech/menu-button#menupopover-props\n */\nexport type MenuPopoverProps = React.HTMLAttributes<HTMLDivElement> & {\n  /**\n   * Must contain a `MenuItems`\n   *\n   * @see Docs https://reach.tech/menu-button#menupopover-children\n   */\n  children: React.ReactNode;\n  /**\n   * Whether or not the popover should be rendered inside a portal. Defaults to\n   * `true`.\n   *\n   * @see Docs https://reach.tech/menu-button#menupopover-portal\n   */\n  portal?: boolean;\n  /**\n   * A function used to determine the position of the popover in relation to the\n   * menu button. By default, the menu button will attempt to position the\n   * popover below the button aligned with its left edge. If this positioning\n   * results in collisions with any side of the window, the popover will be\n   * anchored to a different side to avoid those collisions if possible.\n   *\n   * @see Docs https://reach.tech/menu-button#menupopover-position\n   */\n  position?: Position;\n};\n\nif (__DEV__) {\n  MenuPopover.displayName = \"MenuPopover\";\n  MenuPopover.propTypes = {\n    children: PropTypes.node,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A hook that exposes data for a given `Menu` component to its descendants.\n *\n * @see Docs https://reach.tech/menu-button#usemenubuttoncontext\n */\nexport function useMenuButtonContext(): MenuContextValue {\n  let {\n    state: { isExpanded },\n  } = useContext(MenuContext);\n  return useMemo(() => ({ isExpanded }), [isExpanded]);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * When a user's typed input matches the string displayed in a menu item, it is\n * expected that the matching menu item is selected. This is our matching\n * function.\n */\nfunction findItemFromTypeahead(\n  items: MenuButtonDescendant[],\n  string: string = \"\"\n) {\n  if (!string) {\n    return null;\n  }\n\n  const found = items.find((item) => {\n    return item.disabled\n      ? false\n      : item.element?.dataset?.valuetext?.toLowerCase().startsWith(string);\n  });\n  return found ? items.indexOf(found) : null;\n}\n\nfunction useMenuItemId(index: number | null) {\n  let { menuId } = useContext(MenuContext);\n  return index != null && index > -1\n    ? makeId(`option-${index}`, menuId)\n    : undefined;\n}\n\ninterface MenuButtonState {\n  isExpanded: boolean;\n  selectionIndex: number;\n  buttonId: null | string;\n  typeaheadQuery: string;\n}\n\ntype MenuButtonAction =\n  | { type: \"CLICK_MENU_ITEM\" }\n  | { type: \"CLOSE_MENU\"; payload: { buttonRef: ButtonRef } }\n  | { type: \"OPEN_MENU_AT_FIRST_ITEM\" }\n  | { type: \"OPEN_MENU_AT_INDEX\"; payload: { index: number } }\n  | { type: \"OPEN_MENU_CLEARED\" }\n  | {\n      type: \"SELECT_ITEM_AT_INDEX\";\n      payload: { max?: number; min?: number; index: number };\n    }\n  | { type: \"CLEAR_SELECTION_INDEX\" }\n  | { type: \"SET_BUTTON_ID\"; payload: string }\n  | { type: \"SEARCH_FOR_ITEM\"; payload: string };\n\nfunction isRightClick(nativeEvent: MouseEvent) {\n  return nativeEvent.which === 3 || nativeEvent.button === 2;\n}\n\nfunction focus<T extends HTMLElement = HTMLElement>(\n  element: T | undefined | null\n) {\n  element && element.focus();\n}\n\nfunction reducer(\n  state: MenuButtonState,\n  action: MenuButtonAction = {} as MenuButtonAction\n): MenuButtonState {\n  switch (action.type) {\n    case CLICK_MENU_ITEM:\n      return {\n        ...state,\n        isExpanded: false,\n        selectionIndex: -1,\n      };\n    case CLOSE_MENU:\n      return {\n        ...state,\n        isExpanded: false,\n        selectionIndex: -1,\n      };\n    case OPEN_MENU_AT_FIRST_ITEM:\n      return {\n        ...state,\n        isExpanded: true,\n        selectionIndex: 0,\n      };\n    case OPEN_MENU_AT_INDEX:\n      return {\n        ...state,\n        isExpanded: true,\n        selectionIndex: action.payload.index,\n      };\n    case OPEN_MENU_CLEARED:\n      return {\n        ...state,\n        isExpanded: true,\n        selectionIndex: -1,\n      };\n    case SELECT_ITEM_AT_INDEX:\n      if (action.payload.index >= 0) {\n        return {\n          ...state,\n          selectionIndex:\n            action.payload.max != null\n              ? Math.min(Math.max(action.payload.index, 0), action.payload.max)\n              : Math.max(action.payload.index, 0),\n        };\n      }\n      return state;\n    case CLEAR_SELECTION_INDEX:\n      return {\n        ...state,\n        selectionIndex: -1,\n      };\n    case SET_BUTTON_ID:\n      return {\n        ...state,\n        buttonId: action.payload,\n      };\n    case SEARCH_FOR_ITEM:\n      if (typeof action.payload !== \"undefined\") {\n        return {\n          ...state,\n          typeaheadQuery: action.payload,\n        };\n      }\n      return state;\n    default:\n      return state;\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\ntype MenuButtonDescendant = Descendant<HTMLElement> & {\n  key: string;\n  isLink: boolean;\n  disabled?: boolean;\n};\n\ntype ButtonRef = React.RefObject<null | HTMLElement>;\ntype MenuRef = React.RefObject<null | HTMLElement>;\ntype PopoverRef = React.RefObject<null | HTMLElement>;\n\ninterface InternalMenuContextValue {\n  buttonRef: ButtonRef;\n  buttonClickedRef: React.MutableRefObject<boolean>;\n  dispatch: React.Dispatch<MenuButtonAction>;\n  menuId: string | undefined;\n  menuRef: MenuRef;\n  popoverRef: PopoverRef;\n  readyToSelect: React.MutableRefObject<boolean>;\n  selectCallbacks: React.MutableRefObject<(() => void)[]>;\n  state: MenuButtonState;\n}\n\nexport type MenuContextValue = {\n  isExpanded: boolean;\n  // id: string | undefined;\n};\n"],
  "mappings": "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",
  "names": ["useIsomorphicLayoutEffect", "canUseDOM", "React", "useLayoutEffect", "useEffect", "checkedPkgs", "checkStyles", "noop", "process", "env", "NODE_ENV", "packageName", "parseInt", "window", "getComputedStyle", "document", "body", "getPropertyValue", "console", "warn", "ponyfillGlobal", "Math", "self", "Function", "assignRef", "ref", "value", "isFunction", "current", "error", "Error", "canUseDOM", "window", "document", "createElement", "createNamedContext", "name", "defaultValue", "Ctx", "createContext", "displayName", "forwardRefWithAs", "render", "React", "forwardRef", "getOwnerDocument", "element", "ownerDocument", "canUseDOM", "document", "isFunction", "value", "toString", "call", "isString", "value", "makeId", "args", "filter", "val", "join", "noop", "useControlledSwitchWarning", "noop", "controlledValue", "controlledPropName", "componentName", "controlledRef", "useRef", "nameCache", "useEffect", "current", "wasControlled", "isControlled", "console", "error", "useCheckStyles", "pkg", "name", "checkStyles", "useForceUpdate", "useState", "Object", "create", "dispatch", "useCallback", "useForkedRef", "refs", "useMemo", "every", "ref", "node", "forEach", "assignRef", "usePrevious", "value", "useRef", "useEffect", "current", "useStateLogger", "noop", "state", "DEBUG", "debugRef", "useRef", "useEffect", "current", "console", "group", "log", "groupEnd", "wrapEvent", "theirHandler", "ourHandler", "event", "defaultPrevented", "serverHandoffComplete", "id", "genId", "useId", "idFromProps", "initialId", "useState", "setId", "useIsomorphicLayoutEffect", "useEffect", "String", "undefined", "Portal", "children", "type", "mountNode", "useRef", "portalNode", "forceUpdate", "useForceUpdate", "useIsomorphicLayoutEffect", "current", "ownerDocument", "createElement", "body", "appendChild", "removeChild", "createPortal", "React", "ref", "displayName", "Rect", "onChange", "observe", "children", "ref", "useRef", "rect", "useRect", "displayName", "propTypes", "PropTypes", "func", "isRequired", "bool", "nodeRef", "useState", "current", "element", "setElement", "initialRectIsSet", "initialRefIsSet", "setRect", "onChangeRef", "useIsomorphicLayoutEffect", "getBoundingClientRect", "observer", "elem", "console", "warn", "cleanup", "observeRect", "unobserve", "Popover", "forwardRef", "props", "ref", "React", "Portal", "PopoverImpl", "displayName", "forwardedRef", "targetRef", "position", "positionDefault", "unstable_observableRefs", "popoverRef", "useRef", "popoverRect", "useRect", "hidden", "targetRect", "useForkedRef", "useSimulateTabNavigationForReactTree", "style", "getStyles", "map", "current", "visibility", "getTopPosition", "getCollisions", "directionUp", "top", "height", "window", "pageYOffset", "directionRight", "left", "right", "width", "pageXOffset", "getCollisions", "targetRect", "popoverRect", "offsetLeft", "offsetBottom", "collisions", "top", "height", "right", "window", "innerWidth", "left", "width", "bottom", "innerHeight", "directionRight", "directionLeft", "directionUp", "directionDown", "useSimulateTabNavigationForReactTree", "triggerRef", "popoverRef", "ownerDocument", "getOwnerDocument", "current", "handleKeyDown", "event", "key", "tabbable", "length", "shiftKey", "shiftTabbedFromElementAfterTrigger", "focusLastTabbableInPopover", "shiftTabbedOutOfPopover", "focusTriggerRef", "shiftTabbedToBrowserChrome", "disableTabbablesInPopover", "tabbedFromTriggerToPopover", "focusFirstPopoverTabbable", "tabbedOutOfPopover", "focusTabbableAfterTrigger", "tabbedToBrowserChrome", "useEffect", "addEventListener", "removeEventListener", "getElementAfterTrigger", "elements", "targetIndex", "indexOf", "elementAfterTrigger", "contains", "activeElement", "preventDefault", "focus", "inPopover", "Boolean", "target", "last", "filter", "element", "restoreTabIndexTuplés", "forEach", "push", "tabIndex", "enableTabbablesInPopover", "createDescendantContext", "name", "initialValue", "descendants", "createNamedContext", "_extends", "registerDescendant", "noop", "unregisterDescendant", "useDescendant", "descendant", "context", "indexProp", "forceUpdate", "useForceUpdate", "useContext", "index", "findIndex", "item", "element", "previousDescendants", "usePrevious", "someDescendantsHaveChanged", "some", "useIsomorphicLayoutEffect", "Object", "values", "useDescendantsInit", "useState", "useDescendants", "ctx", "DescendantProvider", "Ctx", "children", "items", "set", "useCallback", "explicitIndex", "rest", "newItems", "length", "find", "Boolean", "compareDocumentPosition", "Node", "DOCUMENT_POSITION_PRECEDING", "newItem", "slice", "map", "filter", "React", "Provider", "value", "useMemo", "useDescendantKeyDown", "options", "callback", "currentIndex", "key", "orientation", "rotate", "rtl", "handleKeyDown", "event", "includes", "selectableDescendants", "getNextOption", "atBottom", "getFirstOption", "getPreviousOption", "atTop", "getLastOption", "preventDefault", "next", "prev", "nextOrPrev", "prevOrNext", "prevOrFirst", "ctrlKey", "first", "nextOrLast", "last", "CLEAR_SELECTION_INDEX", "CLICK_MENU_ITEM", "CLOSE_MENU", "OPEN_MENU_AT_FIRST_ITEM", "OPEN_MENU_AT_INDEX", "OPEN_MENU_CLEARED", "SEARCH_FOR_ITEM", "SELECT_ITEM_AT_INDEX", "SET_BUTTON_ID", "MenuDescendantContext", "createDescendantContext", "MenuContext", "createNamedContext", "initialState", "buttonId", "isExpanded", "typeaheadQuery", "selectionIndex", "Menu", "id", "children", "buttonRef", "useRef", "menuRef", "popoverRef", "useDescendantsInit", "descendants", "setDescendants", "useReducer", "reducer", "state", "dispatch", "_id", "useId", "menuId", "makeId", "buttonClickedRef", "selectCallbacks", "readyToSelect", "context", "useEffect", "window", "__REACH_DISABLE_TOOLTIPS", "requestAnimationFrame", "focus", "current", "checkStyles", "React", "DescendantProvider", "items", "set", "Provider", "value", "isFunction", "isOpen", "displayName", "propTypes", "PropTypes", "oneOfType", "func", "node", "MenuButton", "forwardRefWithAs", "forwardedRef", "as", "Comp", "onKeyDown", "onMouseDown", "props", "useContext", "ref", "useForkedRef", "useDescendants", "firstNonDisabledIndex", "useMemo", "findIndex", "item", "disabled", "newButtonId", "type", "payload", "handleKeyDown", "event", "key", "preventDefault", "index", "handleMouseDown", "isRightClick", "nativeEvent", "undefined", "wrapEvent", "MenuItemImpl", "indexProp", "isLink", "onClick", "onDragStart", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseUp", "onSelect", "valueTextProp", "valueText", "ownRef", "useState", "setValueText", "setValueTextFromDom", "useCallback", "textContent", "mouseEventStarted", "useDescendant", "element", "isSelected", "select", "handleClick", "handleDragStart", "handleMouseEnter", "handleMouseLeave", "handleMouseMove", "handleMouseUp", "click", "ownerDocument", "getOwnerDocument", "document", "listener", "addEventListener", "removeEventListener", "role", "useMenuItemId", "tabIndex", "MenuItem", "any", "isRequired", "MenuItems", "menuItems", "match", "findItemFromTypeahead", "timeout", "setTimeout", "clearTimeout", "prevMenuItemsLength", "usePrevious", "length", "prevSelected", "prevSelectionIndex", "i", "selected", "find", "isString", "query", "toLowerCase", "useDescendantKeyDown", "currentIndex", "orientation", "rotate", "filter", "callback", "MenuLink", "component", "console", "warn", "noop", "MenuList", "forwardRef", "portal", "MenuPopover", "position", "contains", "target", "commonProps", "_extends", "hidden", "Popover", "targetRef", "useMenuButtonContext", "string", "found", "dataset", "valuetext", "startsWith", "indexOf", "which", "button", "action", "max", "Math", "min"]
}
