{
  "version": 3,
  "sources": ["../../../../../node_modules/search-string/dist/node/utils.js", "../../../../../node_modules/search-string/dist/node/searchString.js", "../../../../../node_modules/search-string/index.js"],
  "sourcesContent": ["'use strict';\n\nfunction getQuotePairMap(str) {\n  if (!str) str = '';\n  var quotePairMap = { single: {}, double: {} };\n\n  var prevQuote = { single: -1, double: -1 };\n  var prevChar = '';\n  for (var i = 0; i < str.length; i++) {\n    var char = str[i];\n    if (prevChar !== '\\\\') {\n      if (char === '\"') {\n        if (prevQuote.double >= 0) {\n          quotePairMap.double[prevQuote.double] = true;\n          quotePairMap.double[i] = true;\n          prevQuote.double = -1;\n        } else {\n          prevQuote.double = i;\n        }\n      } else if (char === \"'\") {\n        if (prevQuote.single >= 0) {\n          quotePairMap.single[prevQuote.single] = true;\n          quotePairMap.single[i] = true;\n          prevQuote.single = -1;\n        } else {\n          prevQuote.single = i;\n        }\n      }\n    }\n    prevChar = char;\n  }\n\n  return quotePairMap;\n}\n\nmodule.exports = {\n  getQuotePairMap: getQuotePairMap\n};", "'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _require = require('./utils'),\n    getQuotePairMap = _require.getQuotePairMap;\n\n// state tokens\n\n\nvar RESET = 'RESET';\nvar IN_OPERAND = 'IN_OPERAND';\nvar IN_TEXT = 'IN_TEXT';\nvar SINGLE_QUOTE = 'SINGLE_QUOTE';\nvar DOUBLE_QUOTE = 'DOUBLE_QUOTE';\n\n/**\n * SearchString is a parsed search string which allows you to fetch conditions\n * and text being searched.\n */\n\nvar SearchString = function () {\n  /**\n   * Not intended for public use. API could change.\n   */\n  function SearchString(conditionArray, textSegments) {\n    _classCallCheck(this, SearchString);\n\n    this.conditionArray = conditionArray;\n    this.textSegments = textSegments;\n    this.string = '';\n    this.isStringDirty = true;\n  }\n\n  /**\n   * @param {String} str to parse e.g. 'to:me -from:joe@acme.com foobar'.\n   * @param {Array} transformTextToConditions Array of functions to transform text into conditions\n   * @returns {SearchString} An instance of this class SearchString.\n   */\n\n\n  _createClass(SearchString, [{\n    key: 'getConditionArray',\n\n\n    /**\n     * @return {Array} conditions, may contain multiple conditions for a particular key.\n     */\n    value: function getConditionArray() {\n      return this.conditionArray;\n    }\n\n    /**\n     * @return {Object} map of conditions and includes a special key 'excludes'.\n     *                  Excludes itself is a map of conditions which were negated.\n     */\n\n  }, {\n    key: 'getParsedQuery',\n    value: function getParsedQuery() {\n      var parsedQuery = { exclude: {} };\n      this.conditionArray.forEach(function (condition) {\n        if (condition.negated) {\n          if (parsedQuery.exclude[condition.keyword]) {\n            parsedQuery.exclude[condition.keyword].push(condition.value);\n          } else {\n            parsedQuery.exclude[condition.keyword] = [condition.value];\n          }\n        } else {\n          if (parsedQuery[condition.keyword]) {\n            parsedQuery[condition.keyword].push(condition.value);\n          } else {\n            parsedQuery[condition.keyword] = [condition.value];\n          }\n        }\n      });\n      return parsedQuery;\n    }\n\n    /**\n     * @return {String} All text segments concateted together joined by a space.\n     *                  If a text segment is negated, it is preceded by a `-`.\n     */\n\n  }, {\n    key: 'getAllText',\n    value: function getAllText() {\n      return this.textSegments ? this.textSegments.map(function (_ref) {\n        var text = _ref.text,\n            negated = _ref.negated;\n        return negated ? '-' + text : text;\n      }).join(' ') : '';\n    }\n\n    /**\n     * @return {Array} all text segment objects, negative or positive\n     *                 e.g. { text: 'foobar', negated: false }\n     */\n\n  }, {\n    key: 'getTextSegments',\n    value: function getTextSegments() {\n      return this.textSegments;\n    }\n\n    /**\n     * Removes keyword-negated pair that matches inputted.\n     * Only removes if entry has same keyword/negated combo.\n     * @param {String} keywordToRemove Keyword to remove.\n     * @param {Boolean} negatedToRemove Whether or not the keyword removed is negated.\n     */\n\n  }, {\n    key: 'removeKeyword',\n    value: function removeKeyword(keywordToRemove, negatedToRemove) {\n      this.conditionArray = this.conditionArray.filter(function (_ref2) {\n        var keyword = _ref2.keyword,\n            negated = _ref2.negated;\n        return keywordToRemove !== keyword || negatedToRemove !== negated;\n      });\n      this.isStringDirty = true;\n    }\n\n    /**\n     * Adds a new entry to search string. Does not dedupe against existing entries.\n     * @param {String} keyword  Keyword to add.\n     * @param {String} value    Value for respective keyword.\n     * @param {Boolean} negated Whether or not keyword/value pair should be negated.\n     */\n\n  }, {\n    key: 'addEntry',\n    value: function addEntry(keyword, value, negated) {\n      this.conditionArray.push({\n        keyword: keyword,\n        value: value,\n        negated: negated\n      });\n      this.isStringDirty = true;\n    }\n\n    /**\n     * Removes an entry from the search string. If more than one entry with the same settings is found,\n     * it removes the first entry matched.\n     *\n     * @param {String} keyword  Keyword to remove.\n     * @param {String} value    Value for respective keyword.\n     * @param {Boolean} negated Whether or not keyword/value pair is be negated.\n     */\n\n  }, {\n    key: 'removeEntry',\n    value: function removeEntry(keyword, value, negated) {\n      var index = this.conditionArray.findIndex(function (entry) {\n        return entry.keyword === keyword && entry.value === value && entry.negated === negated;\n      });\n\n      if (index === -1) return;\n\n      this.conditionArray.splice(index, 1);\n      this.isStringDirty = true;\n    }\n\n    /**\n     * @return {SearchString} A new instance of this class based on current data. \n     */\n\n  }, {\n    key: 'clone',\n    value: function clone() {\n      return new SearchString(this.conditionArray.slice(0), this.textSegments.slice(0));\n    }\n\n    /**\n     * @return {String} Returns this instance synthesized to a string format.\n     *                  Example string: `to:me -from:joe@acme.com foobar`\n     */\n\n  }, {\n    key: 'toString',\n    value: function toString() {\n      if (this.isStringDirty) {\n        // Group keyword, negated pairs as keys\n        var conditionGroups = {};\n        this.conditionArray.forEach(function (_ref3) {\n          var keyword = _ref3.keyword,\n              value = _ref3.value,\n              negated = _ref3.negated;\n\n          var negatedStr = negated ? '-' : '';\n          var conditionGroupKey = '' + negatedStr + keyword;\n          if (conditionGroups[conditionGroupKey]) {\n            conditionGroups[conditionGroupKey].push(value);\n          } else {\n            conditionGroups[conditionGroupKey] = [value];\n          }\n        });\n        // Build conditionStr\n        var conditionStr = '';\n        Object.keys(conditionGroups).forEach(function (conditionGroupKey) {\n          var values = conditionGroups[conditionGroupKey];\n          var safeValues = values.filter(function (v) {\n            return v;\n          }).map(function (v) {\n            var newV = '';\n            var shouldQuote = false;\n            for (var i = 0; i < v.length; i++) {\n              var char = v[i];\n              if (char === '\"') {\n                newV += '\\\\\"';\n              } else {\n                if (char === ' ' || char === ',') {\n                  shouldQuote = true;\n                }\n                newV += char;\n              }\n            }\n            return shouldQuote ? '\"' + newV + '\"' : newV;\n          });\n          if (safeValues.length > 0) {\n            conditionStr += ' ' + conditionGroupKey + ':' + safeValues.join(',');\n          }\n        });\n        this.string = (conditionStr + ' ' + this.getAllText()).trim();\n        this.isStringDirty = false;\n      }\n      return this.string;\n    }\n  }], [{\n    key: 'parse',\n    value: function parse(str) {\n      var transformTextToConditions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      if (!str) str = '';\n      var conditionArray = [];\n      var textSegments = [];\n\n      var addCondition = function addCondition(key, value, negated) {\n        var arrayEntry = { keyword: key, value: value, negated: negated };\n        conditionArray.push(arrayEntry);\n      };\n\n      var addTextSegment = function addTextSegment(text, negated) {\n        var hasTransform = false;\n        transformTextToConditions.forEach(function (transform) {\n          var _transform = transform(text),\n              key = _transform.key,\n              value = _transform.value;\n\n          if (key && value) {\n            addCondition(key, value, negated);\n            hasTransform = true;\n          }\n        });\n        if (!hasTransform) {\n          textSegments.push({ text: text, negated: negated });\n        }\n      };\n\n      var state = void 0;\n      var currentOperand = void 0;\n      var isNegated = void 0;\n      var currentText = void 0;\n      var quoteState = void 0;\n      var prevChar = void 0;\n\n      var performReset = function performReset() {\n        state = RESET;\n        quoteState = RESET;\n        currentOperand = '';\n        currentText = '';\n        isNegated = false;\n        prevChar = '';\n      };\n\n      // Terminology, in this example: 'to:joe@acme.com'\n      // 'to' is the operator\n      // 'joe@acme.com' is the operand\n      // 'to:joe@acme.com' is the condition\n\n      // Possible states:\n      var inText = function inText() {\n        return state === IN_TEXT;\n      }; // could be inside raw text or operator\n      var inOperand = function inOperand() {\n        return state === IN_OPERAND;\n      };\n      var inSingleQuote = function inSingleQuote() {\n        return quoteState === SINGLE_QUOTE;\n      };\n      var inDoubleQuote = function inDoubleQuote() {\n        return quoteState === DOUBLE_QUOTE;\n      };\n      var inQuote = function inQuote() {\n        return inSingleQuote() || inDoubleQuote();\n      };\n\n      performReset();\n\n      var quotePairMap = getQuotePairMap(str);\n\n      for (var i = 0; i < str.length; i++) {\n        var char = str[i];\n        if (char === ' ') {\n          if (inOperand()) {\n            if (inQuote()) {\n              currentOperand += char;\n            } else {\n              addCondition(currentText, currentOperand, isNegated);\n              performReset();\n            }\n          } else if (inText()) {\n            if (inQuote()) {\n              currentText += char;\n            } else {\n              addTextSegment(currentText, isNegated);\n              performReset();\n            }\n          }\n        } else if (char === ',' && inOperand() && !inQuote()) {\n          addCondition(currentText, currentOperand, isNegated);\n          // No reset here because we are still evaluating operands for the same operator\n          currentOperand = '';\n        } else if (char === '-' && !inOperand() && !inText()) {\n          isNegated = true;\n        } else if (char === ':' && !inQuote()) {\n          if (inOperand()) {\n            // If we're in an operand, just push the string on.\n            currentOperand += char;\n          } else if (inText()) {\n            // Skip this char, move states into IN_OPERAND,\n            state = IN_OPERAND;\n          }\n        } else if (char === '\"' && prevChar !== '\\\\' && !inSingleQuote()) {\n          if (inDoubleQuote()) {\n            quoteState = RESET;\n          } else if (quotePairMap.double[i]) {\n            quoteState = DOUBLE_QUOTE;\n          } else if (inOperand()) {\n            currentOperand += char;\n          } else {\n            currentText += char;\n          }\n        } else if (char === \"'\" && prevChar !== '\\\\' && !inDoubleQuote()) {\n          if (inSingleQuote()) {\n            quoteState = RESET;\n          } else if (quotePairMap.single[i]) {\n            quoteState = SINGLE_QUOTE;\n          } else if (inOperand()) {\n            currentOperand += char;\n          } else {\n            currentText += char;\n          }\n        } else if (char !== '\\\\') {\n          // Regular character..\n          if (inOperand()) {\n            currentOperand += char;\n          } else {\n            currentText += char;\n            state = IN_TEXT;\n          }\n        }\n        prevChar = char;\n      }\n      // End of string, add any last entries\n      if (inText()) {\n        addTextSegment(currentText, isNegated);\n      } else if (inOperand()) {\n        addCondition(currentText, currentOperand, isNegated);\n      }\n\n      return new SearchString(conditionArray, textSegments);\n    }\n  }]);\n\n  return SearchString;\n}();\n\nmodule.exports = SearchString;", "\nmodule.exports = require('./dist/node/searchString');\n"],
  "mappings": "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",
  "names": ["SearchString", "addCondition", "addTextSegment", "performReset", "inText", "inOperand", "inSingleQuote", "inDoubleQuote", "inQuote"]
}
