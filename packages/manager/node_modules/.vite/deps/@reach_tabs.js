import {
  boolOrBoolString,
  checkStyles,
  cloneValidElement,
  createNamedContext,
  forwardRefWithAs,
  getElementComputedStyle,
  isFunction,
  isNumber,
  makeId,
  memoWithAs,
  noop,
  useControlledState,
  useControlledSwitchWarning,
  useEventCallback,
  useForkedRef,
  useIsomorphicLayoutEffect,
  usePrevious,
  useUpdateEffect,
  wrapEvent
} from "./chunk-P6EZSIYQ.js";
import "./chunk-6GLVATRU.js";
import {
  require_prop_types
} from "./chunk-PLEWTTGR.js";
import "./chunk-NGRKVEHQ.js";
import {
  require_react
} from "./chunk-CPU6GBAM.js";
import {
  __toESM
} from "./chunk-LFBQMW2U.js";

// ../../node_modules/@reach/tabs/dist/tabs.esm.js
var import_react3 = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());

// ../../node_modules/@reach/descendants/dist/descendants.esm.js
var import_react = __toESM(require_react());
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function createDescendantContext(name, initialValue) {
  if (initialValue === void 0) {
    initialValue = {};
  }
  var descendants = [];
  return createNamedContext(name, _extends({
    descendants,
    registerDescendant: noop,
    unregisterDescendant: noop
  }, initialValue));
}
function useDescendant(descendant, context, indexProp) {
  var _useState = (0, import_react.useState)(), forceUpdate = _useState[1];
  var _useContext = (0, import_react.useContext)(context), registerDescendant = _useContext.registerDescendant, unregisterDescendant = _useContext.unregisterDescendant, descendants = _useContext.descendants;
  var index = indexProp !== null && indexProp !== void 0 ? indexProp : descendants.findIndex(function(item) {
    return item.element === descendant.element;
  });
  var previousDescendants = usePrevious(descendants);
  var someDescendantsHaveChanged = descendants.some(function(descendant2, index2) {
    var _previousDescendants$;
    return descendant2.element !== (previousDescendants === null || previousDescendants === void 0 ? void 0 : (_previousDescendants$ = previousDescendants[index2]) === null || _previousDescendants$ === void 0 ? void 0 : _previousDescendants$.element);
  });
  useIsomorphicLayoutEffect(function() {
    if (!descendant.element)
      forceUpdate({});
    registerDescendant(_extends({}, descendant, {
      index
    }));
    return function() {
      return unregisterDescendant(descendant.element);
    };
  }, [registerDescendant, unregisterDescendant, index, someDescendantsHaveChanged].concat(Object.values(descendant)));
  return index;
}
function useDescendantsInit() {
  return (0, import_react.useState)([]);
}
function useDescendants(ctx) {
  return (0, import_react.useContext)(ctx).descendants;
}
function DescendantProvider(_ref) {
  var Ctx = _ref.context, children = _ref.children, items = _ref.items, set = _ref.set;
  var registerDescendant = (0, import_react.useCallback)(
    function(_ref2) {
      var element = _ref2.element, explicitIndex = _ref2.index, rest = _objectWithoutPropertiesLoose(_ref2, ["element", "index"]);
      if (!element) {
        return;
      }
      set(function(items2) {
        var newItems;
        if (explicitIndex != null) {
          newItems = [].concat(items2, [_extends({}, rest, {
            element,
            index: explicitIndex
          })]);
        } else if (items2.length === 0) {
          newItems = [].concat(items2, [_extends({}, rest, {
            element,
            index: 0
          })]);
        } else if (items2.find(function(item) {
          return item.element === element;
        })) {
          newItems = items2;
        } else {
          var index = items2.findIndex(function(item) {
            if (!item.element || !element) {
              return false;
            }
            return Boolean(item.element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING);
          });
          var newItem = _extends({}, rest, {
            element,
            index
          });
          if (index === -1) {
            newItems = [].concat(items2, [newItem]);
          } else {
            newItems = [].concat(items2.slice(0, index), [newItem], items2.slice(index));
          }
        }
        return newItems.map(function(item, index2) {
          return _extends({}, item, {
            index: index2
          });
        });
      });
    },
    // set is a state setter initialized by the useDescendants hook.
    // We can safely ignore the lint warning here because it will not change
    // between renders.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  var unregisterDescendant = (0, import_react.useCallback)(
    function(element) {
      if (!element) {
        return;
      }
      set(function(items2) {
        return items2.filter(function(item) {
          return element !== item.element;
        });
      });
    },
    // set is a state setter initialized by the useDescendants hook.
    // We can safely ignore the lint warning here because it will not change
    // between renders.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  return import_react.default.createElement(Ctx.Provider, {
    value: (0, import_react.useMemo)(function() {
      return {
        descendants: items,
        registerDescendant,
        unregisterDescendant
      };
    }, [items, registerDescendant, unregisterDescendant])
  }, children);
}
function useDescendantKeyDown(context, options) {
  var _useContext2 = (0, import_react.useContext)(context), descendants = _useContext2.descendants;
  var callback = options.callback, currentIndex = options.currentIndex, filter = options.filter, _options$key = options.key, key = _options$key === void 0 ? "index" : _options$key, _options$orientation = options.orientation, orientation = _options$orientation === void 0 ? "vertical" : _options$orientation, _options$rotate = options.rotate, rotate = _options$rotate === void 0 ? true : _options$rotate, _options$rtl = options.rtl, rtl = _options$rtl === void 0 ? false : _options$rtl;
  var index = currentIndex !== null && currentIndex !== void 0 ? currentIndex : -1;
  return function handleKeyDown(event) {
    if (!["ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight", "PageUp", "PageDown", "Home", "End"].includes(event.key)) {
      return;
    }
    var selectableDescendants = filter ? descendants.filter(filter) : descendants;
    if (filter) {
      index = selectableDescendants.findIndex(function(descendant) {
        return descendant.index === currentIndex;
      });
    }
    if (!selectableDescendants.length) {
      return;
    }
    function getNextOption() {
      var atBottom = index === selectableDescendants.length - 1;
      return atBottom ? rotate ? getFirstOption() : selectableDescendants[index] : selectableDescendants[(index + 1) % selectableDescendants.length];
    }
    function getPreviousOption() {
      var atTop = index === 0;
      return atTop ? rotate ? getLastOption() : selectableDescendants[index] : selectableDescendants[(index - 1 + selectableDescendants.length) % selectableDescendants.length];
    }
    function getFirstOption() {
      return selectableDescendants[0];
    }
    function getLastOption() {
      return selectableDescendants[selectableDescendants.length - 1];
    }
    switch (event.key) {
      case "ArrowDown":
        if (orientation === "vertical" || orientation === "both") {
          event.preventDefault();
          var next = getNextOption();
          callback(key === "option" ? next : next[key]);
        }
        break;
      case "ArrowUp":
        if (orientation === "vertical" || orientation === "both") {
          event.preventDefault();
          var prev = getPreviousOption();
          callback(key === "option" ? prev : prev[key]);
        }
        break;
      case "ArrowLeft":
        if (orientation === "horizontal" || orientation === "both") {
          event.preventDefault();
          var nextOrPrev = (rtl ? getNextOption : getPreviousOption)();
          callback(key === "option" ? nextOrPrev : nextOrPrev[key]);
        }
        break;
      case "ArrowRight":
        if (orientation === "horizontal" || orientation === "both") {
          event.preventDefault();
          var prevOrNext = (rtl ? getPreviousOption : getNextOption)();
          callback(key === "option" ? prevOrNext : prevOrNext[key]);
        }
        break;
      case "PageUp":
        event.preventDefault();
        var prevOrFirst = (event.ctrlKey ? getPreviousOption : getFirstOption)();
        callback(key === "option" ? prevOrFirst : prevOrFirst[key]);
        break;
      case "Home":
        event.preventDefault();
        var first = getFirstOption();
        callback(key === "option" ? first : first[key]);
        break;
      case "PageDown":
        event.preventDefault();
        var nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();
        callback(key === "option" ? nextOrLast : nextOrLast[key]);
        break;
      case "End":
        event.preventDefault();
        var last = getLastOption();
        callback(key === "option" ? last : last[key]);
        break;
    }
  };
}

// ../../node_modules/@reach/auto-id/dist/auto-id.esm.js
var import_react2 = __toESM(require_react());
var serverHandoffComplete = false;
var id = 0;
var genId = function genId2() {
  return ++id;
};
var useId = function useId2(idFromProps) {
  var initialId = idFromProps || (serverHandoffComplete ? genId() : null);
  var _useState = (0, import_react2.useState)(initialId), id2 = _useState[0], setId = _useState[1];
  useIsomorphicLayoutEffect(function() {
    if (id2 === null) {
      setId(genId());
    }
  }, []);
  (0, import_react2.useEffect)(function() {
    if (serverHandoffComplete === false) {
      serverHandoffComplete = true;
    }
  }, []);
  return id2 != null ? String(id2) : void 0;
};

// ../../node_modules/@reach/tabs/dist/tabs.esm.js
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var TabsDescendantsContext = createDescendantContext("TabsDescendantsContext");
var TabPanelDescendantsContext = createDescendantContext("TabPanelDescendantsContext");
var TabsContext = createNamedContext("TabsContext", {});
var TabsKeyboardActivation;
(function(TabsKeyboardActivation2) {
  TabsKeyboardActivation2["Auto"] = "auto";
  TabsKeyboardActivation2["Manual"] = "manual";
})(TabsKeyboardActivation || (TabsKeyboardActivation = {}));
var TabsOrientation;
(function(TabsOrientation2) {
  TabsOrientation2["Horizontal"] = "horizontal";
  TabsOrientation2["Vertical"] = "vertical";
})(TabsOrientation || (TabsOrientation = {}));
var Tabs = forwardRefWithAs(function Tabs2(_ref, ref) {
  var _props$id;
  var _ref$as = _ref.as, Comp = _ref$as === void 0 ? "div" : _ref$as, children = _ref.children, defaultIndex = _ref.defaultIndex, _ref$orientation = _ref.orientation, orientation = _ref$orientation === void 0 ? TabsOrientation.Horizontal : _ref$orientation, _ref$index = _ref.index, controlledIndex = _ref$index === void 0 ? void 0 : _ref$index, _ref$keyboardActivati = _ref.keyboardActivation, keyboardActivation = _ref$keyboardActivati === void 0 ? TabsKeyboardActivation.Auto : _ref$keyboardActivati, onChange = _ref.onChange, _ref$readOnly = _ref.readOnly, readOnly = _ref$readOnly === void 0 ? false : _ref$readOnly, props = _objectWithoutPropertiesLoose2(_ref, ["as", "children", "defaultIndex", "orientation", "index", "keyboardActivation", "onChange", "readOnly"]);
  var isControlled = (0, import_react3.useRef)(controlledIndex != null);
  useControlledSwitchWarning(controlledIndex, "index", "Tabs");
  var _id = useId(props.id);
  var id2 = (_props$id = props.id) !== null && _props$id !== void 0 ? _props$id : makeId("tabs", _id);
  var userInteractedRef = (0, import_react3.useRef)(false);
  var selectedPanelRef = (0, import_react3.useRef)(null);
  var isRTL = (0, import_react3.useRef)(false);
  var _useControlledState = useControlledState(controlledIndex, defaultIndex !== null && defaultIndex !== void 0 ? defaultIndex : 0), selectedIndex = _useControlledState[0], setSelectedIndex = _useControlledState[1];
  var _useState = (0, import_react3.useState)(-1), focusedIndex = _useState[0], setFocusedIndex = _useState[1];
  var _useDescendantsInit = useDescendantsInit(), tabs = _useDescendantsInit[0], setTabs = _useDescendantsInit[1];
  var context = (0, import_react3.useMemo)(function() {
    return {
      focusedIndex,
      id: id2,
      isControlled: isControlled.current,
      isRTL,
      keyboardActivation,
      onFocusPanel: function onFocusPanel() {
        var _selectedPanelRef$cur;
        (_selectedPanelRef$cur = selectedPanelRef.current) === null || _selectedPanelRef$cur === void 0 ? void 0 : _selectedPanelRef$cur.focus();
      },
      onSelectTab: readOnly ? noop : function(index) {
        userInteractedRef.current = true;
        onChange && onChange(index);
        setSelectedIndex(index);
      },
      onSelectTabWithKeyboard: readOnly ? noop : function(index) {
        var _tabs$index$element;
        userInteractedRef.current = true;
        switch (keyboardActivation) {
          case TabsKeyboardActivation.Manual:
            (_tabs$index$element = tabs[index].element) === null || _tabs$index$element === void 0 ? void 0 : _tabs$index$element.focus();
            return;
          case TabsKeyboardActivation.Auto:
          default:
            onChange && onChange(index);
            setSelectedIndex(index);
            return;
        }
      },
      orientation,
      selectedIndex,
      selectedPanelRef,
      setFocusedIndex,
      setSelectedIndex,
      userInteractedRef
    };
  }, [focusedIndex, id2, keyboardActivation, onChange, orientation, readOnly, selectedIndex, setSelectedIndex, tabs]);
  (0, import_react3.useEffect)(function() {
    return checkStyles("tabs");
  }, []);
  return import_react3.default.createElement(DescendantProvider, {
    context: TabsDescendantsContext,
    items: tabs,
    set: setTabs
  }, import_react3.default.createElement(TabsContext.Provider, {
    value: context
  }, import_react3.default.createElement(Comp, Object.assign({}, props, {
    ref,
    "data-reach-tabs": "",
    "data-orientation": orientation,
    id: props.id
  }), isFunction(children) ? children({
    focusedIndex,
    id: id2,
    selectedIndex
  }) : children)));
});
if (true) {
  Tabs.displayName = "Tabs";
  Tabs.propTypes = {
    children: import_prop_types.default.node.isRequired,
    onChange: import_prop_types.default.func,
    orientation: import_prop_types.default.oneOf(Object.values(TabsOrientation)),
    index: function index(props, name, compName, location, propName) {
      var val = props[name];
      if (props.index > -1 && props.onChange == null && props.readOnly !== true) {
        return new Error("You provided a value prop to `" + compName + "` without an `onChange` handler. This will render a read-only tabs element. If the tabs should be mutable use `defaultIndex`. Otherwise, set `onChange`.");
      } else if (val != null && !isNumber(val)) {
        return new Error("Invalid prop `" + propName + "` supplied to `" + compName + "`. Expected `number`, received `" + (Array.isArray(val) ? "array" : typeof val) + "`.");
      }
      return null;
    },
    defaultIndex: import_prop_types.default.number
  };
}
var TabListImpl = forwardRefWithAs(function TabList(_ref2, forwardedRef) {
  var children = _ref2.children, _ref2$as = _ref2.as, Comp = _ref2$as === void 0 ? "div" : _ref2$as, onKeyDown = _ref2.onKeyDown, props = _objectWithoutPropertiesLoose2(_ref2, ["children", "as", "onKeyDown"]);
  var _useContext = (0, import_react3.useContext)(TabsContext), focusedIndex = _useContext.focusedIndex, isControlled = _useContext.isControlled, isRTL = _useContext.isRTL, keyboardActivation = _useContext.keyboardActivation, onSelectTabWithKeyboard = _useContext.onSelectTabWithKeyboard, orientation = _useContext.orientation, selectedIndex = _useContext.selectedIndex, setSelectedIndex = _useContext.setSelectedIndex;
  var tabs = useDescendants(TabsDescendantsContext);
  var ownRef = (0, import_react3.useRef)(null);
  var ref = useForkedRef(forwardedRef, ownRef);
  (0, import_react3.useEffect)(function() {
    if (ownRef.current && (ownRef.current.ownerDocument && ownRef.current.ownerDocument.dir === "rtl" || getElementComputedStyle(ownRef.current, "direction") === "rtl")) {
      isRTL.current = true;
    }
  }, [isRTL]);
  var handleKeyDown = useEventCallback(wrapEvent(onKeyDown, useDescendantKeyDown(TabsDescendantsContext, {
    currentIndex: keyboardActivation === TabsKeyboardActivation.Manual ? focusedIndex : selectedIndex,
    orientation,
    rotate: true,
    callback: onSelectTabWithKeyboard,
    filter: function filter(tab) {
      return !tab.disabled;
    },
    rtl: isRTL.current
  })));
  useIsomorphicLayoutEffect(function() {
    var _tabs$selectedIndex;
    if (!isControlled && boolOrBoolString((_tabs$selectedIndex = tabs[selectedIndex]) === null || _tabs$selectedIndex === void 0 ? void 0 : _tabs$selectedIndex.disabled)) {
      var next = tabs.find(function(tab) {
        return !tab.disabled;
      });
      if (next) {
        setSelectedIndex(next.index);
      }
    }
  }, [tabs, isControlled, selectedIndex, setSelectedIndex]);
  return import_react3.default.createElement(
    Comp,
    Object.assign({
      // The element that serves as the container for the set of tabs has role
      // `tablist`
      // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel
      role: "tablist",
      "aria-orientation": orientation
    }, props, {
      "data-reach-tab-list": "",
      ref,
      onKeyDown: handleKeyDown
    }),
    import_react3.Children.map(children, function(child, index) {
      return cloneValidElement(child, {
        isSelected: index === selectedIndex
      });
    })
  );
});
if (true) {
  TabListImpl.displayName = "TabList";
  TabListImpl.propTypes = {
    as: import_prop_types.default.any,
    children: import_prop_types.default.node
  };
}
var TabList2 = memoWithAs(TabListImpl);
if (true) {
  TabList2.displayName = "TabList";
}
var Tab = forwardRefWithAs(function Tab2(_ref3, forwardedRef) {
  var children = _ref3.children, _ = _ref3.isSelected, _ref3$as = _ref3.as, Comp = _ref3$as === void 0 ? "button" : _ref3$as, indexProp = _ref3.index, disabled = _ref3.disabled, onBlur = _ref3.onBlur, onFocus = _ref3.onFocus, props = _objectWithoutPropertiesLoose2(_ref3, ["children", "isSelected", "as", "index", "disabled", "onBlur", "onFocus"]);
  var _useContext2 = (0, import_react3.useContext)(TabsContext), tabsId = _useContext2.id, onSelectTab = _useContext2.onSelectTab, orientation = _useContext2.orientation, selectedIndex = _useContext2.selectedIndex, userInteractedRef = _useContext2.userInteractedRef, setFocusedIndex = _useContext2.setFocusedIndex;
  var ownRef = (0, import_react3.useRef)(null);
  var ref = useForkedRef(forwardedRef, ownRef);
  var index = useDescendant({
    element: ownRef.current,
    disabled: !!disabled
  }, TabsDescendantsContext, indexProp);
  var htmlType = Comp === "button" && props.type == null ? "button" : props.type;
  var isSelected = index === selectedIndex;
  function onSelect() {
    onSelectTab(index);
  }
  useUpdateEffect(function() {
    if (isSelected && ownRef.current && userInteractedRef.current) {
      userInteractedRef.current = false;
      ownRef.current.focus();
    }
  }, [isSelected, userInteractedRef]);
  var handleFocus = useEventCallback(wrapEvent(onFocus, function() {
    setFocusedIndex(index);
  }));
  var handleBlur = useEventCallback(wrapEvent(onFocus, function() {
    setFocusedIndex(-1);
  }));
  return import_react3.default.createElement(
    Comp,
    Object.assign({
      "aria-controls": makeId(tabsId, "panel", index),
      "aria-disabled": disabled,
      "aria-selected": isSelected,
      // Each element that serves as a tab has role `tab` and is contained
      // within the element with role `tablist`.
      // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel
      role: "tab",
      tabIndex: isSelected ? 0 : -1
    }, props, {
      ref,
      "data-reach-tab": "",
      "data-orientation": orientation,
      "data-selected": isSelected ? "" : void 0,
      disabled,
      id: makeId(tabsId, "tab", index),
      onClick: onSelect,
      onFocus: handleFocus,
      onBlur: handleBlur,
      type: htmlType
    }),
    children
  );
});
if (true) {
  Tab.displayName = "Tab";
  Tab.propTypes = {
    children: import_prop_types.default.node,
    disabled: import_prop_types.default.bool
  };
}
var TabPanelsImpl = forwardRefWithAs(function TabPanels(_ref4, forwardedRef) {
  var children = _ref4.children, _ref4$as = _ref4.as, Comp = _ref4$as === void 0 ? "div" : _ref4$as, props = _objectWithoutPropertiesLoose2(_ref4, ["children", "as"]);
  var ownRef = (0, import_react3.useRef)();
  var ref = useForkedRef(ownRef, forwardedRef);
  var _useDescendantsInit2 = useDescendantsInit(), tabPanels = _useDescendantsInit2[0], setTabPanels = _useDescendantsInit2[1];
  return import_react3.default.createElement(DescendantProvider, {
    context: TabPanelDescendantsContext,
    items: tabPanels,
    set: setTabPanels
  }, import_react3.default.createElement(Comp, Object.assign({}, props, {
    ref,
    "data-reach-tab-panels": ""
  }), children));
});
if (true) {
  TabPanelsImpl.displayName = "TabPanels";
  TabPanelsImpl.propTypes = {
    as: import_prop_types.default.any,
    children: import_prop_types.default.node
  };
}
var TabPanels2 = memoWithAs(TabPanelsImpl);
if (true) {
  TabPanels2.displayName = "TabPanels";
}
var TabPanel = forwardRefWithAs(function TabPanel2(_ref5, forwardedRef) {
  var children = _ref5.children, ariaLabel = _ref5["aria-label"], _ref5$as = _ref5.as, Comp = _ref5$as === void 0 ? "div" : _ref5$as, props = _objectWithoutPropertiesLoose2(_ref5, ["children", "aria-label", "as"]);
  var _useContext3 = (0, import_react3.useContext)(TabsContext), selectedPanelRef = _useContext3.selectedPanelRef, selectedIndex = _useContext3.selectedIndex, tabsId = _useContext3.id;
  var ownRef = (0, import_react3.useRef)(null);
  var index = useDescendant({
    element: ownRef.current
  }, TabPanelDescendantsContext);
  var id2 = makeId(tabsId, "panel", index);
  var isSelected = index === selectedIndex;
  var readyToHide = (0, import_react3.useRef)(false);
  var hidden = readyToHide.current ? !isSelected : false;
  import_react3.default.useEffect(function() {
    readyToHide.current = true;
  }, []);
  var ref = useForkedRef(forwardedRef, ownRef, isSelected ? selectedPanelRef : null);
  return import_react3.default.createElement(
    Comp,
    Object.assign({
      "aria-labelledby": makeId(tabsId, "tab", index),
      hidden,
      // Each element that contains the content panel for a tab has role
      // `tabpanel`.
      // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel
      role: "tabpanel",
      tabIndex: isSelected ? 0 : -1
    }, props, {
      ref,
      "data-reach-tab-panel": "",
      id: id2
    }),
    children
  );
});
if (true) {
  TabPanel.displayName = "TabPanel";
  TabPanel.propTypes = {
    as: import_prop_types.default.any,
    children: import_prop_types.default.node
  };
}
function useTabsContext() {
  var _useContext4 = (0, import_react3.useContext)(TabsContext), focusedIndex = _useContext4.focusedIndex, id2 = _useContext4.id, selectedIndex = _useContext4.selectedIndex;
  return (0, import_react3.useMemo)(function() {
    return {
      focusedIndex,
      id: id2,
      selectedIndex
    };
  }, [focusedIndex, id2, selectedIndex]);
}
export {
  Tab,
  TabList2 as TabList,
  TabPanel,
  TabPanels2 as TabPanels,
  Tabs,
  TabsKeyboardActivation,
  TabsOrientation,
  useTabsContext
};
//# sourceMappingURL=@reach_tabs.js.map
