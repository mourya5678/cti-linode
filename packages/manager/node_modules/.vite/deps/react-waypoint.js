import {
  require_prop_types
} from "./chunk-PLEWTTGR.js";
import {
  require_react_is
} from "./chunk-NGRKVEHQ.js";
import {
  require_react
} from "./chunk-CPU6GBAM.js";
import {
  __toESM
} from "./chunk-LFBQMW2U.js";

// ../../node_modules/consolidated-events/lib/index.esm.js
var CAN_USE_DOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
function testPassiveEventListeners() {
  if (!CAN_USE_DOM) {
    return false;
  }
  if (!window.addEventListener || !window.removeEventListener || !Object.defineProperty) {
    return false;
  }
  var supportsPassiveOption = false;
  try {
    var opts = Object.defineProperty({}, "passive", {
      // eslint-disable-next-line getter-return
      get: function() {
        function get() {
          supportsPassiveOption = true;
        }
        return get;
      }()
    });
    var noop = function noop2() {
    };
    window.addEventListener("testPassiveEventSupport", noop, opts);
    window.removeEventListener("testPassiveEventSupport", noop, opts);
  } catch (e) {
  }
  return supportsPassiveOption;
}
var memoized = void 0;
function canUsePassiveEventListeners() {
  if (memoized === void 0) {
    memoized = testPassiveEventListeners();
  }
  return memoized;
}
function normalizeEventOptions(eventOptions) {
  if (!eventOptions) {
    return void 0;
  }
  if (!canUsePassiveEventListeners()) {
    return !!eventOptions.capture;
  }
  return eventOptions;
}
function eventOptionsKey(normalizedEventOptions) {
  if (!normalizedEventOptions) {
    return 0;
  }
  if (normalizedEventOptions === true) {
    return 100;
  }
  var capture = normalizedEventOptions.capture << 0;
  var passive = normalizedEventOptions.passive << 1;
  var once = normalizedEventOptions.once << 2;
  return capture + passive + once;
}
function ensureCanMutateNextEventHandlers(eventHandlers) {
  if (eventHandlers.handlers === eventHandlers.nextHandlers) {
    eventHandlers.nextHandlers = eventHandlers.handlers.slice();
  }
}
function TargetEventHandlers(target) {
  this.target = target;
  this.events = {};
}
TargetEventHandlers.prototype.getEventHandlers = function() {
  function getEventHandlers(eventName, options) {
    var key = String(eventName) + " " + String(eventOptionsKey(options));
    if (!this.events[key]) {
      this.events[key] = {
        handlers: [],
        handleEvent: void 0
      };
      this.events[key].nextHandlers = this.events[key].handlers;
    }
    return this.events[key];
  }
  return getEventHandlers;
}();
TargetEventHandlers.prototype.handleEvent = function() {
  function handleEvent(eventName, options, event) {
    var eventHandlers = this.getEventHandlers(eventName, options);
    eventHandlers.handlers = eventHandlers.nextHandlers;
    eventHandlers.handlers.forEach(function(handler) {
      if (handler) {
        handler(event);
      }
    });
  }
  return handleEvent;
}();
TargetEventHandlers.prototype.add = function() {
  function add(eventName, listener, options) {
    var _this = this;
    var eventHandlers = this.getEventHandlers(eventName, options);
    ensureCanMutateNextEventHandlers(eventHandlers);
    if (eventHandlers.nextHandlers.length === 0) {
      eventHandlers.handleEvent = this.handleEvent.bind(this, eventName, options);
      this.target.addEventListener(eventName, eventHandlers.handleEvent, options);
    }
    eventHandlers.nextHandlers.push(listener);
    var isSubscribed = true;
    var unsubscribe = function() {
      function unsubscribe2() {
        if (!isSubscribed) {
          return;
        }
        isSubscribed = false;
        ensureCanMutateNextEventHandlers(eventHandlers);
        var index = eventHandlers.nextHandlers.indexOf(listener);
        eventHandlers.nextHandlers.splice(index, 1);
        if (eventHandlers.nextHandlers.length === 0) {
          if (_this.target) {
            _this.target.removeEventListener(eventName, eventHandlers.handleEvent, options);
          }
          eventHandlers.handleEvent = void 0;
        }
      }
      return unsubscribe2;
    }();
    return unsubscribe;
  }
  return add;
}();
var EVENT_HANDLERS_KEY = "__consolidated_events_handlers__";
function addEventListener(target, eventName, listener, options) {
  if (!target[EVENT_HANDLERS_KEY]) {
    target[EVENT_HANDLERS_KEY] = new TargetEventHandlers(target);
  }
  var normalizedEventOptions = normalizeEventOptions(options);
  return target[EVENT_HANDLERS_KEY].add(eventName, listener, normalizedEventOptions);
}

// ../../node_modules/react-waypoint/es/index.js
var import_prop_types = __toESM(require_prop_types());
var import_react = __toESM(require_react());
var import_react_is = __toESM(require_react_is());
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function parseOffsetAsPercentage(str) {
  if (str.slice(-1) === "%") {
    return parseFloat(str.slice(0, -1)) / 100;
  }
  return void 0;
}
function parseOffsetAsPixels(str) {
  if (!isNaN(parseFloat(str)) && isFinite(str)) {
    return parseFloat(str);
  }
  if (str.slice(-2) === "px") {
    return parseFloat(str.slice(0, -2));
  }
  return void 0;
}
function computeOffsetPixels(offset, contextHeight) {
  var pixelOffset = parseOffsetAsPixels(offset);
  if (typeof pixelOffset === "number") {
    return pixelOffset;
  }
  var percentOffset = parseOffsetAsPercentage(offset);
  if (typeof percentOffset === "number") {
    return percentOffset * contextHeight;
  }
  return void 0;
}
var ABOVE = "above";
var INSIDE = "inside";
var BELOW = "below";
var INVISIBLE = "invisible";
function debugLog() {
  if (true) {
    var _console;
    (_console = console).log.apply(_console, arguments);
  }
}
function isDOMElement(Component) {
  return typeof Component.type === "string";
}
var errorMessage = "<Waypoint> needs a DOM element to compute boundaries. The child you passed is neither a DOM element (e.g. <div>) nor does it use the innerRef prop.\n\nSee https://goo.gl/LrBNgw for more info.";
function ensureRefIsProvidedByChild(children, ref) {
  if (children && !isDOMElement(children) && !ref) {
    throw new Error(errorMessage);
  }
}
function getCurrentPosition(bounds) {
  if (bounds.viewportBottom - bounds.viewportTop === 0) {
    return INVISIBLE;
  }
  if (bounds.viewportTop <= bounds.waypointTop && bounds.waypointTop <= bounds.viewportBottom) {
    return INSIDE;
  }
  if (bounds.viewportTop <= bounds.waypointBottom && bounds.waypointBottom <= bounds.viewportBottom) {
    return INSIDE;
  }
  if (bounds.waypointTop <= bounds.viewportTop && bounds.viewportBottom <= bounds.waypointBottom) {
    return INSIDE;
  }
  if (bounds.viewportBottom < bounds.waypointTop) {
    return BELOW;
  }
  if (bounds.waypointTop < bounds.viewportTop) {
    return ABOVE;
  }
  return INVISIBLE;
}
var timeout;
var timeoutQueue = [];
function onNextTick(cb) {
  timeoutQueue.push(cb);
  if (!timeout) {
    timeout = setTimeout(function() {
      timeout = null;
      var item;
      while (item = timeoutQueue.shift()) {
        item();
      }
    }, 0);
  }
  var isSubscribed = true;
  return function unsubscribe() {
    if (!isSubscribed) {
      return;
    }
    isSubscribed = false;
    var index = timeoutQueue.indexOf(cb);
    if (index === -1) {
      return;
    }
    timeoutQueue.splice(index, 1);
    if (!timeoutQueue.length && timeout) {
      clearTimeout(timeout);
      timeout = null;
    }
  };
}
function resolveScrollableAncestorProp(scrollableAncestor) {
  if (scrollableAncestor === "window") {
    return global.window;
  }
  return scrollableAncestor;
}
var defaultProps = {
  debug: false,
  scrollableAncestor: void 0,
  children: void 0,
  topOffset: "0px",
  bottomOffset: "0px",
  horizontal: false,
  onEnter: function onEnter() {
  },
  onLeave: function onLeave() {
  },
  onPositionChange: function onPositionChange() {
  },
  fireOnRapidScroll: true
};
var Waypoint = function(_React$PureComponent) {
  _inherits(Waypoint2, _React$PureComponent);
  var _super = _createSuper(Waypoint2);
  function Waypoint2(props) {
    var _this;
    _classCallCheck(this, Waypoint2);
    _this = _super.call(this, props);
    _this.refElement = function(e) {
      _this._ref = e;
    };
    return _this;
  }
  _createClass(Waypoint2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;
      if (!Waypoint2.getWindow()) {
        return;
      }
      this.cancelOnNextTick = onNextTick(function() {
        _this2.cancelOnNextTick = null;
        var _this2$props = _this2.props, children = _this2$props.children, debug = _this2$props.debug;
        ensureRefIsProvidedByChild(children, _this2._ref);
        _this2._handleScroll = _this2._handleScroll.bind(_this2);
        _this2.scrollableAncestor = _this2._findScrollableAncestor();
        if (debug) {
          debugLog("scrollableAncestor", _this2.scrollableAncestor);
        }
        _this2.scrollEventListenerUnsubscribe = addEventListener(_this2.scrollableAncestor, "scroll", _this2._handleScroll, {
          passive: true
        });
        _this2.resizeEventListenerUnsubscribe = addEventListener(window, "resize", _this2._handleScroll, {
          passive: true
        });
        _this2._handleScroll(null);
      });
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      var _this3 = this;
      if (!Waypoint2.getWindow()) {
        return;
      }
      if (!this.scrollableAncestor) {
        return;
      }
      if (this.cancelOnNextTick) {
        return;
      }
      this.cancelOnNextTick = onNextTick(function() {
        _this3.cancelOnNextTick = null;
        _this3._handleScroll(null);
      });
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (!Waypoint2.getWindow()) {
        return;
      }
      if (this.scrollEventListenerUnsubscribe) {
        this.scrollEventListenerUnsubscribe();
      }
      if (this.resizeEventListenerUnsubscribe) {
        this.resizeEventListenerUnsubscribe();
      }
      if (this.cancelOnNextTick) {
        this.cancelOnNextTick();
      }
    }
    /**
     * Traverses up the DOM to find an ancestor container which has an overflow
     * style that allows for scrolling.
     *
     * @return {Object} the closest ancestor element with an overflow style that
     *   allows for scrolling. If none is found, the `window` object is returned
     *   as a fallback.
     */
  }, {
    key: "_findScrollableAncestor",
    value: function _findScrollableAncestor() {
      var _this$props = this.props, horizontal = _this$props.horizontal, scrollableAncestor = _this$props.scrollableAncestor;
      if (scrollableAncestor) {
        return resolveScrollableAncestorProp(scrollableAncestor);
      }
      var node = this._ref;
      while (node.parentNode) {
        node = node.parentNode;
        if (node === document.body) {
          return window;
        }
        var style = window.getComputedStyle(node);
        var overflowDirec = horizontal ? style.getPropertyValue("overflow-x") : style.getPropertyValue("overflow-y");
        var overflow = overflowDirec || style.getPropertyValue("overflow");
        if (overflow === "auto" || overflow === "scroll" || overflow === "overlay") {
          return node;
        }
      }
      return window;
    }
    /**
     * @param {Object} event the native scroll event coming from the scrollable
     *   ancestor, or resize event coming from the window. Will be undefined if
     *   called by a React lifecyle method
     */
  }, {
    key: "_handleScroll",
    value: function _handleScroll(event) {
      if (!this._ref) {
        return;
      }
      var bounds = this._getBounds();
      var currentPosition = getCurrentPosition(bounds);
      var previousPosition = this._previousPosition;
      var _this$props2 = this.props, debug = _this$props2.debug, onPositionChange2 = _this$props2.onPositionChange, onEnter2 = _this$props2.onEnter, onLeave2 = _this$props2.onLeave, fireOnRapidScroll = _this$props2.fireOnRapidScroll;
      if (debug) {
        debugLog("currentPosition", currentPosition);
        debugLog("previousPosition", previousPosition);
      }
      this._previousPosition = currentPosition;
      if (previousPosition === currentPosition) {
        return;
      }
      var callbackArg = {
        currentPosition,
        previousPosition,
        event,
        waypointTop: bounds.waypointTop,
        waypointBottom: bounds.waypointBottom,
        viewportTop: bounds.viewportTop,
        viewportBottom: bounds.viewportBottom
      };
      onPositionChange2.call(this, callbackArg);
      if (currentPosition === INSIDE) {
        onEnter2.call(this, callbackArg);
      } else if (previousPosition === INSIDE) {
        onLeave2.call(this, callbackArg);
      }
      var isRapidScrollDown = previousPosition === BELOW && currentPosition === ABOVE;
      var isRapidScrollUp = previousPosition === ABOVE && currentPosition === BELOW;
      if (fireOnRapidScroll && (isRapidScrollDown || isRapidScrollUp)) {
        onEnter2.call(this, {
          currentPosition: INSIDE,
          previousPosition,
          event,
          waypointTop: bounds.waypointTop,
          waypointBottom: bounds.waypointBottom,
          viewportTop: bounds.viewportTop,
          viewportBottom: bounds.viewportBottom
        });
        onLeave2.call(this, {
          currentPosition,
          previousPosition: INSIDE,
          event,
          waypointTop: bounds.waypointTop,
          waypointBottom: bounds.waypointBottom,
          viewportTop: bounds.viewportTop,
          viewportBottom: bounds.viewportBottom
        });
      }
    }
  }, {
    key: "_getBounds",
    value: function _getBounds() {
      var _this$props3 = this.props, horizontal = _this$props3.horizontal, debug = _this$props3.debug;
      var _this$_ref$getBoundin = this._ref.getBoundingClientRect(), left = _this$_ref$getBoundin.left, top = _this$_ref$getBoundin.top, right = _this$_ref$getBoundin.right, bottom = _this$_ref$getBoundin.bottom;
      var waypointTop = horizontal ? left : top;
      var waypointBottom = horizontal ? right : bottom;
      var contextHeight;
      var contextScrollTop;
      if (this.scrollableAncestor === window) {
        contextHeight = horizontal ? window.innerWidth : window.innerHeight;
        contextScrollTop = 0;
      } else {
        contextHeight = horizontal ? this.scrollableAncestor.offsetWidth : this.scrollableAncestor.offsetHeight;
        contextScrollTop = horizontal ? this.scrollableAncestor.getBoundingClientRect().left : this.scrollableAncestor.getBoundingClientRect().top;
      }
      if (debug) {
        debugLog("waypoint top", waypointTop);
        debugLog("waypoint bottom", waypointBottom);
        debugLog("scrollableAncestor height", contextHeight);
        debugLog("scrollableAncestor scrollTop", contextScrollTop);
      }
      var _this$props4 = this.props, bottomOffset = _this$props4.bottomOffset, topOffset = _this$props4.topOffset;
      var topOffsetPx = computeOffsetPixels(topOffset, contextHeight);
      var bottomOffsetPx = computeOffsetPixels(bottomOffset, contextHeight);
      var contextBottom = contextScrollTop + contextHeight;
      return {
        waypointTop,
        waypointBottom,
        viewportTop: contextScrollTop + topOffsetPx,
        viewportBottom: contextBottom - bottomOffsetPx
      };
    }
    /**
     * @return {Object}
     */
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;
      var children = this.props.children;
      if (!children) {
        return import_react.default.createElement("span", {
          ref: this.refElement,
          style: {
            fontSize: 0
          }
        });
      }
      if (isDOMElement(children) || (0, import_react_is.isForwardRef)(children)) {
        var ref = function ref2(node) {
          _this4.refElement(node);
          if (children.ref) {
            if (typeof children.ref === "function") {
              children.ref(node);
            } else {
              children.ref.current = node;
            }
          }
        };
        return import_react.default.cloneElement(children, {
          ref
        });
      }
      return import_react.default.cloneElement(children, {
        innerRef: this.refElement
      });
    }
  }]);
  return Waypoint2;
}(import_react.default.PureComponent);
if (true) {
  Waypoint.propTypes = {
    children: import_prop_types.default.element,
    debug: import_prop_types.default.bool,
    onEnter: import_prop_types.default.func,
    onLeave: import_prop_types.default.func,
    onPositionChange: import_prop_types.default.func,
    fireOnRapidScroll: import_prop_types.default.bool,
    // eslint-disable-next-line react/forbid-prop-types
    scrollableAncestor: import_prop_types.default.any,
    horizontal: import_prop_types.default.bool,
    // `topOffset` can either be a number, in which case its a distance from the
    // top of the container in pixels, or a string value. Valid string values are
    // of the form "20px", which is parsed as pixels, or "20%", which is parsed
    // as a percentage of the height of the containing element.
    // For instance, if you pass "-20%", and the containing element is 100px tall,
    // then the waypoint will be triggered when it has been scrolled 20px beyond
    // the top of the containing element.
    topOffset: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.number]),
    // `bottomOffset` is like `topOffset`, but for the bottom of the container.
    bottomOffset: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.number])
  };
}
Waypoint.above = ABOVE;
Waypoint.below = BELOW;
Waypoint.inside = INSIDE;
Waypoint.invisible = INVISIBLE;
Waypoint.getWindow = function() {
  if (typeof window !== "undefined") {
    return window;
  }
  return void 0;
};
Waypoint.defaultProps = defaultProps;
Waypoint.displayName = "Waypoint";
export {
  Waypoint
};
//# sourceMappingURL=react-waypoint.js.map
