{
  "version": 3,
  "sources": ["../../src/scheduler/Action.ts", "../../src/scheduler/AsyncAction.ts", "../../src/Scheduler.ts", "../../src/scheduler/AsyncScheduler.ts", "../../src/scheduler/async.ts", "../../src/operators/bufferTime.ts", "../../src/operator/bufferTime.ts", "../../src/add/operator/bufferTime.ts"],
  "sourcesContent": ["import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\n\n/**\n * A unit of work to be executed in a {@link Scheduler}. An action is typically\n * created from within a Scheduler and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nexport class Action<T> extends Subscription {\n  constructor(scheduler: Scheduler, work: (this: Action<T>, state?: T) => void) {\n    super();\n  }\n  /**\n   * Schedules this action on its parent Scheduler for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler.\n   * @return {void}\n   */\n  public schedule(state?: T, delay: number = 0): Subscription {\n    return this;\n  }\n}\n", "import { root } from '../util/root';\nimport { Action } from './Action';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class AsyncAction<T> extends Action<T> {\n\n  public id: any;\n  public state: T;\n  public delay: number;\n  protected pending: boolean = false;\n  protected work: (this: this, state?: T) => void;\n\n  constructor(protected scheduler: AsyncScheduler,\n              work: (this: AsyncAction<T>, state?: T) => void) {\n    super(scheduler, work);\n    this.work = work;\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n\n    if (this.closed) {\n      return this;\n     }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, id?: any, delay: number = 0): any {\n    return root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(scheduler: AsyncScheduler, id: any, delay: number = 0): any {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    return root.clearInterval(id) && undefined || undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n  public execute(state: T, delay: number): any {\n\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any = undefined;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  /** @deprecated internal use only */ _unsubscribe() {\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n    const actions = scheduler.actions;\n    const index = actions.indexOf(this);\n\n    this.work  = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n\n    this.delay = null;\n  }\n}\n", "import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\n\nexport interface IScheduler {\n  now(): number;\n  schedule<T>(work: (this: Action<T>, state?: T) => void, delay?: number, state?: T): Subscription;\n}\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an {@link Action}.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n */\nexport class Scheduler implements IScheduler {\n\n  public static now: () => number = Date.now ? Date.now : () => +new Date();\n\n  constructor(private SchedulerAction: typeof Action,\n              now: () => number = Scheduler.now) {\n    this.now = now;\n  }\n\n  /**\n   * A getter method that returns a number representing the current time\n   * (at the time this function was called) according to the scheduler's own\n   * internal clock.\n   * @return {number} A number that represents the current time. May or may not\n   * have a relation to wall-clock time. May or may not refer to a time unit\n   * (e.g. milliseconds).\n   */\n  public now: () => number;\n\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param {function(state: ?T): ?Subscription} work A function representing a\n   * task, or some unit of work to be executed by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler itself.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @return {Subscription} A subscription in order to be able to unsubscribe\n   * the scheduled work.\n   */\n  public schedule<T>(work: (this: Action<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    return new this.SchedulerAction<T>(this, work).schedule(state, delay);\n  }\n}\n", "import { Scheduler } from '../Scheduler';\nimport { AsyncAction } from './AsyncAction';\n\nexport class AsyncScheduler extends Scheduler {\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   */\n  public active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   */\n  public scheduled: any = undefined;\n\n  public flush(action: AsyncAction<any>): void {\n\n    const {actions} = this;\n\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this.active = true;\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift()); // exhaust the scheduler queue\n\n    this.active = false;\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n", "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asap} scheduler.\n *\n * @example <caption>Use async scheduler to delay task</caption>\n * const task = () => console.log('it works!');\n *\n * Rx.Scheduler.async.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n *\n *\n * @example <caption>Use async scheduler to repeat task in intervals</caption>\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * Rx.Scheduler.async.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n *\n * @static true\n * @name async\n * @owner Scheduler\n */\n\nexport const async = new AsyncScheduler(AsyncAction);\n", "import { IScheduler } from '../Scheduler';\nimport { Action } from '../scheduler/Action';\nimport { Operator } from '../Operator';\nimport { async } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { isScheduler } from '../util/isScheduler';\nimport { OperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function bufferTime<T>(bufferTimeSpan: number, scheduler?: IScheduler): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(bufferTimeSpan: number, bufferCreationInterval: number, scheduler?: IScheduler): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(bufferTimeSpan: number, bufferCreationInterval: number, maxBufferSize: number, scheduler?: IScheduler): OperatorFunction<T, T[]>;\n/* tslint:enable:max-line-length */\n\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * <img src=\"./img/bufferTime.png\" width=\"100%\">\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * @example <caption>Every second, emit an array of the recent click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(1000);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(2000, 5000);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferTime\n * @owner Observable\n */\nexport function bufferTime<T>(bufferTimeSpan: number): OperatorFunction<T, T[]> {\n  let length: number = arguments.length;\n\n  let scheduler: IScheduler = async;\n  if (isScheduler(arguments[arguments.length - 1])) {\n    scheduler = arguments[arguments.length - 1];\n    length--;\n  }\n\n  let bufferCreationInterval: number = null;\n  if (length >= 2) {\n    bufferCreationInterval = arguments[1];\n  }\n\n  let maxBufferSize: number = Number.POSITIVE_INFINITY;\n  if (length >= 3) {\n    maxBufferSize = arguments[2];\n  }\n\n  return function bufferTimeOperatorFunction(source: Observable<T>) {\n    return source.lift(new BufferTimeOperator<T>(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n  };\n}\n\nclass BufferTimeOperator<T> implements Operator<T, T[]> {\n  constructor(private bufferTimeSpan: number,\n              private bufferCreationInterval: number,\n              private maxBufferSize: number,\n              private scheduler: IScheduler) {\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): any {\n    return source.subscribe(new BufferTimeSubscriber(\n      subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler\n    ));\n  }\n}\n\nclass Context<T> {\n  buffer: T[] = [];\n  closeAction: Subscription;\n}\n\ntype CreationState<T> = {\n  bufferTimeSpan: number;\n  bufferCreationInterval: number,\n  subscriber: BufferTimeSubscriber<T>;\n  scheduler: IScheduler;\n};\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferTimeSubscriber<T> extends Subscriber<T> {\n  private contexts: Array<Context<T>> = [];\n  private timespanOnly: boolean;\n\n  constructor(destination: Subscriber<T[]>,\n              private bufferTimeSpan: number,\n              private bufferCreationInterval: number,\n              private maxBufferSize: number,\n              private scheduler: IScheduler) {\n    super(destination);\n    const context = this.openContext();\n    this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n    if (this.timespanOnly) {\n      const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\n      this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    } else {\n      const closeState = { subscriber: this, context };\n      const creationState: CreationState<T> = { bufferTimeSpan, bufferCreationInterval, subscriber: this, scheduler };\n      this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n      this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n    }\n  }\n\n  protected _next(value: T) {\n    const contexts = this.contexts;\n    const len = contexts.length;\n    let filledBufferContext: Context<T>;\n    for (let i = 0; i < len; i++) {\n      const context = contexts[i];\n      const buffer = context.buffer;\n      buffer.push(value);\n      if (buffer.length == this.maxBufferSize) {\n        filledBufferContext = context;\n      }\n    }\n\n    if (filledBufferContext) {\n      this.onBufferFull(filledBufferContext);\n    }\n  }\n\n  protected _error(err: any) {\n    this.contexts.length = 0;\n    super._error(err);\n  }\n\n  protected _complete() {\n    const { contexts, destination } = this;\n    while (contexts.length > 0) {\n      const context = contexts.shift();\n      destination.next(context.buffer);\n    }\n    super._complete();\n  }\n\n  /** @deprecated internal use only */ _unsubscribe() {\n    this.contexts = null;\n  }\n\n  protected onBufferFull(context: Context<T>) {\n    this.closeContext(context);\n    const closeAction = context.closeAction;\n    closeAction.unsubscribe();\n    this.remove(closeAction);\n\n    if (!this.closed && this.timespanOnly) {\n      context = this.openContext();\n      const bufferTimeSpan = this.bufferTimeSpan;\n      const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\n      this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    }\n  }\n\n  openContext(): Context<T> {\n    const context: Context<T> = new Context<T>();\n    this.contexts.push(context);\n    return context;\n  }\n\n  closeContext(context: Context<T>) {\n    this.destination.next(context.buffer);\n    const contexts = this.contexts;\n\n    const spliceIndex = contexts ? contexts.indexOf(context) : -1;\n    if (spliceIndex >= 0) {\n      contexts.splice(contexts.indexOf(context), 1);\n    }\n  }\n}\n\nfunction dispatchBufferTimeSpanOnly(this: Action<any>, state: any) {\n  const subscriber: BufferTimeSubscriber<any> = state.subscriber;\n\n  const prevContext = state.context;\n  if (prevContext) {\n    subscriber.closeContext(prevContext);\n  }\n\n  if (!subscriber.closed) {\n    state.context = subscriber.openContext();\n    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n  }\n}\n\ninterface DispatchArg<T> {\n  subscriber: BufferTimeSubscriber<T>;\n  context: Context<T>;\n}\n\nfunction dispatchBufferCreation<T>(this: Action<CreationState<T>>, state: CreationState<T>) {\n  const { bufferCreationInterval, bufferTimeSpan, subscriber, scheduler } = state;\n  const context = subscriber.openContext();\n  const action = <Action<CreationState<T>>>this;\n  if (!subscriber.closed) {\n    subscriber.add(context.closeAction = scheduler.schedule<DispatchArg<T>>(dispatchBufferClose, bufferTimeSpan, { subscriber, context }));\n    action.schedule(state, bufferCreationInterval);\n  }\n}\n\nfunction dispatchBufferClose<T>(arg: DispatchArg<T>) {\n  const { subscriber, context } = arg;\n  subscriber.closeContext(context);\n}\n", "import { IScheduler } from '../Scheduler';\nimport { async } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { isScheduler } from '../util/isScheduler';\nimport { bufferTime as higherOrder } from '../operators/bufferTime';\n\n/* tslint:disable:max-line-length */\nexport function bufferTime<T>(this: Observable<T>, bufferTimeSpan: number, scheduler?: IScheduler): Observable<T[]>;\nexport function bufferTime<T>(this: Observable<T>, bufferTimeSpan: number, bufferCreationInterval: number, scheduler?: IScheduler): Observable<T[]>;\nexport function bufferTime<T>(this: Observable<T>, bufferTimeSpan: number, bufferCreationInterval: number, maxBufferSize: number, scheduler?: IScheduler): Observable<T[]>;\n/* tslint:enable:max-line-length */\n\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * <img src=\"./img/bufferTime.png\" width=\"100%\">\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * @example <caption>Every second, emit an array of the recent click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(1000);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(2000, 5000);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferTime\n * @owner Observable\n */\nexport function bufferTime<T>(this: Observable<T>, bufferTimeSpan: number): Observable<T[]> {\n  let length: number = arguments.length;\n\n  let scheduler: IScheduler = async;\n  if (isScheduler(arguments[arguments.length - 1])) {\n    scheduler = arguments[arguments.length - 1];\n    length--;\n  }\n\n  let bufferCreationInterval: number = null;\n  if (length >= 2) {\n    bufferCreationInterval = arguments[1];\n  }\n\n  let maxBufferSize: number = Number.POSITIVE_INFINITY;\n  if (length >= 3) {\n    maxBufferSize = arguments[2];\n  }\n\n  return higherOrder(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler)(this) as Observable<T[]>;\n}\n", "\nimport { Observable } from '../../Observable';\nimport { bufferTime } from '../../operator/bufferTime';\n\nObservable.prototype.bufferTime = bufferTime;\n\ndeclare module '../../Observable' {\n  interface Observable<T> {\n    bufferTime: typeof bufferTime;\n  }\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;AACA,QAAA,iBAAA;AAgBA,QAAA,SAAA,SAAA,QAAA;AAA+B,gBAAAA,SAAA,MAAA;AAC7B,eAAAA,QAAY,WAAsB,MAA0C;AAC1E,eAAA,KAAA,IAAA;MACF;AAWO,MAAAA,QAAA,UAAA,WAAP,SAAgB,OAAW,OAAiB;AAAjB,YAAA,UAAA,QAAiB;AAAjB,kBAAA;QAAiB;AAC1C,eAAO;MACT;AACF,aAAAA;IAAA,EAjB+B,eAAA,YAAY;AAA9B,YAAA,SAAM;;;;;;;;;;;;;;;;;ACjBnB,QAAA,SAAA;AACA,QAAA,WAAA;AASA,QAAA,cAAA,SAAA,QAAA;AAAoC,gBAAAC,cAAA,MAAA;AAQlC,eAAAA,aAAsB,WACV,MAA+C;AACzD,eAAA,KAAA,MAAM,WAAW,IAAI;AAFD,aAAA,YAAA;AAHZ,aAAA,UAAmB;AAM3B,aAAK,OAAO;MACd;AAEO,MAAAA,aAAA,UAAA,WAAP,SAAgB,OAAW,OAAiB;AAAjB,YAAA,UAAA,QAAiB;AAAjB,kBAAA;QAAiB;AAE1C,YAAI,KAAK,QAAQ;AACf,iBAAO;QACR;AAGD,aAAK,QAAQ;AAIb,aAAK,UAAU;AAEf,YAAM,KAAK,KAAK;AAChB,YAAM,YAAY,KAAK;AAuBvB,YAAI,MAAM,MAAM;AACd,eAAK,KAAK,KAAK,eAAe,WAAW,IAAI,KAAK;QACpD;AAEA,aAAK,QAAQ;AAEb,aAAK,KAAK,KAAK,MAAM,KAAK,eAAe,WAAW,KAAK,IAAI,KAAK;AAElE,eAAO;MACT;AAEU,MAAAA,aAAA,UAAA,iBAAV,SAAyB,WAA2B,IAAU,OAAiB;AAAjB,YAAA,UAAA,QAAiB;AAAjB,kBAAA;QAAiB;AAC7E,eAAO,OAAA,KAAK,YAAY,UAAU,MAAM,KAAK,WAAW,IAAI,GAAG,KAAK;MACtE;AAEU,MAAAA,aAAA,UAAA,iBAAV,SAAyB,WAA2B,IAAS,OAAiB;AAAjB,YAAA,UAAA,QAAiB;AAAjB,kBAAA;QAAiB;AAE5E,YAAI,UAAU,QAAQ,KAAK,UAAU,SAAS,KAAK,YAAY,OAAO;AACpE,iBAAO;QACT;AAGA,eAAO,OAAA,KAAK,cAAc,EAAE,KAAK,UAAa;MAChD;AAMO,MAAAA,aAAA,UAAA,UAAP,SAAe,OAAU,OAAa;AAEpC,YAAI,KAAK,QAAQ;AACf,iBAAO,IAAI,MAAM,8BAA8B;QACjD;AAEA,aAAK,UAAU;AACf,YAAM,QAAQ,KAAK,SAAS,OAAO,KAAK;AACxC,YAAI,OAAO;AACT,iBAAO;QACT,WAAW,KAAK,YAAY,SAAS,KAAK,MAAM,MAAM;AAcpD,eAAK,KAAK,KAAK,eAAe,KAAK,WAAW,KAAK,IAAI,IAAI;QAC7D;MACF;AAEU,MAAAA,aAAA,UAAA,WAAV,SAAmB,OAAU,OAAa;AACxC,YAAI,UAAmB;AACvB,YAAI,aAAkB;AACtB,YAAI;AACF,eAAK,KAAK,KAAK;QACjB,SAAS,GAAP;AACA,oBAAU;AACV,uBAAa,CAAC,CAAC,KAAK,KAAK,IAAI,MAAM,CAAC;QACtC;AACA,YAAI,SAAS;AACX,eAAK,YAAW;AAChB,iBAAO;QACT;MACF;AAEqC,MAAAA,aAAA,UAAA,eAAA,WAAA;AAEnC,YAAM,KAAK,KAAK;AAChB,YAAM,YAAY,KAAK;AACvB,YAAM,UAAU,UAAU;AAC1B,YAAM,QAAQ,QAAQ,QAAQ,IAAI;AAElC,aAAK,OAAQ;AACb,aAAK,QAAQ;AACb,aAAK,UAAU;AACf,aAAK,YAAY;AAEjB,YAAI,UAAU,IAAI;AAChB,kBAAQ,OAAO,OAAO,CAAC;QACzB;AAEA,YAAI,MAAM,MAAM;AACd,eAAK,KAAK,KAAK,eAAe,WAAW,IAAI,IAAI;QACnD;AAEA,aAAK,QAAQ;MACf;AACF,aAAAA;IAAA,EAjJoC,SAAA,MAAM;AAA7B,YAAA,cAAW;;;;;;;;ACaxB,QAAA,YAAA,WAAA;AAIE,eAAAC,WAAoB,iBACR,KAAiC;AAAjC,YAAA,QAAA,QAAiC;AAAjC,gBAAoBA,WAAU;QAAG;AADzB,aAAA,kBAAA;AAElB,aAAK,MAAM;MACb;AA6BO,MAAAA,WAAA,UAAA,WAAP,SAAmB,MAA4C,OAAmB,OAAS;AAA5B,YAAA,UAAA,QAAiB;AAAjB,kBAAA;QAAiB;AAC9E,eAAO,IAAI,KAAK,gBAAmB,MAAM,IAAI,EAAE,SAAS,OAAO,KAAK;MACtE;AApCc,MAAAA,WAAA,MAAoB,KAAK,MAAM,KAAK,MAAM,WAAA;AAAM,eAAA,CAAC,oBAAI,KAAI;MAAT;AAqChE,aAAAA;IAAA,EAvCA;AAAa,YAAA,YAAS;;;;;;;;;;;;;;;;;ACvBtB,QAAA,cAAA;AAGA,QAAA,iBAAA,SAAA,QAAA;AAAoC,gBAAAC,iBAAA,MAAA;AAApC,eAAAA,kBAAA;AAAoC,eAAA,MAAA,MAAA,SAAA;AAC3B,aAAA,UAAmC,CAAA;AAMnC,aAAA,SAAkB;AAOlB,aAAA,YAAiB;MA6B1B;AA3BS,MAAAA,gBAAA,UAAA,QAAP,SAAa,QAAwB;AAE5B,YAAA,UAAA,KAAA;AAEP,YAAI,KAAK,QAAQ;AACf,kBAAQ,KAAK,MAAM;AACnB;QACF;AAEA,YAAI;AACJ,aAAK,SAAS;AAEd,WAAG;AACD,cAAI,QAAQ,OAAO,QAAQ,OAAO,OAAO,OAAO,KAAK,GAAG;AACtD;UACF;QACF,SAAS,SAAS,QAAQ,MAAK;AAE/B,aAAK,SAAS;AAEd,YAAI,OAAO;AACT,iBAAO,SAAS,QAAQ,MAAK,GAAI;AAC/B,mBAAO,YAAW;UACpB;AACA,gBAAM;QACR;MACF;AACF,aAAAA;IAAA,EA3CoC,YAAA,SAAS;AAAhC,YAAA,iBAAc;;;;;;;;ACH3B,QAAA,gBAAA;AACA,QAAA,mBAAA;AA6Ca,YAAA,QAAQ,IAAI,iBAAA,eAAe,cAAA,WAAW;;;;;;;;;;;;;;;;;AC3CnD,QAAA,UAAA;AAEA,QAAA,eAAA;AAEA,QAAA,gBAAA;AAoDA,aAAA,WAA8B,gBAAsB;AAClD,UAAI,SAAiB,UAAU;AAE/B,UAAI,YAAwB,QAAA;AAC5B,UAAI,cAAA,YAAY,UAAU,UAAU,SAAS,CAAC,CAAC,GAAG;AAChD,oBAAY,UAAU,UAAU,SAAS,CAAC;AAC1C;MACF;AAEA,UAAI,yBAAiC;AACrC,UAAI,UAAU,GAAG;AACf,iCAAyB,UAAU,CAAC;MACtC;AAEA,UAAI,gBAAwB,OAAO;AACnC,UAAI,UAAU,GAAG;AACf,wBAAgB,UAAU,CAAC;MAC7B;AAEA,aAAO,SAAA,2BAAoC,QAAqB;AAC9D,eAAO,OAAO,KAAK,IAAI,mBAAsB,gBAAgB,wBAAwB,eAAe,SAAS,CAAC;MAChH;IACF;AAtBgB,YAAA,aAAU;AAwB1B,QAAA,qBAAA,WAAA;AACE,eAAAC,oBAAoB,gBACA,wBACA,eACA,WAAqB;AAHrB,aAAA,iBAAA;AACA,aAAA,yBAAA;AACA,aAAA,gBAAA;AACA,aAAA,YAAA;MACpB;AAEA,MAAAA,oBAAA,UAAA,OAAA,SAAK,YAA6B,QAAW;AAC3C,eAAO,OAAO,UAAU,IAAI,qBAC1B,YAAY,KAAK,gBAAgB,KAAK,wBAAwB,KAAK,eAAe,KAAK,SAAS,CACjG;MACH;AACF,aAAAA;IAAA,EAZA;AAcA,QAAA,UAAA,WAAA;AAAA,eAAAC,WAAA;AACE,aAAA,SAAc,CAAA;MAEhB;AAAA,aAAAA;IAAA,EAHA;AAiBA,QAAA,uBAAA,SAAA,QAAA;AAAsC,gBAAAC,uBAAA,MAAA;AAIpC,eAAAA,sBAAY,aACQ,gBACA,wBACA,eACA,WAAqB;AACvC,eAAA,KAAA,MAAM,WAAW;AAJC,aAAA,iBAAA;AACA,aAAA,yBAAA;AACA,aAAA,gBAAA;AACA,aAAA,YAAA;AAPZ,aAAA,WAA8B,CAAA;AASpC,YAAM,UAAU,KAAK,YAAW;AAChC,aAAK,eAAe,0BAA0B,QAAQ,yBAAyB;AAC/E,YAAI,KAAK,cAAc;AACrB,cAAM,oBAAoB,EAAE,YAAY,MAAM,SAAS,eAAc;AACrE,eAAK,IAAI,QAAQ,cAAc,UAAU,SAAS,4BAA4B,gBAAgB,iBAAiB,CAAC;QAClH,OAAO;AACL,cAAM,aAAa,EAAE,YAAY,MAAM,QAAO;AAC9C,cAAM,gBAAkC,EAAE,gBAAgB,wBAAwB,YAAY,MAAM,UAAS;AAC7G,eAAK,IAAI,QAAQ,cAAc,UAAU,SAAS,qBAAqB,gBAAgB,UAAU,CAAC;AAClG,eAAK,IAAI,UAAU,SAAS,wBAAwB,wBAAwB,aAAa,CAAC;QAC5F;MACF;AAEU,MAAAA,sBAAA,UAAA,QAAV,SAAgB,OAAQ;AACtB,YAAM,WAAW,KAAK;AACtB,YAAM,MAAM,SAAS;AACrB,YAAI;AACJ,iBAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,cAAM,UAAU,SAAS,CAAC;AAC1B,cAAM,SAAS,QAAQ;AACvB,iBAAO,KAAK,KAAK;AACjB,cAAI,OAAO,UAAU,KAAK,eAAe;AACvC,kCAAsB;UACxB;QACF;AAEA,YAAI,qBAAqB;AACvB,eAAK,aAAa,mBAAmB;QACvC;MACF;AAEU,MAAAA,sBAAA,UAAA,SAAV,SAAiB,KAAQ;AACvB,aAAK,SAAS,SAAS;AACvB,eAAA,UAAM,OAAM,KAAA,MAAC,GAAG;MAClB;AAEU,MAAAA,sBAAA,UAAA,YAAV,WAAA;AACE,YAAA,KAAA,MAAQ,WAAA,GAAA,UAAU,cAAA,GAAA;AAClB,eAAO,SAAS,SAAS,GAAG;AAC1B,cAAM,UAAU,SAAS,MAAK;AAC9B,sBAAY,KAAK,QAAQ,MAAM;QACjC;AACA,eAAA,UAAM,UAAS,KAAA,IAAA;MACjB;AAEqC,MAAAA,sBAAA,UAAA,eAAA,WAAA;AACnC,aAAK,WAAW;MAClB;AAEU,MAAAA,sBAAA,UAAA,eAAV,SAAuB,SAAmB;AACxC,aAAK,aAAa,OAAO;AACzB,YAAM,cAAc,QAAQ;AAC5B,oBAAY,YAAW;AACvB,aAAK,OAAO,WAAW;AAEvB,YAAI,CAAC,KAAK,UAAU,KAAK,cAAc;AACrC,oBAAU,KAAK,YAAW;AAC1B,cAAM,iBAAiB,KAAK;AAC5B,cAAM,oBAAoB,EAAE,YAAY,MAAM,SAAS,eAAc;AACrE,eAAK,IAAI,QAAQ,cAAc,KAAK,UAAU,SAAS,4BAA4B,gBAAgB,iBAAiB,CAAC;QACvH;MACF;AAEA,MAAAA,sBAAA,UAAA,cAAA,WAAA;AACE,YAAM,UAAsB,IAAI,QAAO;AACvC,aAAK,SAAS,KAAK,OAAO;AAC1B,eAAO;MACT;AAEA,MAAAA,sBAAA,UAAA,eAAA,SAAa,SAAmB;AAC9B,aAAK,YAAY,KAAK,QAAQ,MAAM;AACpC,YAAM,WAAW,KAAK;AAEtB,YAAM,cAAc,WAAW,SAAS,QAAQ,OAAO,IAAI;AAC3D,YAAI,eAAe,GAAG;AACpB,mBAAS,OAAO,SAAS,QAAQ,OAAO,GAAG,CAAC;QAC9C;MACF;AACF,aAAAA;IAAA,EAxFsC,aAAA,UAAU;AA0FhD,aAAA,2BAAuD,OAAU;AAC/D,UAAM,aAAwC,MAAM;AAEpD,UAAM,cAAc,MAAM;AAC1B,UAAI,aAAa;AACf,mBAAW,aAAa,WAAW;MACrC;AAEA,UAAI,CAAC,WAAW,QAAQ;AACtB,cAAM,UAAU,WAAW,YAAW;AACtC,cAAM,QAAQ,cAAc,KAAK,SAAS,OAAO,MAAM,cAAc;MACvE;IACF;AAOA,aAAA,uBAAmE,OAAuB;AAChF,UAAA,yBAAA,MAAA,wBAAwB,iBAAA,MAAA,gBAAgB,aAAA,MAAA,YAAY,YAAA,MAAA;AAC5D,UAAM,UAAU,WAAW,YAAW;AACtC,UAAM,SAAmC;AACzC,UAAI,CAAC,WAAW,QAAQ;AACtB,mBAAW,IAAI,QAAQ,cAAc,UAAU,SAAyB,qBAAqB,gBAAgB,EAAE,YAAY,QAAO,CAAE,CAAC;AACrI,eAAO,SAAS,OAAO,sBAAsB;MAC/C;IACF;AAEA,aAAA,oBAAgC,KAAmB;AACzC,UAAA,aAAA,IAAA,YAAY,UAAA,IAAA;AACpB,iBAAW,aAAa,OAAO;IACjC;;;;;;;;AC3OA,QAAA,UAAA;AAEA,QAAA,gBAAA;AACA,QAAAC,gBAAA;AAmDA,aAAA,WAAmD,gBAAsB;AACvE,UAAI,SAAiB,UAAU;AAE/B,UAAI,YAAwB,QAAA;AAC5B,UAAI,cAAA,YAAY,UAAU,UAAU,SAAS,CAAC,CAAC,GAAG;AAChD,oBAAY,UAAU,UAAU,SAAS,CAAC;AAC1C;MACF;AAEA,UAAI,yBAAiC;AACrC,UAAI,UAAU,GAAG;AACf,iCAAyB,UAAU,CAAC;MACtC;AAEA,UAAI,gBAAwB,OAAO;AACnC,UAAI,UAAU,GAAG;AACf,wBAAgB,UAAU,CAAC;MAC7B;AAEA,aAAOA,cAAA,WAAY,gBAAgB,wBAAwB,eAAe,SAAS,EAAE,IAAI;IAC3F;AApBgB,YAAA,aAAU;;;;;ACtD1B,IAAA,eAAA;AACA,IAAA,eAAA;AAEA,aAAA,WAAW,UAAU,aAAa,aAAA;",
  "names": ["Action", "AsyncAction", "Scheduler", "AsyncScheduler", "BufferTimeOperator", "Context", "BufferTimeSubscriber", "bufferTime_1"]
}
