import {
  useMediaQuery
} from "./chunk-DJSTIE5Z.js";
import {
  useTheme
} from "./chunk-T3YJ7BEG.js";
import {
  init_useEnhancedEffect,
  useEnhancedEffect_default
} from "./chunk-AL4WBPVD.js";
import {
  capitalize_default,
  init_capitalize
} from "./chunk-DK7RNG5L.js";
import {
  init_base
} from "./chunk-ISZQ7FVM.js";
import {
  init_generateUtilityClass,
  init_styled,
  styled_default
} from "./chunk-VH7WLPLV.js";
import {
  getThemeProps,
  init_esm as init_esm2
} from "./chunk-GBMADWHN.js";
import {
  _objectWithoutPropertiesLoose,
  init_objectWithoutPropertiesLoose
} from "./chunk-GYB27DV7.js";
import {
  clsx_m_default,
  init_clsx_m
} from "./chunk-GXTM5FPK.js";
import {
  composeClasses,
  exactProp,
  generateUtilityClass,
  generateUtilityClasses,
  getDisplayName,
  init_esm
} from "./chunk-YUTZFTRZ.js";
import {
  require_jsx_runtime
} from "./chunk-PMEGQKNZ.js";
import {
  _extends,
  init_extends
} from "./chunk-S5Y2Q5O2.js";
import {
  require_prop_types
} from "./chunk-PLEWTTGR.js";
import {
  require_react
} from "./chunk-CPU6GBAM.js";
import {
  __toESM
} from "./chunk-LFBQMW2U.js";

// ../../node_modules/@mui/material/Hidden/Hidden.js
init_extends();
init_objectWithoutPropertiesLoose();
var React4 = __toESM(require_react());
var import_prop_types4 = __toESM(require_prop_types());

// ../../node_modules/@mui/material/Hidden/HiddenJs.js
var React2 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());
init_esm();

// ../../node_modules/@mui/material/Hidden/withWidth.js
init_extends();
init_objectWithoutPropertiesLoose();
var React = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
init_esm();
init_esm2();
init_useEnhancedEffect();
var import_jsx_runtime = __toESM(require_jsx_runtime());
var _excluded = ["initialWidth", "width"];
var breakpointKeys = ["xs", "sm", "md", "lg", "xl"];
var isWidthUp = (breakpoint, width, inclusive = true) => {
  if (inclusive) {
    return breakpointKeys.indexOf(breakpoint) <= breakpointKeys.indexOf(width);
  }
  return breakpointKeys.indexOf(breakpoint) < breakpointKeys.indexOf(width);
};
var isWidthDown = (breakpoint, width, inclusive = false) => {
  if (inclusive) {
    return breakpointKeys.indexOf(width) <= breakpointKeys.indexOf(breakpoint);
  }
  return breakpointKeys.indexOf(width) < breakpointKeys.indexOf(breakpoint);
};
var withWidth = (options = {}) => (Component) => {
  const {
    withTheme: withThemeOption = false,
    noSSR = false,
    initialWidth: initialWidthOption
  } = options;
  function WithWidth(props) {
    const contextTheme = useTheme();
    const theme = props.theme || contextTheme;
    const _getThemeProps = getThemeProps({
      theme,
      name: "MuiWithWidth",
      props
    }), {
      initialWidth,
      width
    } = _getThemeProps, other = _objectWithoutPropertiesLoose(_getThemeProps, _excluded);
    const [mountedState, setMountedState] = React.useState(false);
    useEnhancedEffect_default(() => {
      setMountedState(true);
    }, []);
    const keys = theme.breakpoints.keys.slice().reverse();
    const widthComputed = keys.reduce((output, key) => {
      const matches = useMediaQuery(theme.breakpoints.up(key));
      return !output && matches ? key : output;
    }, null);
    const more = _extends({
      width: width || (mountedState || noSSR ? widthComputed : void 0) || initialWidth || initialWidthOption
    }, withThemeOption ? {
      theme
    } : {}, other);
    if (more.width === void 0) {
      return null;
    }
    return (0, import_jsx_runtime.jsx)(Component, _extends({}, more));
  }
  true ? WithWidth.propTypes = {
    /**
     * As `window.innerWidth` is unavailable on the server,
     * we default to rendering an empty component during the first mount.
     * You might want to use a heuristic to approximate
     * the screen width of the client browser screen width.
     *
     * For instance, you could be using the user-agent or the client-hints.
     * https://caniuse.com/#search=client%20hint
     */
    initialWidth: import_prop_types.default.oneOf(["xs", "sm", "md", "lg", "xl"]),
    /**
     * @ignore
     */
    theme: import_prop_types.default.object,
    /**
     * Bypass the width calculation logic.
     */
    width: import_prop_types.default.oneOf(["xs", "sm", "md", "lg", "xl"])
  } : void 0;
  if (true) {
    WithWidth.displayName = `WithWidth(${getDisplayName(Component)})`;
  }
  return WithWidth;
};
var withWidth_default = withWidth;

// ../../node_modules/@mui/material/Hidden/HiddenJs.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
function HiddenJs(props) {
  const {
    children,
    only,
    width
  } = props;
  const theme = useTheme();
  let visible = true;
  if (only) {
    if (Array.isArray(only)) {
      for (let i = 0; i < only.length; i += 1) {
        const breakpoint = only[i];
        if (width === breakpoint) {
          visible = false;
          break;
        }
      }
    } else if (only && width === only) {
      visible = false;
    }
  }
  if (visible) {
    for (let i = 0; i < theme.breakpoints.keys.length; i += 1) {
      const breakpoint = theme.breakpoints.keys[i];
      const breakpointUp = props[`${breakpoint}Up`];
      const breakpointDown = props[`${breakpoint}Down`];
      if (breakpointUp && isWidthUp(breakpoint, width) || breakpointDown && isWidthDown(breakpoint, width)) {
        visible = false;
        break;
      }
    }
  }
  if (!visible) {
    return null;
  }
  return (0, import_jsx_runtime2.jsx)(React2.Fragment, {
    children
  });
}
true ? HiddenJs.propTypes = {
  /**
   * The content of the component.
   */
  children: import_prop_types2.default.node,
  /**
   * If `true`, screens this size and down are hidden.
   */
  // eslint-disable-next-line react/no-unused-prop-types
  lgDown: import_prop_types2.default.bool,
  /**
   * If `true`, screens this size and up are hidden.
   */
  // eslint-disable-next-line react/no-unused-prop-types
  lgUp: import_prop_types2.default.bool,
  /**
   * If `true`, screens this size and down are hidden.
   */
  // eslint-disable-next-line react/no-unused-prop-types
  mdDown: import_prop_types2.default.bool,
  /**
   * If `true`, screens this size and up are hidden.
   */
  // eslint-disable-next-line react/no-unused-prop-types
  mdUp: import_prop_types2.default.bool,
  /**
   * Hide the given breakpoint(s).
   */
  only: import_prop_types2.default.oneOfType([import_prop_types2.default.oneOf(["xs", "sm", "md", "lg", "xl"]), import_prop_types2.default.arrayOf(import_prop_types2.default.oneOf(["xs", "sm", "md", "lg", "xl"]))]),
  /**
   * If `true`, screens this size and down are hidden.
   */
  // eslint-disable-next-line react/no-unused-prop-types
  smDown: import_prop_types2.default.bool,
  /**
   * If `true`, screens this size and up are hidden.
   */
  // eslint-disable-next-line react/no-unused-prop-types
  smUp: import_prop_types2.default.bool,
  /**
   * @ignore
   * width prop provided by withWidth decorator.
   */
  width: import_prop_types2.default.string.isRequired,
  /**
   * If `true`, screens this size and down are hidden.
   */
  // eslint-disable-next-line react/no-unused-prop-types
  xlDown: import_prop_types2.default.bool,
  /**
   * If `true`, screens this size and up are hidden.
   */
  // eslint-disable-next-line react/no-unused-prop-types
  xlUp: import_prop_types2.default.bool,
  /**
   * If `true`, screens this size and down are hidden.
   */
  // eslint-disable-next-line react/no-unused-prop-types
  xsDown: import_prop_types2.default.bool,
  /**
   * If `true`, screens this size and up are hidden.
   */
  // eslint-disable-next-line react/no-unused-prop-types
  xsUp: import_prop_types2.default.bool
} : void 0;
if (true) {
  true ? HiddenJs.propTypes = exactProp(HiddenJs.propTypes) : void 0;
}
var HiddenJs_default = withWidth_default()(HiddenJs);

// ../../node_modules/@mui/material/Hidden/HiddenCss.js
init_objectWithoutPropertiesLoose();
init_extends();
var React3 = __toESM(require_react());
init_clsx_m();
var import_prop_types3 = __toESM(require_prop_types());
init_base();
init_capitalize();
init_styled();

// ../../node_modules/@mui/material/Hidden/hiddenCssClasses.js
init_esm();
init_generateUtilityClass();
function getHiddenCssUtilityClass(slot) {
  return generateUtilityClass("PrivateHiddenCss", slot);
}
var hiddenCssClasses = generateUtilityClasses("PrivateHiddenCss", ["root", "xlDown", "xlUp", "onlyXl", "lgDown", "lgUp", "onlyLg", "mdDown", "mdUp", "onlyMd", "smDown", "smUp", "onlySm", "xsDown", "xsUp", "onlyXs"]);

// ../../node_modules/@mui/material/Hidden/HiddenCss.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var _excluded2 = ["children", "className", "only"];
var useUtilityClasses = (ownerState) => {
  const {
    classes,
    breakpoints
  } = ownerState;
  const slots = {
    root: ["root", ...breakpoints.map(({
      breakpoint,
      dir
    }) => {
      return dir === "only" ? `${dir}${capitalize_default(breakpoint)}` : `${breakpoint}${capitalize_default(dir)}`;
    })]
  };
  return composeClasses(slots, getHiddenCssUtilityClass, classes);
};
var HiddenCssRoot = styled_default("div", {
  name: "PrivateHiddenCss",
  slot: "Root"
})(({
  theme,
  ownerState
}) => {
  const hidden = {
    display: "none"
  };
  return _extends({}, ownerState.breakpoints.map(({
    breakpoint,
    dir
  }) => {
    if (dir === "only") {
      return {
        [theme.breakpoints.only(breakpoint)]: hidden
      };
    }
    return dir === "up" ? {
      [theme.breakpoints.up(breakpoint)]: hidden
    } : {
      [theme.breakpoints.down(breakpoint)]: hidden
    };
  }).reduce((r, o) => {
    Object.keys(o).forEach((k) => {
      r[k] = o[k];
    });
    return r;
  }, {}));
});
function HiddenCss(props) {
  const {
    children,
    className,
    only
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded2);
  const theme = useTheme();
  if (true) {
    const unknownProps = Object.keys(other).filter((propName) => {
      const isUndeclaredBreakpoint = !theme.breakpoints.keys.some((breakpoint) => {
        return `${breakpoint}Up` === propName || `${breakpoint}Down` === propName;
      });
      return !["classes", "theme", "isRtl", "sx"].includes(propName) && isUndeclaredBreakpoint;
    });
    if (unknownProps.length > 0) {
      console.error(`MUI: Unsupported props received by \`<Hidden implementation="css" />\`: ${unknownProps.join(", ")}. Did you forget to wrap this component in a ThemeProvider declaring these breakpoints?`);
    }
  }
  const breakpoints = [];
  for (let i = 0; i < theme.breakpoints.keys.length; i += 1) {
    const breakpoint = theme.breakpoints.keys[i];
    const breakpointUp = other[`${breakpoint}Up`];
    const breakpointDown = other[`${breakpoint}Down`];
    if (breakpointUp) {
      breakpoints.push({
        breakpoint,
        dir: "up"
      });
    }
    if (breakpointDown) {
      breakpoints.push({
        breakpoint,
        dir: "down"
      });
    }
  }
  if (only) {
    const onlyBreakpoints = Array.isArray(only) ? only : [only];
    onlyBreakpoints.forEach((breakpoint) => {
      breakpoints.push({
        breakpoint,
        dir: "only"
      });
    });
  }
  const ownerState = _extends({}, props, {
    breakpoints
  });
  const classes = useUtilityClasses(ownerState);
  return (0, import_jsx_runtime3.jsx)(HiddenCssRoot, {
    className: clsx_m_default(classes.root, className),
    ownerState,
    children
  });
}
true ? HiddenCss.propTypes = {
  /**
   * The content of the component.
   */
  children: import_prop_types3.default.node,
  /**
   * @ignore
   */
  className: import_prop_types3.default.string,
  /**
   * Specify which implementation to use.  'js' is the default, 'css' works better for
   * server-side rendering.
   */
  implementation: import_prop_types3.default.oneOf(["js", "css"]),
  /**
   * If `true`, screens this size and down are hidden.
   */
  lgDown: import_prop_types3.default.bool,
  /**
   * If `true`, screens this size and up are hidden.
   */
  lgUp: import_prop_types3.default.bool,
  /**
   * If `true`, screens this size and down are hidden.
   */
  mdDown: import_prop_types3.default.bool,
  /**
   * If `true`, screens this size and up are hidden.
   */
  mdUp: import_prop_types3.default.bool,
  /**
   * Hide the given breakpoint(s).
   */
  only: import_prop_types3.default.oneOfType([import_prop_types3.default.oneOf(["xs", "sm", "md", "lg", "xl"]), import_prop_types3.default.arrayOf(import_prop_types3.default.oneOf(["xs", "sm", "md", "lg", "xl"]))]),
  /**
   * If `true`, screens this size and down are hidden.
   */
  smDown: import_prop_types3.default.bool,
  /**
   * If `true`, screens this size and up are hidden.
   */
  smUp: import_prop_types3.default.bool,
  /**
   * If `true`, screens this size and down are hidden.
   */
  xlDown: import_prop_types3.default.bool,
  /**
   * If `true`, screens this size and up are hidden.
   */
  xlUp: import_prop_types3.default.bool,
  /**
   * If `true`, screens this size and down are hidden.
   */
  xsDown: import_prop_types3.default.bool,
  /**
   * If `true`, screens this size and up are hidden.
   */
  xsUp: import_prop_types3.default.bool
} : void 0;
var HiddenCss_default = HiddenCss;

// ../../node_modules/@mui/material/Hidden/Hidden.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var _excluded3 = ["implementation", "lgDown", "lgUp", "mdDown", "mdUp", "smDown", "smUp", "xlDown", "xlUp", "xsDown", "xsUp"];
function Hidden(props) {
  const {
    implementation = "js",
    lgDown = false,
    lgUp = false,
    mdDown = false,
    mdUp = false,
    smDown = false,
    smUp = false,
    xlDown = false,
    xlUp = false,
    xsDown = false,
    xsUp = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded3);
  if (implementation === "js") {
    return (0, import_jsx_runtime4.jsx)(HiddenJs_default, _extends({
      lgDown,
      lgUp,
      mdDown,
      mdUp,
      smDown,
      smUp,
      xlDown,
      xlUp,
      xsDown,
      xsUp
    }, other));
  }
  return (0, import_jsx_runtime4.jsx)(HiddenCss_default, _extends({
    lgDown,
    lgUp,
    mdDown,
    mdUp,
    smDown,
    smUp,
    xlDown,
    xlUp,
    xsDown,
    xsUp
  }, other));
}
true ? Hidden.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: import_prop_types4.default.node,
  /**
   * Specify which implementation to use.  'js' is the default, 'css' works better for
   * server-side rendering.
   * @default 'js'
   */
  implementation: import_prop_types4.default.oneOf(["css", "js"]),
  /**
   * You can use this prop when choosing the `js` implementation with server-side rendering.
   *
   * As `window.innerWidth` is unavailable on the server,
   * we default to rendering an empty component during the first mount.
   * You might want to use a heuristic to approximate
   * the screen width of the client browser screen width.
   *
   * For instance, you could be using the user-agent or the client-hints.
   * https://caniuse.com/#search=client%20hint
   */
  initialWidth: import_prop_types4.default.oneOf(["xs", "sm", "md", "lg", "xl"]),
  /**
   * If `true`, screens this size and down are hidden.
   * @default false
   */
  lgDown: import_prop_types4.default.bool,
  /**
   * If `true`, screens this size and up are hidden.
   * @default false
   */
  lgUp: import_prop_types4.default.bool,
  /**
   * If `true`, screens this size and down are hidden.
   * @default false
   */
  mdDown: import_prop_types4.default.bool,
  /**
   * If `true`, screens this size and up are hidden.
   * @default false
   */
  mdUp: import_prop_types4.default.bool,
  /**
   * Hide the given breakpoint(s).
   */
  only: import_prop_types4.default.oneOfType([import_prop_types4.default.oneOf(["xs", "sm", "md", "lg", "xl"]), import_prop_types4.default.arrayOf(import_prop_types4.default.oneOf(["xs", "sm", "md", "lg", "xl"]).isRequired)]),
  /**
   * If `true`, screens this size and down are hidden.
   * @default false
   */
  smDown: import_prop_types4.default.bool,
  /**
   * If `true`, screens this size and up are hidden.
   * @default false
   */
  smUp: import_prop_types4.default.bool,
  /**
   * If `true`, screens this size and down are hidden.
   * @default false
   */
  xlDown: import_prop_types4.default.bool,
  /**
   * If `true`, screens this size and up are hidden.
   * @default false
   */
  xlUp: import_prop_types4.default.bool,
  /**
   * If `true`, screens this size and down are hidden.
   * @default false
   */
  xsDown: import_prop_types4.default.bool,
  /**
   * If `true`, screens this size and up are hidden.
   * @default false
   */
  xsUp: import_prop_types4.default.bool
} : void 0;
var Hidden_default = Hidden;

export {
  Hidden_default
};
//# sourceMappingURL=chunk-3G7AIOLG.js.map
