{
  "version": 3,
  "sources": ["../../src/observable/ScalarObservable.ts", "../../src/observable/EmptyObservable.ts", "../../src/observable/ArrayObservable.ts", "../../src/util/isArrayLike.ts", "../../src/util/isPromise.ts", "../../src/symbol/iterator.ts", "../../src/InnerSubscriber.ts", "../../src/util/subscribeToResult.ts", "../../src/OuterSubscriber.ts", "../../src/operators/mergeMap.ts", "../../src/util/identity.ts", "../../src/operators/mergeAll.ts", "../../src/observable/merge.ts", "../../src/operators/merge.ts", "../../src/operator/merge.ts", "../../src/add/operator/merge.ts"],
  "sourcesContent": ["import { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class ScalarObservable<T> extends Observable<T> {\n  static create<T>(value: T, scheduler?: IScheduler): ScalarObservable<T> {\n    return new ScalarObservable(value, scheduler);\n  }\n\n  static dispatch(state: any): void {\n    const { done, value, subscriber } = state;\n\n    if (done) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(value);\n    if (subscriber.closed) {\n      return;\n    }\n\n    state.done = true;\n    (<any> this).schedule(state);\n  }\n\n  _isScalar: boolean = true;\n\n  constructor(public value: T, private scheduler?: IScheduler) {\n    super();\n    if (scheduler) {\n      this._isScalar = false;\n    }\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    const value = this.value;\n    const scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(ScalarObservable.dispatch, 0, {\n        done: false, value, subscriber\n      });\n    } else {\n      subscriber.next(value);\n      if (!subscriber.closed) {\n        subscriber.complete();\n      }\n    }\n  }\n}\n", "import { IScheduler } from '../Scheduler';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\n\nexport interface DispatchArg<T> {\n  subscriber: Subscriber<T>;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class EmptyObservable<T> extends Observable<T> {\n\n  /**\n   * Creates an Observable that emits no items to the Observer and immediately\n   * emits a complete notification.\n   *\n   * <span class=\"informal\">Just emits 'complete', and nothing else.\n   * </span>\n   *\n   * <img src=\"./img/empty.png\" width=\"100%\">\n   *\n   * This static operator is useful for creating a simple Observable that only\n   * emits the complete notification. It can be used for composing with other\n   * Observables, such as in a {@link mergeMap}.\n   *\n   * @example <caption>Emit the number 7, then complete.</caption>\n   * var result = Rx.Observable.empty().startWith(7);\n   * result.subscribe(x => console.log(x));\n   *\n   * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\n   * var interval = Rx.Observable.interval(1000);\n   * var result = interval.mergeMap(x =>\n   *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\n   * );\n   * result.subscribe(x => console.log(x));\n   *\n   * // Results in the following to the console:\n   * // x is equal to the count on the interval eg(0,1,2,3,...)\n   * // x will occur every 1000ms\n   * // if x % 2 is equal to 1 print abc\n   * // if x % 2 is not equal to 1 nothing will be output\n   *\n   * @see {@link create}\n   * @see {@link never}\n   * @see {@link of}\n   * @see {@link throw}\n   *\n   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n   * the emission of the complete notification.\n   * @return {Observable} An \"empty\" Observable: emits only the complete\n   * notification.\n   * @static true\n   * @name empty\n   * @owner Observable\n   */\n  static create<T>(scheduler?: IScheduler): Observable<T> {\n    return new EmptyObservable<T>(scheduler);\n  }\n\n  static dispatch<T>(arg: DispatchArg<T>) {\n    const { subscriber } = arg;\n    subscriber.complete();\n  }\n\n  constructor(private scheduler?: IScheduler) {\n    super();\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n\n    const scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber });\n    } else {\n      subscriber.complete();\n    }\n  }\n}\n", "import { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { ScalarObservable } from './ScalarObservable';\nimport { EmptyObservable } from './EmptyObservable';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class ArrayObservable<T> extends Observable<T> {\n\n  static create<T>(array: T[], scheduler?: IScheduler): Observable<T> {\n    return new ArrayObservable(array, scheduler);\n  }\n\n  static of<T>(item1: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, item4: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, item4: T, item5: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, item4: T, item5: T, item6: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(...array: Array<T | IScheduler>): Observable<T>;\n  /**\n   * Creates an Observable that emits some values you specify as arguments,\n   * immediately one after the other, and then emits a complete notification.\n   *\n   * <span class=\"informal\">Emits the arguments you provide, then completes.\n   * </span>\n   *\n   * <img src=\"./img/of.png\" width=\"100%\">\n   *\n   * This static operator is useful for creating a simple Observable that only\n   * emits the arguments given, and the complete notification thereafter. It can\n   * be used for composing with other Observables, such as with {@link concat}.\n   * By default, it uses a `null` IScheduler, which means the `next`\n   * notifications are sent synchronously, although with a different IScheduler\n   * it is possible to determine when those notifications will be delivered.\n   *\n   * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n   * var numbers = Rx.Observable.of(10, 20, 30);\n   * var letters = Rx.Observable.of('a', 'b', 'c');\n   * var interval = Rx.Observable.interval(1000);\n   * var result = numbers.concat(letters).concat(interval);\n   * result.subscribe(x => console.log(x));\n   *\n   * @see {@link create}\n   * @see {@link empty}\n   * @see {@link never}\n   * @see {@link throw}\n   *\n   * @param {...T} values Arguments that represent `next` values to be emitted.\n   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n   * the emissions of the `next` notifications.\n   * @return {Observable<T>} An Observable that emits each given input value.\n   * @static true\n   * @name of\n   * @owner Observable\n   */\n  static of<T>(...array: Array<T | IScheduler>): Observable<T> {\n    let scheduler = <IScheduler>array[array.length - 1];\n    if (isScheduler(scheduler)) {\n      array.pop();\n    } else {\n      scheduler = null;\n    }\n\n    const len = array.length;\n    if (len > 1) {\n      return new ArrayObservable<T>(<any>array, scheduler);\n    } else if (len === 1) {\n      return new ScalarObservable<T>(<any>array[0], scheduler);\n    } else {\n      return new EmptyObservable<T>(scheduler);\n    }\n  }\n\n  static dispatch(state: any) {\n\n    const { array, index, count, subscriber } = state;\n\n    if (index >= count) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(array[index]);\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    state.index = index + 1;\n\n    (<any> this).schedule(state);\n  }\n\n  // value used if Array has one value and _isScalar\n  value: any;\n\n  constructor(private array: T[], private scheduler?: IScheduler) {\n    super();\n    if (!scheduler && array.length === 1) {\n      this._isScalar = true;\n      this.value = array[0];\n    }\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    let index = 0;\n    const array = this.array;\n    const count = array.length;\n    const scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(ArrayObservable.dispatch, 0, {\n        array, index, count, subscriber\n      });\n    } else {\n      for (let i = 0; i < count && !subscriber.closed; i++) {\n        subscriber.next(array[i]);\n      }\n      subscriber.complete();\n    }\n  }\n}\n", "export const isArrayLike = (<T>(x: any): x is ArrayLike<T> => x && typeof x.length === 'number');", "export function isPromise<T>(value: any | Promise<T>): value is Promise<T> {\n  return value && typeof (<any>value).subscribe !== 'function' && typeof (value as any).then === 'function';\n}\n", "import { root } from '../util/root';\n\nexport function symbolIteratorPonyfill(root: any) {\n  const Symbol: any = root.Symbol;\n\n  if (typeof Symbol === 'function') {\n    if (!Symbol.iterator) {\n      Symbol.iterator = Symbol('iterator polyfill');\n    }\n    return Symbol.iterator;\n  } else {\n    // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)\n    const { Set } = root;\n    if (Set && typeof new Set()['@@iterator'] === 'function') {\n      return '@@iterator';\n    }\n    const { Map } = root;\n    // required for compatability with es6-shim\n    if (Map) {\n      let keys = Object.getOwnPropertyNames(Map.prototype);\n      for (let i = 0; i < keys.length; ++i) {\n        let key = keys[i];\n        // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.\n        if (key !== 'entries' && key !== 'size' && Map.prototype[key] === Map.prototype['entries']) {\n          return key;\n        }\n      }\n    }\n    return '@@iterator';\n  }\n}\n\nexport const iterator = symbolIteratorPonyfill(root);\n\n/**\n * @deprecated use iterator instead\n */\nexport const $$iterator = iterator;\n", "import { Subscriber } from './Subscriber';\nimport { OuterSubscriber } from './OuterSubscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class InnerSubscriber<T, R> extends Subscriber<R> {\n  private index: number = 0;\n\n  constructor(private parent: OuterSubscriber<T, R>, private outerValue: T, private outerIndex: number) {\n    super();\n  }\n\n  protected _next(value: R): void {\n    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n  }\n\n  protected _error(error: any): void {\n    this.parent.notifyError(error, this);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.parent.notifyComplete(this);\n    this.unsubscribe();\n  }\n}\n", "import { root } from './root';\nimport { isArrayLike } from './isArrayLike';\nimport { isPromise } from './isPromise';\nimport { isObject } from './isObject';\nimport { Subscriber } from '../Subscriber';\nimport { Observable, ObservableInput } from '../Observable';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { Subscription } from '../Subscription';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\nexport function subscribeToResult<T, R>(outerSubscriber: OuterSubscriber<T, R>,\n                                        result: any,\n                                        outerValue?: T,\n                                        outerIndex?: number): Subscription;\nexport function subscribeToResult<T>(outerSubscriber: OuterSubscriber<any, any>,\n                                     result: ObservableInput<T>,\n                                     outerValue?: T,\n                                     outerIndex?: number): Subscription {\n  let destination: Subscriber<any> = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n\n  if (destination.closed) {\n    return null;\n  }\n\n  if (result instanceof Observable) {\n    if (result._isScalar) {\n      destination.next((<any>result).value);\n      destination.complete();\n      return null;\n    } else {\n      destination.syncErrorThrowable = true;\n      return result.subscribe(destination);\n    }\n  } else if (isArrayLike(result)) {\n    for (let i = 0, len = result.length; i < len && !destination.closed; i++) {\n      destination.next(result[i]);\n    }\n    if (!destination.closed) {\n      destination.complete();\n    }\n  } else if (isPromise(result)) {\n    result.then(\n      (value) => {\n        if (!destination.closed) {\n          destination.next(<any>value);\n          destination.complete();\n        }\n      },\n      (err: any) => destination.error(err)\n    )\n    .then(null, (err: any) => {\n      // Escaping the Promise trap: globally throw unhandled errors\n      root.setTimeout(() => { throw err; });\n    });\n    return destination;\n  } else if (result && typeof result[Symbol_iterator] === 'function') {\n    const iterator = <any>result[Symbol_iterator]();\n    do {\n      let item = iterator.next();\n      if (item.done) {\n        destination.complete();\n        break;\n      }\n      destination.next(item.value);\n      if (destination.closed) {\n        break;\n      }\n    } while (true);\n  } else if (result && typeof result[Symbol_observable] === 'function') {\n    const obs = result[Symbol_observable]();\n    if (typeof obs.subscribe !== 'function') {\n      destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));\n    } else {\n      return obs.subscribe(new InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n    }\n  } else {\n    const value = isObject(result) ? 'an invalid object' : `'${result}'`;\n    const msg = `You provided ${value} where a stream was expected.`\n      + ' You can provide an Observable, Promise, Array, or Iterable.';\n    destination.error(new TypeError(msg));\n  }\n  return null;\n}\n", "import { Subscriber } from './Subscriber';\nimport { InnerSubscriber } from './InnerSubscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class OuterSubscriber<T, R> extends Subscriber<T> {\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.destination.next(innerValue);\n  }\n\n  notifyError(error: any, innerSub: InnerSubscriber<T, R>): void {\n    this.destination.error(error);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, R>): void {\n    this.destination.complete();\n  }\n}\n", "import { Observable, ObservableInput } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function mergeMap<T, R>(project: (value: T, index: number) => ObservableInput<R>, concurrent?: number): OperatorFunction<T, R>;\nexport function mergeMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R, concurrent?: number): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * <img src=\"./img/mergeMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n * var letters = Rx.Observable.of('a', 'b', 'c');\n * var result = letters.mergeMap(x =>\n *   Rx.Observable.interval(1000).map(i => x+i)\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a,b,c with respective ascending integers\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and merging the results of the Observables obtained\n * from this transformation.\n * @method mergeMap\n * @owner Observable\n */\nexport function mergeMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>,\n                                  resultSelector?: ((outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) | number,\n                                  concurrent: number = Number.POSITIVE_INFINITY): OperatorFunction<T, I|R> {\n  return function mergeMapOperatorFunction(source: Observable<T>) {\n    if (typeof resultSelector === 'number') {\n      concurrent = <number>resultSelector;\n      resultSelector = null;\n    }\n    return source.lift(new MergeMapOperator(project, <any>resultSelector, concurrent));\n  };\n}\n\nexport class MergeMapOperator<T, I, R> implements Operator<T, I> {\n  constructor(private project: (value: T, index: number) => ObservableInput<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R,\n              private concurrent: number = Number.POSITIVE_INFINITY) {\n  }\n\n  call(observer: Subscriber<I>, source: any): any {\n    return source.subscribe(new MergeMapSubscriber(\n      observer, this.project, this.resultSelector, this.concurrent\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class MergeMapSubscriber<T, I, R> extends OuterSubscriber<T, I> {\n  private hasCompleted: boolean = false;\n  private buffer: T[] = [];\n  private active: number = 0;\n  protected index: number = 0;\n\n  constructor(destination: Subscriber<I>,\n              private project: (value: T, index: number) => ObservableInput<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R,\n              private concurrent: number = Number.POSITIVE_INFINITY) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (this.active < this.concurrent) {\n      this._tryNext(value);\n    } else {\n      this.buffer.push(value);\n    }\n  }\n\n  protected _tryNext(value: T) {\n    let result: ObservableInput<I>;\n    const index = this.index++;\n    try {\n      result = this.project(value, index);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.active++;\n    this._innerSub(result, value, index);\n  }\n\n  private _innerSub(ish: ObservableInput<I>, value: T, index: number): void {\n    this.add(subscribeToResult<T, I>(this, ish, value, index));\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (this.active === 0 && this.buffer.length === 0) {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: I,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, I>): void {\n    if (this.resultSelector) {\n      this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      this.destination.next(innerValue);\n    }\n  }\n\n  private _notifyResultSelector(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) {\n    let result: R;\n    try {\n      result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    const buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      this.destination.complete();\n    }\n  }\n}\n", "export function identity<T>(x: T): T {\n  return x;\n}\n", "\nimport { ObservableInput } from '../Observable';\nimport { mergeMap } from './mergeMap';\nimport { identity } from '../util/identity';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * <img src=\"./img/mergeAll.png\" width=\"100%\">\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var firstOrder = higherOrder.mergeAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n * var firstOrder = higherOrder.mergeAll(2);\n * firstOrder.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits values coming from all the\n * inner Observables emitted by the source Observable.\n * @method mergeAll\n * @owner Observable\n */\nexport function mergeAll<T>(concurrent: number = Number.POSITIVE_INFINITY): MonoTypeOperatorFunction<T> {\n  return mergeMap(identity as (value: T, index: number) => ObservableInput<{}>, null, concurrent);\n}", "import { Observable, ObservableInput } from '../Observable';\nimport { IScheduler } from '../Scheduler';\nimport { ArrayObservable } from './ArrayObservable';\nimport { isScheduler } from '../util/isScheduler';\nimport { mergeAll } from '../operators/mergeAll';\n\n/* tslint:disable:max-line-length */\nexport function merge<T>(v1: ObservableInput<T>, scheduler?: IScheduler): Observable<T>;\nexport function merge<T>(v1: ObservableInput<T>, concurrent?: number, scheduler?: IScheduler): Observable<T>;\nexport function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler?: IScheduler): Observable<T | T2>;\nexport function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2>;\nexport function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: IScheduler): Observable<T | T2 | T3>;\nexport function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2 | T3>;\nexport function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: IScheduler): Observable<T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: IScheduler): Observable<T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: IScheduler): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T>(...observables: (ObservableInput<T> | IScheduler | number)[]): Observable<T>;\nexport function merge<T, R>(...observables: (ObservableInput<any> | IScheduler | number)[]): Observable<R>;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (as arguments), and simply\n * forwards (without doing any transformation) all the values from all the input\n * Observables to the output Observable. The output Observable only completes\n * once all input Observables have completed. Any error delivered by an input\n * Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = Rx.Observable.merge(clicks, timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // timer will emit ascending values, one every second(1000ms) to console\n * // clicks logs MouseEvents to console everytime the \"document\" is clicked\n * // Since the two streams are merged you see these happening\n * // as they occur.\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - First timer1 and timer2 will run concurrently\n * // - timer1 will emit a value every 1000ms for 10 iterations\n * // - timer2 will emit a value every 2000ms for 6 iterations\n * // - after timer1 hits it's max iteration, timer2 will\n * //   continue, and timer3 will start to run concurrently with timer2\n * // - when timer2 hits it's max iteration it terminates, and\n * //   timer3 will continue to emit a value every 500ms until it is complete\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {...ObservableInput} observables Input Observables to merge together.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} an Observable that emits items that are the result of\n * every input Observable.\n * @static true\n * @name merge\n * @owner Observable\n */\nexport function merge<T, R>(...observables: Array<ObservableInput<any> | IScheduler | number>): Observable<R> {\n let concurrent = Number.POSITIVE_INFINITY;\n let scheduler: IScheduler = null;\n  let last: any = observables[observables.length - 1];\n  if (isScheduler(last)) {\n    scheduler = <IScheduler>observables.pop();\n    if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {\n      concurrent = <number>observables.pop();\n    }\n  } else if (typeof last === 'number') {\n    concurrent = <number>observables.pop();\n  }\n\n  if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {\n    return <Observable<R>>observables[0];\n  }\n\n  return mergeAll(concurrent)(new ArrayObservable(<any>observables, scheduler)) as Observable<R>;\n}\n", "import { Observable, ObservableInput } from '../Observable';\nimport { IScheduler } from '../Scheduler';\nimport { OperatorFunction, MonoTypeOperatorFunction } from '../interfaces';\nimport { merge as mergeStatic } from '../observable/merge';\n\nexport { merge as mergeStatic } from '../observable/merge';\n\n/* tslint:disable:max-line-length */\nexport function merge<T>(scheduler?: IScheduler): MonoTypeOperatorFunction<T>;\nexport function merge<T>(concurrent?: number, scheduler?: IScheduler): MonoTypeOperatorFunction<T>;\nexport function merge<T, T2>(v2: ObservableInput<T2>, scheduler?: IScheduler): OperatorFunction<T, T | T2>;\nexport function merge<T, T2>(v2: ObservableInput<T2>, concurrent?: number, scheduler?: IScheduler): OperatorFunction<T, T | T2>;\nexport function merge<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: IScheduler): OperatorFunction<T, T | T2 | T3>;\nexport function merge<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent?: number, scheduler?: IScheduler): OperatorFunction<T, T | T2 | T3>;\nexport function merge<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: IScheduler): OperatorFunction<T, T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent?: number, scheduler?: IScheduler): OperatorFunction<T, T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: IScheduler): OperatorFunction<T, T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent?: number, scheduler?: IScheduler): OperatorFunction<T, T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: IScheduler): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent?: number, scheduler?: IScheduler): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T>(...observables: Array<ObservableInput<T> | IScheduler | number>): MonoTypeOperatorFunction<T>;\nexport function merge<T, R>(...observables: Array<ObservableInput<any> | IScheduler | number>): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nexport function merge<T, R>(...observables: Array<ObservableInput<any> | IScheduler | number>): OperatorFunction<T, R> {\n  return (source: Observable<T>) => source.lift.call(mergeStatic(source, ...observables));\n}\n", "import { Observable, ObservableInput } from '../Observable';\nimport { IScheduler } from '../Scheduler';\nimport { merge as higherOrder } from '../operators/merge';\n\nexport { merge as mergeStatic } from '../observable/merge';\n\n/* tslint:disable:max-line-length */\nexport function merge<T>(this: Observable<T>, scheduler?: IScheduler): Observable<T>;\nexport function merge<T>(this: Observable<T>, concurrent?: number, scheduler?: IScheduler): Observable<T>;\nexport function merge<T, T2>(this: Observable<T>, v2: ObservableInput<T2>, scheduler?: IScheduler): Observable<T | T2>;\nexport function merge<T, T2>(this: Observable<T>, v2: ObservableInput<T2>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2>;\nexport function merge<T, T2, T3>(this: Observable<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: IScheduler): Observable<T | T2 | T3>;\nexport function merge<T, T2, T3>(this: Observable<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2 | T3>;\nexport function merge<T, T2, T3, T4>(this: Observable<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: IScheduler): Observable<T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4>(this: Observable<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4, T5>(this: Observable<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: IScheduler): Observable<T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5>(this: Observable<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5, T6>(this: Observable<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: IScheduler): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T, T2, T3, T4, T5, T6>(this: Observable<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T>(this: Observable<T>, ...observables: Array<ObservableInput<T> | IScheduler | number>): Observable<T>;\nexport function merge<T, R>(this: Observable<T>, ...observables: Array<ObservableInput<any> | IScheduler | number>): Observable<R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nexport function merge<T, R>(this: Observable<T>, ...observables: Array<ObservableInput<any> | IScheduler | number>): Observable<R> {\n  return higherOrder(...observables)(this) as Observable<R>;\n}\n", "\nimport { Observable } from '../../Observable';\nimport { merge } from '../../operator/merge';\n\nObservable.prototype.merge = merge;\n\ndeclare module '../../Observable' {\n  interface Observable<T> {\n    merge: typeof merge;\n  }\n}"],
  "mappings": "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",
  "names": ["Observable_1", "ScalarObservable", "Observable_1", "EmptyObservable", "Observable_1", "ArrayObservable", "InnerSubscriber", "Observable_1", "value", "OuterSubscriber", "MergeMapOperator", "MergeMapSubscriber", "Observable_1", "merge_1", "merge_1"]
}
