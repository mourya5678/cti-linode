{
  "version": 3,
  "sources": ["../../../../../node_modules/@reach/portal/src/index.tsx", "../../../../../node_modules/@reach/rect/src/index.tsx", "../../../../../node_modules/@reach/popover/src/index.tsx"],
  "sourcesContent": ["/**\n * Welcome to @reach/portal!\n *\n * Creates and appends a DOM node to the end of `document.body` and renders a\n * React tree into it. Useful for rendering a natural React element hierarchy\n * with a different DOM hierarchy to prevent parent styles from clipping or\n * hiding content (for popovers, dropdowns, and modals).\n *\n * @see Docs   https://reacttraining.com/reach-ui/portal\n * @see Source https://github.com/reach/reach-ui/tree/main/packages/portal\n * @see React  https://reactjs.org/docs/portals.html\n */\n\nimport React, { useRef, useState } from \"react\";\nimport { useIsomorphicLayoutEffect } from \"@reach/utils\";\nimport { createPortal } from \"react-dom\";\n\n/**\n * Portal\n *\n * @see Docs https://reacttraining.com/reach-ui/portal#portal\n */\nconst Portal: React.FC<PortalProps> = ({ children, type = \"reach-portal\" }) => {\n  let mountNode = useRef<HTMLDivElement | null>(null);\n  let portalNode = useRef<HTMLElement | null>(null);\n  let [, forceUpdate] = useState();\n\n  useIsomorphicLayoutEffect(() => {\n    // This ref may be null when a hot-loader replaces components on the page\n    if (!mountNode.current) return;\n    // It's possible that the content of the portal has, itself, been portaled.\n    // In that case, it's important to append to the correct document element.\n    const ownerDocument = mountNode.current!.ownerDocument;\n    portalNode.current = ownerDocument?.createElement(type)!;\n    ownerDocument!.body.appendChild(portalNode.current);\n    forceUpdate({});\n    return () => {\n      if (portalNode.current && portalNode.current.ownerDocument) {\n        portalNode.current.ownerDocument.body.removeChild(portalNode.current);\n      }\n    };\n  }, [type]);\n\n  return portalNode.current ? (\n    createPortal(children, portalNode.current)\n  ) : (\n    <span ref={mountNode} />\n  );\n};\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/portal#portal-props\n */\nexport type PortalProps = {\n  /**\n   * Regular React children.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/portal#portal-children\n   */\n  children: React.ReactNode;\n  /**\n   * The DOM element type to render.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/portal#portal-type\n   */\n  type?: string;\n};\n\nif (__DEV__) {\n  Portal.displayName = \"Portal\";\n}\n\nexport default Portal;\n", "/**\n * Welcome to @reach/rect!\n *\n * Measures DOM elements (aka. bounding client rect).\n *\n * @see getBoundingClientRect https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\n * @see Docs                  https://reacttraining.com/reach-ui/rect\n * @see Source                https://github.com/reach/reach-ui/tree/main/packages/rect\n */\n\nimport React, { useRef, useState } from \"react\";\nimport PropTypes from \"prop-types\";\nimport observeRect from \"@reach/observe-rect\";\nimport { useIsomorphicLayoutEffect } from \"@reach/utils\";\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Rect\n *\n * @param props\n */\nexport const Rect: React.FC<RectProps> = ({\n  onChange,\n  observe = true,\n  children,\n}) => {\n  const ref = useRef<HTMLElement | null>(null);\n  const rect = useRect(ref, observe, onChange);\n  return children({ ref, rect });\n};\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/rect#rect-props\n */\nexport type RectProps = {\n  /**\n   * Tells `Rect` to observe the position of the node or not. While observing,\n   * the `children` render prop may call back very quickly (especially while\n   * scrolling) so it can be important for performance to avoid observing when\n   * you don't need to.\n   *\n   * This is typically used for elements that pop over other elements (like a\n   * dropdown menu), so you don't need to observe all the time, only when the\n   * popup is active.\n   *\n   * Pass `true` to observe, `false` to ignore.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/rect#rect-observe\n   */\n  observe?: boolean;\n  /**\n   * Calls back whenever the `rect` of the element changes.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/rect#rect-onchange\n   */\n  onChange?: (rect: PRect) => void;\n  /**\n   * A function that calls back to you with a `ref` to place on an element and\n   * the `rect` measurements of the dom node.\n   *\n   * **Note**: On the first render `rect` will be `undefined` because we can't\n   * measure a node that has not yet been rendered. Make sure your code accounts\n   * for this.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/rect#rect-onchange\n   */\n  children(args: {\n    rect: PRect | null;\n    ref: React.RefObject<any>;\n  }): JSX.Element;\n};\n\nif (__DEV__) {\n  Rect.displayName = \"Rect\";\n  Rect.propTypes = {\n    children: PropTypes.func.isRequired,\n    observe: PropTypes.bool,\n    onChange: PropTypes.func,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * useRect\n *\n * @param nodeRef\n * @param observe\n * @param onChange\n */\nexport function useRect<T extends Element = HTMLElement>(\n  nodeRef: React.RefObject<T | undefined | null>,\n  observe: boolean = true,\n  onChange?: (rect: DOMRect) => void\n): null | DOMRect {\n  let [element, setElement] = useState(nodeRef.current);\n  let initialRectIsSet = useRef(false);\n  let initialRefIsSet = useRef(false);\n  let [rect, setRect] = useState<DOMRect | null>(null);\n  let onChangeRef = useRef<typeof onChange>();\n\n  useIsomorphicLayoutEffect(() => {\n    onChangeRef.current = onChange;\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current);\n    }\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    if (element && !initialRectIsSet.current) {\n      initialRectIsSet.current = true;\n      setRect(element.getBoundingClientRect());\n    }\n  }, [element]);\n\n  useIsomorphicLayoutEffect(() => {\n    let observer: ReturnType<typeof observeRect>;\n    let elem = element;\n\n    // State initializes before refs are placed, meaning the element state will\n    // be undefined on the first render. We still want the rect on the first\n    // render, so initially we'll use the nodeRef that was passed instead of\n    // state for our measurements.\n    if (!initialRefIsSet.current) {\n      initialRefIsSet.current = true;\n      elem = nodeRef.current;\n    }\n\n    if (!elem) {\n      if (__DEV__) {\n        console.warn(\"You need to place the ref\");\n      }\n      return cleanup;\n    }\n\n    observer = observeRect(elem, (rect) => {\n      onChangeRef.current && onChangeRef.current(rect);\n      setRect(rect);\n    });\n\n    observe && observer.observe();\n    return cleanup;\n\n    function cleanup() {\n      observer && observer.unobserve();\n    }\n  }, [observe, element]);\n\n  return rect;\n}\n\nexport default Rect;\n\nexport type PRect = Partial<DOMRect> & {\n  readonly bottom: number;\n  readonly height: number;\n  readonly left: number;\n  readonly right: number;\n  readonly top: number;\n  readonly width: number;\n};\n", "/**\n * Welcome to @reach/popover!\n */\n\nimport React, { useRef, forwardRef, useEffect } from \"react\";\nimport Portal from \"@reach/portal\";\nimport { useRect, PRect } from \"@reach/rect\";\nimport { getOwnerDocument, useForkedRef } from \"@reach/utils\";\nimport tabbable from \"tabbable\";\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Popover\n */\nconst Popover = forwardRef<HTMLDivElement, PopoverProps>(function Popover(\n  props,\n  ref\n) {\n  return (\n    <Portal>\n      <PopoverImpl ref={ref} {...props} />\n    </Portal>\n  );\n});\n\nexport type PopoverProps = {\n  children: React.ReactNode;\n  targetRef: React.RefObject<HTMLElement>;\n  position?: Position;\n  /**\n   * Testing this API so we might accept additional nodes that apps can use to\n   * determine the position of the popover. One example where it may be useful\n   * is for positioning the popover of a listbox where the cursor rests on top\n   * of the selected option. Pretty sure this will change so don't use it\n   * anywehre in public yet!\n   */\n  unstable_observableRefs?: React.RefObject<PossibleNode>[];\n} & React.HTMLAttributes<HTMLDivElement>;\n\nif (__DEV__) {\n  Popover.displayName = \"Popover\";\n}\n\nexport default Popover;\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * PopoverImpl\n *\n * Popover is conditionally rendered so we can't start measuring until it shows\n * up, so useRect needs to live down here not up in Popover\n */\nconst PopoverImpl = forwardRef<HTMLDivElement, PopoverProps>(\n  function PopoverImpl(\n    {\n      targetRef,\n      position = positionDefault,\n      unstable_observableRefs = [],\n      ...props\n    },\n    forwardedRef\n  ) {\n    const popoverRef = useRef<HTMLDivElement>(null);\n    const popoverRect = useRect(popoverRef);\n    const targetRect = useRect(targetRef);\n    const ref = useForkedRef(popoverRef, forwardedRef);\n\n    useSimulateTabNavigationForReactTree(targetRef, popoverRef);\n\n    return (\n      <div\n        data-reach-popover=\"\"\n        ref={ref}\n        {...props}\n        style={{\n          position: \"absolute\",\n          ...getStyles(\n            position,\n            targetRect,\n            popoverRect,\n            ...unstable_observableRefs\n          ),\n          ...props.style,\n        }}\n      />\n    );\n  }\n);\n\nif (__DEV__) {\n  PopoverImpl.displayName = \"PopoverImpl\";\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction getStyles(\n  position: Position,\n  targetRect: PRect | null,\n  popoverRect: PRect | null,\n  ...unstable_observableRefs: React.RefObject<PossibleNode>[]\n): React.CSSProperties {\n  return popoverRect\n    ? position(\n        targetRect,\n        popoverRect,\n        ...unstable_observableRefs.map((ref) => ref.current)\n      )\n    : { visibility: \"hidden\" };\n}\n\nfunction getTopPosition(targetRect: PRect, popoverRect: PRect) {\n  const { directionUp } = getCollisions(targetRect, popoverRect);\n  return {\n    top: directionUp\n      ? `${targetRect.top - popoverRect.height + window.pageYOffset}px`\n      : `${targetRect.top + targetRect.height + window.pageYOffset}px`,\n  };\n}\n\nexport const positionDefault: Position = (targetRect, popoverRect) => {\n  if (!targetRect || !popoverRect) {\n    return {};\n  }\n\n  const { directionRight } = getCollisions(targetRect, popoverRect);\n  return {\n    left: directionRight\n      ? `${targetRect.right - popoverRect.width + window.pageXOffset}px`\n      : `${targetRect.left + window.pageXOffset}px`,\n    ...getTopPosition(targetRect, popoverRect),\n  };\n};\n\nexport const positionRight: Position = (targetRect, popoverRect) => {\n  if (!targetRect || !popoverRect) {\n    return {};\n  }\n\n  const { directionLeft } = getCollisions(targetRect, popoverRect);\n  return {\n    left: directionLeft\n      ? `${targetRect.left + window.pageXOffset}px`\n      : `${targetRect.right - popoverRect.width + window.pageXOffset}px`,\n    ...getTopPosition(targetRect, popoverRect),\n  };\n};\n\nexport const positionMatchWidth: Position = (targetRect, popoverRect) => {\n  if (!targetRect || !popoverRect) {\n    return {};\n  }\n\n  return {\n    width: targetRect.width,\n    left: targetRect.left,\n    ...getTopPosition(targetRect, popoverRect),\n  };\n};\n\nexport function getCollisions(\n  targetRect: PRect,\n  popoverRect: PRect,\n  offsetLeft: number = 0,\n  offsetBottom: number = 0\n) {\n  const collisions = {\n    top: targetRect.top - popoverRect.height < 0,\n    right: window.innerWidth < targetRect.left + popoverRect.width - offsetLeft,\n    bottom:\n      window.innerHeight <\n      targetRect.bottom + popoverRect.height - offsetBottom,\n    left: targetRect.left + targetRect.width - popoverRect.width < 0,\n  };\n\n  const directionRight = collisions.right && !collisions.left;\n  const directionLeft = collisions.left && !collisions.right;\n  const directionUp = collisions.bottom && !collisions.top;\n  const directionDown = collisions.top && !collisions.bottom;\n\n  return { directionRight, directionLeft, directionUp, directionDown };\n}\n\n// Heads up, my jQuery past haunts this function. This hook scopes the tab\n// order to the React element tree, instead of the DOM tree. This way, when the\n// user navigates with tab from the targetRef, the tab order moves into the\n// popup, and then out of the popup back to the rest of the document.\n// (We call targetRef, triggerRef inside this function to avoid confusion with\n// event.target)\nfunction useSimulateTabNavigationForReactTree<\n  T extends HTMLElement = HTMLElement,\n  P extends HTMLElement = HTMLElement\n>(triggerRef: React.RefObject<T>, popoverRef: React.RefObject<P>) {\n  const ownerDocument = getOwnerDocument(triggerRef.current);\n\n  function handleKeyDown(event: KeyboardEvent) {\n    if (\n      event.key === \"Tab\" &&\n      popoverRef.current &&\n      tabbable(popoverRef.current).length === 0\n    ) {\n      return;\n    }\n\n    if (event.key === \"Tab\" && event.shiftKey) {\n      if (shiftTabbedFromElementAfterTrigger(event)) {\n        focusLastTabbableInPopover(event);\n      } else if (shiftTabbedOutOfPopover(event)) {\n        focusTriggerRef(event);\n      } else if (shiftTabbedToBrowserChrome(event)) {\n        disableTabbablesInPopover();\n      }\n    } else if (event.key === \"Tab\") {\n      if (tabbedFromTriggerToPopover()) {\n        focusFirstPopoverTabbable(event);\n      } else if (tabbedOutOfPopover()) {\n        focusTabbableAfterTrigger(event);\n      } else if (tabbedToBrowserChrome(event)) {\n        disableTabbablesInPopover();\n      }\n    }\n  }\n\n  useEffect(() => {\n    if (ownerDocument) {\n      ownerDocument.addEventListener(\"keydown\", handleKeyDown);\n      return () => {\n        ownerDocument.removeEventListener(\"keydown\", handleKeyDown);\n      };\n    }\n    return;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  function getElementAfterTrigger() {\n    const elements = ownerDocument && tabbable(ownerDocument);\n    const targetIndex =\n      elements && triggerRef.current\n        ? elements.indexOf(triggerRef.current)\n        : -1;\n    const elementAfterTrigger = elements && elements[targetIndex + 1];\n    return popoverRef.current &&\n      popoverRef.current.contains(elementAfterTrigger || null)\n      ? false\n      : elementAfterTrigger;\n  }\n\n  function tabbedFromTriggerToPopover() {\n    return triggerRef.current && ownerDocument\n      ? triggerRef.current === ownerDocument.activeElement\n      : false;\n  }\n\n  function focusFirstPopoverTabbable(event: KeyboardEvent) {\n    const elements = popoverRef.current && tabbable(popoverRef.current);\n    if (elements && elements[0]) {\n      event.preventDefault();\n      elements[0].focus();\n    }\n  }\n\n  function tabbedOutOfPopover() {\n    const inPopover =\n      popoverRef.current && ownerDocument\n        ? popoverRef.current.contains(ownerDocument.activeElement || null)\n        : false;\n    if (inPopover) {\n      const elements = popoverRef.current && tabbable(popoverRef.current);\n      return Boolean(\n        elements &&\n          ownerDocument &&\n          elements[elements.length - 1] === ownerDocument.activeElement\n      );\n    }\n    return false;\n  }\n\n  function focusTabbableAfterTrigger(event: KeyboardEvent) {\n    const elementAfterTrigger = getElementAfterTrigger();\n    if (elementAfterTrigger) {\n      event.preventDefault();\n      elementAfterTrigger.focus();\n    }\n  }\n\n  function shiftTabbedFromElementAfterTrigger(event: KeyboardEvent) {\n    if (!event.shiftKey) return;\n    const elementAfterTrigger = getElementAfterTrigger();\n    return event.target === elementAfterTrigger;\n  }\n\n  function focusLastTabbableInPopover(event: KeyboardEvent) {\n    const elements = popoverRef.current && tabbable(popoverRef.current);\n    const last = elements && elements[elements.length - 1];\n    if (last) {\n      event.preventDefault();\n      last.focus();\n    }\n  }\n\n  function shiftTabbedOutOfPopover(event: KeyboardEvent) {\n    const elements = popoverRef.current && tabbable(popoverRef.current);\n    if (elements) {\n      return elements.length === 0 ? false : event.target === elements[0];\n    }\n    return false;\n  }\n\n  function focusTriggerRef(event: KeyboardEvent) {\n    event.preventDefault();\n    triggerRef.current?.focus();\n  }\n\n  function tabbedToBrowserChrome(event: KeyboardEvent) {\n    const elements =\n      ownerDocument && popoverRef.current\n        ? tabbable(ownerDocument).filter(\n            (element) => !popoverRef.current!.contains(element)\n          )\n        : null;\n    return elements ? event.target === elements[elements.length - 1] : false;\n  }\n\n  function shiftTabbedToBrowserChrome(event: KeyboardEvent) {\n    // we're assuming the popover will never contain the first tabbable\n    // element, and it better not, because the trigger needs to be tabbable!\n    return ownerDocument ? event.target === tabbable(ownerDocument)[0] : false;\n  }\n\n  let restoreTabIndexTuplés: [HTMLElement, number][] = [];\n\n  function disableTabbablesInPopover() {\n    const elements = popoverRef.current && tabbable(popoverRef.current);\n    if (elements) {\n      elements.forEach((element) => {\n        restoreTabIndexTuplés.push([element, element.tabIndex]);\n        element.tabIndex = -1;\n      });\n      ownerDocument &&\n        ownerDocument.addEventListener(\"focusin\", enableTabbablesInPopover);\n    }\n  }\n\n  function enableTabbablesInPopover() {\n    ownerDocument &&\n      ownerDocument.removeEventListener(\"focusin\", enableTabbablesInPopover);\n    restoreTabIndexTuplés.forEach(([element, tabIndex]) => {\n      element.tabIndex = tabIndex;\n    });\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\nexport type Position = (\n  targetRect?: PRect | null,\n  popoverRect?: PRect | null,\n  ...unstable_observableNodes: PossibleNode[]\n) => React.CSSProperties;\n\ntype PossibleNode = null | undefined | HTMLElement | SVGElement;\n"],
  "mappings": "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",
  "names": ["Portal", "children", "type", "mountNode", "useRef", "portalNode", "useState", "forceUpdate", "useIsomorphicLayoutEffect", "current", "ownerDocument", "createElement", "body", "appendChild", "removeChild", "createPortal", "React", "ref", "displayName", "Rect", "onChange", "observe", "children", "ref", "useRef", "rect", "useRect", "displayName", "propTypes", "PropTypes", "func", "isRequired", "bool", "nodeRef", "useState", "current", "element", "setElement", "initialRectIsSet", "initialRefIsSet", "setRect", "onChangeRef", "useIsomorphicLayoutEffect", "getBoundingClientRect", "observer", "elem", "console", "warn", "cleanup", "observeRect", "unobserve", "Popover", "forwardRef", "props", "ref", "React", "Portal", "PopoverImpl", "displayName", "forwardedRef", "targetRef", "position", "positionDefault", "unstable_observableRefs", "popoverRef", "useRef", "popoverRect", "useRect", "targetRect", "useForkedRef", "useSimulateTabNavigationForReactTree", "style", "getStyles", "map", "current", "visibility", "getTopPosition", "getCollisions", "directionUp", "top", "height", "window", "pageYOffset", "directionRight", "left", "right", "width", "pageXOffset", "positionRight", "directionLeft", "positionMatchWidth", "offsetLeft", "offsetBottom", "collisions", "innerWidth", "bottom", "innerHeight", "directionDown", "triggerRef", "ownerDocument", "getOwnerDocument", "handleKeyDown", "event", "key", "tabbable", "length", "shiftKey", "shiftTabbedFromElementAfterTrigger", "focusLastTabbableInPopover", "shiftTabbedOutOfPopover", "focusTriggerRef", "shiftTabbedToBrowserChrome", "disableTabbablesInPopover", "tabbedFromTriggerToPopover", "focusFirstPopoverTabbable", "tabbedOutOfPopover", "focusTabbableAfterTrigger", "tabbedToBrowserChrome", "useEffect", "addEventListener", "removeEventListener", "getElementAfterTrigger", "elements", "targetIndex", "indexOf", "elementAfterTrigger", "contains", "activeElement", "preventDefault", "focus", "inPopover", "Boolean", "target", "last", "filter", "element", "restoreTabIndexTuplés", "forEach", "push", "tabIndex", "enableTabbablesInPopover"]
}
