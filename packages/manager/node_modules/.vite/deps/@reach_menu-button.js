import {
  observe_rect_esm_default,
  require_tabbable
} from "./chunk-LUXDPJAP.js";
import {
  require_warning
} from "./chunk-6GLVATRU.js";
import {
  require_react_dom
} from "./chunk-66PEM4UL.js";
import {
  require_prop_types
} from "./chunk-PLEWTTGR.js";
import "./chunk-NGRKVEHQ.js";
import {
  require_react
} from "./chunk-CPU6GBAM.js";
import {
  __toESM
} from "./chunk-LFBQMW2U.js";

// ../../node_modules/@reach/menu-button/dist/menu-button.esm.js
var import_react7 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());

// ../../node_modules/@reach/menu-button/node_modules/@reach/auto-id/dist/auto-id.esm.js
var import_react2 = __toESM(require_react());

// ../../node_modules/@reach/menu-button/node_modules/@reach/utils/dist/utils.esm.js
var import_react = __toESM(require_react());
var import_warning = __toESM(require_warning());
var useIsomorphicLayoutEffect = canUseDOM() ? import_react.default.useLayoutEffect : import_react.default.useEffect;
var checkedPkgs = {};
var checkStyles = noop;
if (true) {
  _ref = typeof process !== "undefined" ? process : {
    env: {
      NODE_ENV: "development"
    }
  }, env = _ref.env;
  checkStyles = function checkStyles2(packageName) {
    if (checkedPkgs[packageName])
      return;
    checkedPkgs[packageName] = true;
    if (env.NODE_ENV !== "test" && parseInt(window.getComputedStyle(document.body).getPropertyValue("--reach-" + packageName), 10) !== 1) {
      console.warn("@reach/" + packageName + ' styles not found. If you are using a bundler like webpack or parcel include this in the entry file of your app before any of your own styles:\n\n    import "@reach/' + packageName + `/styles.css";

  Otherwise you'll need to include them some other way:

    <link rel="stylesheet" type="text/css" href="node_modules/@reach/` + packageName + '/styles.css" />\n\n  For more information visit https://ui.reach.tech/styling.\n  ');
    }
  };
}
var _ref;
var env;
var ponyfillGlobal = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : (
  // eslint-disable-next-line no-new-func
  Function("return this")()
);
function assignRef(ref, value) {
  if (ref == null)
    return;
  if (isFunction(ref)) {
    ref(value);
  } else {
    try {
      ref.current = value;
    } catch (error) {
      throw new Error('Cannot assign value "' + value + '" to ref "' + ref + '"');
    }
  }
}
function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function createNamedContext(name, defaultValue) {
  var Ctx = (0, import_react.createContext)(defaultValue);
  Ctx.displayName = name;
  return Ctx;
}
function forwardRefWithAs(render) {
  return import_react.default.forwardRef(render);
}
function getOwnerDocument(element) {
  return element && element.ownerDocument ? element.ownerDocument : canUseDOM() ? document : null;
}
function isFunction(value) {
  return !!(value && {}.toString.call(value) == "[object Function]");
}
function isString(value) {
  return typeof value === "string";
}
function makeId() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  return args.filter(function(val) {
    return val != null;
  }).join("--");
}
function noop() {
}
var useControlledSwitchWarning = noop;
if (true) {
  useControlledSwitchWarning = function useControlledSwitchWarning2(controlledValue, controlledPropName, componentName) {
    var controlledRef = (0, import_react.useRef)(controlledValue != null);
    var nameCache = (0, import_react.useRef)({
      componentName,
      controlledPropName
    });
    (0, import_react.useEffect)(function() {
      nameCache.current = {
        componentName,
        controlledPropName
      };
    }, [componentName, controlledPropName]);
    (0, import_react.useEffect)(function() {
      var wasControlled = controlledRef.current;
      var _nameCache$current = nameCache.current, componentName2 = _nameCache$current.componentName, controlledPropName2 = _nameCache$current.controlledPropName;
      var isControlled = controlledValue != null;
      if (wasControlled !== isControlled) {
        console.error("A component is changing an " + (wasControlled ? "" : "un") + "controlled `" + controlledPropName2 + "` state of " + componentName2 + " to be " + (wasControlled ? "un" : "") + "controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled " + componentName2 + " element for the lifetime of the component.\nMore info: https://fb.me/react-controlled-components");
      }
    }, [controlledValue]);
  };
}
var useCheckStyles = noop;
if (true) {
  useCheckStyles = function useCheckStyles2(pkg) {
    var name = (0, import_react.useRef)(pkg);
    (0, import_react.useEffect)(function() {
      return void (name.current = pkg);
    }, [pkg]);
    (0, import_react.useEffect)(function() {
      return checkStyles(name.current);
    }, []);
  };
}
function useForceUpdate() {
  var _useState2 = (0, import_react.useState)(/* @__PURE__ */ Object.create(null)), dispatch = _useState2[1];
  return (0, import_react.useCallback)(function() {
    dispatch(/* @__PURE__ */ Object.create(null));
  }, []);
}
function useForkedRef() {
  for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    refs[_key4] = arguments[_key4];
  }
  return (0, import_react.useMemo)(function() {
    if (refs.every(function(ref) {
      return ref == null;
    })) {
      return null;
    }
    return function(node) {
      refs.forEach(function(ref) {
        assignRef(ref, node);
      });
    };
  }, [].concat(refs));
}
function usePrevious(value) {
  var ref = (0, import_react.useRef)(null);
  (0, import_react.useEffect)(function() {
    ref.current = value;
  }, [value]);
  return ref.current;
}
var useStateLogger = noop;
if (true) {
  useStateLogger = function useStateLogger2(state, DEBUG) {
    if (DEBUG === void 0) {
      DEBUG = false;
    }
    var debugRef = (0, import_react.useRef)(DEBUG);
    (0, import_react.useEffect)(function() {
      debugRef.current = DEBUG;
    }, [DEBUG]);
    (0, import_react.useEffect)(function() {
      if (debugRef.current) {
        console.group("State Updated");
        console.log("%c" + state, "font-weight: normal; font-size: 120%; font-style: italic;");
        console.groupEnd();
      }
    }, [state]);
  };
}
function wrapEvent(theirHandler, ourHandler) {
  return function(event) {
    theirHandler && theirHandler(event);
    if (!event.defaultPrevented) {
      return ourHandler(event);
    }
  };
}

// ../../node_modules/@reach/menu-button/node_modules/@reach/auto-id/dist/auto-id.esm.js
var serverHandoffComplete = false;
var id = 0;
var genId = function genId2() {
  return ++id;
};
var useId = function useId2(idFromProps) {
  var initialId = idFromProps || (serverHandoffComplete ? genId() : null);
  var _useState = (0, import_react2.useState)(initialId), id2 = _useState[0], setId = _useState[1];
  useIsomorphicLayoutEffect(function() {
    if (id2 === null) {
      setId(genId());
    }
  }, []);
  (0, import_react2.useEffect)(function() {
    if (serverHandoffComplete === false) {
      serverHandoffComplete = true;
    }
  }, []);
  return id2 != null ? String(id2) : void 0;
};

// ../../node_modules/@reach/menu-button/node_modules/@reach/popover/dist/popover.esm.js
var import_react5 = __toESM(require_react());

// ../../node_modules/@reach/menu-button/node_modules/@reach/portal/dist/portal.esm.js
var import_react3 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
var Portal = function Portal2(_ref) {
  var children = _ref.children, _ref$type = _ref.type, type = _ref$type === void 0 ? "reach-portal" : _ref$type;
  var mountNode = (0, import_react3.useRef)(null);
  var portalNode = (0, import_react3.useRef)(null);
  var forceUpdate = useForceUpdate();
  useIsomorphicLayoutEffect(function() {
    if (!mountNode.current)
      return;
    var ownerDocument = mountNode.current.ownerDocument;
    portalNode.current = ownerDocument === null || ownerDocument === void 0 ? void 0 : ownerDocument.createElement(type);
    ownerDocument.body.appendChild(portalNode.current);
    forceUpdate();
    return function() {
      if (portalNode.current && portalNode.current.ownerDocument) {
        portalNode.current.ownerDocument.body.removeChild(portalNode.current);
      }
    };
  }, [type, forceUpdate]);
  return portalNode.current ? (0, import_react_dom.createPortal)(children, portalNode.current) : import_react3.default.createElement("span", {
    ref: mountNode
  });
};
if (true) {
  Portal.displayName = "Portal";
}
var portal_esm_default = Portal;

// ../../node_modules/@reach/menu-button/node_modules/@reach/rect/dist/rect.esm.js
var import_react4 = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
var Rect = function Rect2(_ref) {
  var onChange = _ref.onChange, _ref$observe = _ref.observe, observe = _ref$observe === void 0 ? true : _ref$observe, children = _ref.children;
  var ref = (0, import_react4.useRef)(null);
  var rect = useRect(ref, observe, onChange);
  return children({
    ref,
    rect
  });
};
if (true) {
  Rect.displayName = "Rect";
  Rect.propTypes = {
    children: import_prop_types.default.func.isRequired,
    observe: import_prop_types.default.bool,
    onChange: import_prop_types.default.func
  };
}
function useRect(nodeRef, observe, onChange) {
  if (observe === void 0) {
    observe = true;
  }
  var _useState = (0, import_react4.useState)(nodeRef.current), element = _useState[0], setElement = _useState[1];
  var initialRectIsSet = (0, import_react4.useRef)(false);
  var initialRefIsSet = (0, import_react4.useRef)(false);
  var _useState2 = (0, import_react4.useState)(null), rect = _useState2[0], setRect = _useState2[1];
  var onChangeRef = (0, import_react4.useRef)();
  useIsomorphicLayoutEffect(function() {
    onChangeRef.current = onChange;
    if (nodeRef.current !== element) {
      setElement(nodeRef.current);
    }
  });
  useIsomorphicLayoutEffect(function() {
    if (element && !initialRectIsSet.current) {
      initialRectIsSet.current = true;
      setRect(element.getBoundingClientRect());
    }
  }, [element]);
  useIsomorphicLayoutEffect(function() {
    var observer;
    var elem = element;
    if (!initialRefIsSet.current) {
      initialRefIsSet.current = true;
      elem = nodeRef.current;
    }
    if (!elem) {
      if (true) {
        console.warn("You need to place the ref");
      }
      return cleanup;
    }
    observer = observe_rect_esm_default(elem, function(rect2) {
      onChangeRef.current && onChangeRef.current(rect2);
      setRect(rect2);
    });
    observe && observer.observe();
    return cleanup;
    function cleanup() {
      observer && observer.unobserve();
    }
  }, [observe, element]);
  return rect;
}

// ../../node_modules/@reach/menu-button/node_modules/@reach/popover/dist/popover.esm.js
var import_tabbable = __toESM(require_tabbable());
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var Popover = (0, import_react5.forwardRef)(function Popover2(props, ref) {
  return import_react5.default.createElement(portal_esm_default, null, import_react5.default.createElement(PopoverImpl, Object.assign({
    ref
  }, props)));
});
if (true) {
  Popover.displayName = "Popover";
}
var PopoverImpl = (0, import_react5.forwardRef)(function PopoverImpl2(_ref, forwardedRef) {
  var targetRef = _ref.targetRef, _ref$position = _ref.position, position = _ref$position === void 0 ? positionDefault : _ref$position, _ref$unstable_observa = _ref.unstable_observableRefs, unstable_observableRefs = _ref$unstable_observa === void 0 ? [] : _ref$unstable_observa, props = _objectWithoutPropertiesLoose(_ref, ["targetRef", "position", "unstable_observableRefs"]);
  var popoverRef = (0, import_react5.useRef)(null);
  var popoverRect = useRect(popoverRef, !props.hidden);
  var targetRect = useRect(targetRef, !props.hidden);
  var ref = useForkedRef(popoverRef, forwardedRef);
  useSimulateTabNavigationForReactTree(targetRef, popoverRef);
  return import_react5.default.createElement("div", Object.assign({
    "data-reach-popover": "",
    ref
  }, props, {
    style: _extends({
      position: "absolute"
    }, getStyles.apply(void 0, [position, targetRect, popoverRect].concat(unstable_observableRefs)), props.style)
  }));
});
if (true) {
  PopoverImpl.displayName = "PopoverImpl";
}
function getStyles(position, targetRect, popoverRect) {
  for (var _len = arguments.length, unstable_observableRefs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    unstable_observableRefs[_key - 3] = arguments[_key];
  }
  return popoverRect ? position.apply(void 0, [targetRect, popoverRect].concat(unstable_observableRefs.map(function(ref) {
    return ref.current;
  }))) : {
    visibility: "hidden"
  };
}
function getTopPosition(targetRect, popoverRect) {
  var _getCollisions = getCollisions(targetRect, popoverRect), directionUp = _getCollisions.directionUp;
  return {
    top: directionUp ? targetRect.top - popoverRect.height + window.pageYOffset + "px" : targetRect.top + targetRect.height + window.pageYOffset + "px"
  };
}
var positionDefault = function positionDefault2(targetRect, popoverRect) {
  if (!targetRect || !popoverRect) {
    return {};
  }
  var _getCollisions2 = getCollisions(targetRect, popoverRect), directionRight = _getCollisions2.directionRight;
  return _extends({
    left: directionRight ? targetRect.right - popoverRect.width + window.pageXOffset + "px" : targetRect.left + window.pageXOffset + "px"
  }, getTopPosition(targetRect, popoverRect));
};
function getCollisions(targetRect, popoverRect, offsetLeft, offsetBottom) {
  if (offsetLeft === void 0) {
    offsetLeft = 0;
  }
  if (offsetBottom === void 0) {
    offsetBottom = 0;
  }
  var collisions = {
    top: targetRect.top - popoverRect.height < 0,
    right: window.innerWidth < targetRect.left + popoverRect.width - offsetLeft,
    bottom: window.innerHeight < targetRect.bottom + popoverRect.height - offsetBottom,
    left: targetRect.left + targetRect.width - popoverRect.width < 0
  };
  var directionRight = collisions.right && !collisions.left;
  var directionLeft = collisions.left && !collisions.right;
  var directionUp = collisions.bottom && !collisions.top;
  var directionDown = collisions.top && !collisions.bottom;
  return {
    directionRight,
    directionLeft,
    directionUp,
    directionDown
  };
}
function useSimulateTabNavigationForReactTree(triggerRef, popoverRef) {
  var ownerDocument = getOwnerDocument(triggerRef.current);
  function handleKeyDown(event) {
    if (event.key === "Tab" && popoverRef.current && (0, import_tabbable.default)(popoverRef.current).length === 0) {
      return;
    }
    if (event.key === "Tab" && event.shiftKey) {
      if (shiftTabbedFromElementAfterTrigger(event)) {
        focusLastTabbableInPopover(event);
      } else if (shiftTabbedOutOfPopover(event)) {
        focusTriggerRef(event);
      } else if (shiftTabbedToBrowserChrome(event)) {
        disableTabbablesInPopover();
      }
    } else if (event.key === "Tab") {
      if (tabbedFromTriggerToPopover()) {
        focusFirstPopoverTabbable(event);
      } else if (tabbedOutOfPopover()) {
        focusTabbableAfterTrigger(event);
      } else if (tabbedToBrowserChrome(event)) {
        disableTabbablesInPopover();
      }
    }
  }
  (0, import_react5.useEffect)(function() {
    if (ownerDocument) {
      ownerDocument.addEventListener("keydown", handleKeyDown);
      return function() {
        ownerDocument.removeEventListener("keydown", handleKeyDown);
      };
    }
    return;
  }, []);
  function getElementAfterTrigger() {
    var elements = ownerDocument && (0, import_tabbable.default)(ownerDocument);
    var targetIndex = elements && triggerRef.current ? elements.indexOf(triggerRef.current) : -1;
    var elementAfterTrigger = elements && elements[targetIndex + 1];
    return popoverRef.current && popoverRef.current.contains(elementAfterTrigger || null) ? false : elementAfterTrigger;
  }
  function tabbedFromTriggerToPopover() {
    return triggerRef.current && ownerDocument ? triggerRef.current === ownerDocument.activeElement : false;
  }
  function focusFirstPopoverTabbable(event) {
    var elements = popoverRef.current && (0, import_tabbable.default)(popoverRef.current);
    if (elements && elements[0]) {
      event.preventDefault();
      elements[0].focus();
    }
  }
  function tabbedOutOfPopover() {
    var inPopover = popoverRef.current && ownerDocument ? popoverRef.current.contains(ownerDocument.activeElement || null) : false;
    if (inPopover) {
      var elements = popoverRef.current && (0, import_tabbable.default)(popoverRef.current);
      return Boolean(elements && ownerDocument && elements[elements.length - 1] === ownerDocument.activeElement);
    }
    return false;
  }
  function focusTabbableAfterTrigger(event) {
    var elementAfterTrigger = getElementAfterTrigger();
    if (elementAfterTrigger) {
      event.preventDefault();
      elementAfterTrigger.focus();
    }
  }
  function shiftTabbedFromElementAfterTrigger(event) {
    if (!event.shiftKey)
      return;
    var elementAfterTrigger = getElementAfterTrigger();
    return event.target === elementAfterTrigger;
  }
  function focusLastTabbableInPopover(event) {
    var elements = popoverRef.current && (0, import_tabbable.default)(popoverRef.current);
    var last = elements && elements[elements.length - 1];
    if (last) {
      event.preventDefault();
      last.focus();
    }
  }
  function shiftTabbedOutOfPopover(event) {
    var elements = popoverRef.current && (0, import_tabbable.default)(popoverRef.current);
    if (elements) {
      return elements.length === 0 ? false : event.target === elements[0];
    }
    return false;
  }
  function focusTriggerRef(event) {
    var _triggerRef$current;
    event.preventDefault();
    (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : _triggerRef$current.focus();
  }
  function tabbedToBrowserChrome(event) {
    var elements = ownerDocument && popoverRef.current ? (0, import_tabbable.default)(ownerDocument).filter(function(element) {
      return !popoverRef.current.contains(element);
    }) : null;
    return elements ? event.target === elements[elements.length - 1] : false;
  }
  function shiftTabbedToBrowserChrome(event) {
    return ownerDocument ? event.target === (0, import_tabbable.default)(ownerDocument)[0] : false;
  }
  var restoreTabIndexTuplés = [];
  function disableTabbablesInPopover() {
    var elements = popoverRef.current && (0, import_tabbable.default)(popoverRef.current);
    if (elements) {
      elements.forEach(function(element) {
        restoreTabIndexTuplés.push([element, element.tabIndex]);
        element.tabIndex = -1;
      });
      ownerDocument && ownerDocument.addEventListener("focusin", enableTabbablesInPopover);
    }
  }
  function enableTabbablesInPopover() {
    ownerDocument && ownerDocument.removeEventListener("focusin", enableTabbablesInPopover);
    restoreTabIndexTuplés.forEach(function(_ref2) {
      var element = _ref2[0], tabIndex = _ref2[1];
      element.tabIndex = tabIndex;
    });
  }
}
var popover_esm_default = Popover;

// ../../node_modules/@reach/menu-button/node_modules/@reach/descendants/dist/descendants.esm.js
var import_react6 = __toESM(require_react());
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function createDescendantContext(name, initialValue) {
  if (initialValue === void 0) {
    initialValue = {};
  }
  var descendants = [];
  return createNamedContext(name, _extends2({
    descendants,
    registerDescendant: noop,
    unregisterDescendant: noop
  }, initialValue));
}
function useDescendant(descendant, context, indexProp) {
  var forceUpdate = useForceUpdate();
  var _useContext = (0, import_react6.useContext)(context), registerDescendant = _useContext.registerDescendant, unregisterDescendant = _useContext.unregisterDescendant, descendants = _useContext.descendants;
  var index = indexProp !== null && indexProp !== void 0 ? indexProp : descendants.findIndex(function(item) {
    return item.element === descendant.element;
  });
  var previousDescendants = usePrevious(descendants);
  var someDescendantsHaveChanged = descendants.some(function(descendant2, index2) {
    var _previousDescendants$;
    return descendant2.element !== (previousDescendants === null || previousDescendants === void 0 ? void 0 : (_previousDescendants$ = previousDescendants[index2]) === null || _previousDescendants$ === void 0 ? void 0 : _previousDescendants$.element);
  });
  useIsomorphicLayoutEffect(function() {
    if (!descendant.element)
      forceUpdate();
    registerDescendant(_extends2({}, descendant, {
      index
    }));
    return function() {
      return unregisterDescendant(descendant.element);
    };
  }, [forceUpdate, index, registerDescendant, someDescendantsHaveChanged, unregisterDescendant].concat(Object.values(descendant)));
  return index;
}
function useDescendantsInit() {
  return (0, import_react6.useState)([]);
}
function useDescendants(ctx) {
  return (0, import_react6.useContext)(ctx).descendants;
}
function DescendantProvider(_ref) {
  var Ctx = _ref.context, children = _ref.children, items = _ref.items, set = _ref.set;
  var registerDescendant = (0, import_react6.useCallback)(
    function(_ref2) {
      var element = _ref2.element, explicitIndex = _ref2.index, rest = _objectWithoutPropertiesLoose2(_ref2, ["element", "index"]);
      if (!element) {
        return;
      }
      set(function(items2) {
        var newItems;
        if (explicitIndex != null) {
          newItems = [].concat(items2, [_extends2({}, rest, {
            element,
            index: explicitIndex
          })]);
        } else if (items2.length === 0) {
          newItems = [].concat(items2, [_extends2({}, rest, {
            element,
            index: 0
          })]);
        } else if (items2.find(function(item) {
          return item.element === element;
        })) {
          newItems = items2;
        } else {
          var index = items2.findIndex(function(item) {
            if (!item.element || !element) {
              return false;
            }
            return Boolean(item.element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING);
          });
          var newItem = _extends2({}, rest, {
            element,
            index
          });
          if (index === -1) {
            newItems = [].concat(items2, [newItem]);
          } else {
            newItems = [].concat(items2.slice(0, index), [newItem], items2.slice(index));
          }
        }
        return newItems.map(function(item, index2) {
          return _extends2({}, item, {
            index: index2
          });
        });
      });
    },
    // set is a state setter initialized by the useDescendants hook.
    // We can safely ignore the lint warning here because it will not change
    // between renders.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  var unregisterDescendant = (0, import_react6.useCallback)(
    function(element) {
      if (!element) {
        return;
      }
      set(function(items2) {
        return items2.filter(function(item) {
          return element !== item.element;
        });
      });
    },
    // set is a state setter initialized by the useDescendants hook.
    // We can safely ignore the lint warning here because it will not change
    // between renders.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  return import_react6.default.createElement(Ctx.Provider, {
    value: (0, import_react6.useMemo)(function() {
      return {
        descendants: items,
        registerDescendant,
        unregisterDescendant
      };
    }, [items, registerDescendant, unregisterDescendant])
  }, children);
}
function useDescendantKeyDown(context, options) {
  var _useContext2 = (0, import_react6.useContext)(context), descendants = _useContext2.descendants;
  var callback = options.callback, currentIndex = options.currentIndex, filter = options.filter, _options$key = options.key, key = _options$key === void 0 ? "index" : _options$key, _options$orientation = options.orientation, orientation = _options$orientation === void 0 ? "vertical" : _options$orientation, _options$rotate = options.rotate, rotate = _options$rotate === void 0 ? true : _options$rotate, _options$rtl = options.rtl, rtl = _options$rtl === void 0 ? false : _options$rtl;
  var index = currentIndex !== null && currentIndex !== void 0 ? currentIndex : -1;
  return function handleKeyDown(event) {
    if (!["ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight", "PageUp", "PageDown", "Home", "End"].includes(event.key)) {
      return;
    }
    var selectableDescendants = filter ? descendants.filter(filter) : descendants;
    if (filter) {
      index = selectableDescendants.findIndex(function(descendant) {
        return descendant.index === currentIndex;
      });
    }
    if (!selectableDescendants.length) {
      return;
    }
    function getNextOption() {
      var atBottom = index === selectableDescendants.length - 1;
      return atBottom ? rotate ? getFirstOption() : selectableDescendants[index] : selectableDescendants[(index + 1) % selectableDescendants.length];
    }
    function getPreviousOption() {
      var atTop = index === 0;
      return atTop ? rotate ? getLastOption() : selectableDescendants[index] : selectableDescendants[(index - 1 + selectableDescendants.length) % selectableDescendants.length];
    }
    function getFirstOption() {
      return selectableDescendants[0];
    }
    function getLastOption() {
      return selectableDescendants[selectableDescendants.length - 1];
    }
    switch (event.key) {
      case "ArrowDown":
        if (orientation === "vertical" || orientation === "both") {
          event.preventDefault();
          var next = getNextOption();
          callback(key === "option" ? next : next[key]);
        }
        break;
      case "ArrowUp":
        if (orientation === "vertical" || orientation === "both") {
          event.preventDefault();
          var prev = getPreviousOption();
          callback(key === "option" ? prev : prev[key]);
        }
        break;
      case "ArrowLeft":
        if (orientation === "horizontal" || orientation === "both") {
          event.preventDefault();
          var nextOrPrev = (rtl ? getNextOption : getPreviousOption)();
          callback(key === "option" ? nextOrPrev : nextOrPrev[key]);
        }
        break;
      case "ArrowRight":
        if (orientation === "horizontal" || orientation === "both") {
          event.preventDefault();
          var prevOrNext = (rtl ? getPreviousOption : getNextOption)();
          callback(key === "option" ? prevOrNext : prevOrNext[key]);
        }
        break;
      case "PageUp":
        event.preventDefault();
        var prevOrFirst = (event.ctrlKey ? getPreviousOption : getFirstOption)();
        callback(key === "option" ? prevOrFirst : prevOrFirst[key]);
        break;
      case "Home":
        event.preventDefault();
        var first = getFirstOption();
        callback(key === "option" ? first : first[key]);
        break;
      case "PageDown":
        event.preventDefault();
        var nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();
        callback(key === "option" ? nextOrLast : nextOrLast[key]);
        break;
      case "End":
        event.preventDefault();
        var last = getLastOption();
        callback(key === "option" ? last : last[key]);
        break;
    }
  };
}

// ../../node_modules/@reach/menu-button/dist/menu-button.esm.js
function _extends3() {
  _extends3 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}
function _objectWithoutPropertiesLoose3(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var CLEAR_SELECTION_INDEX = "CLEAR_SELECTION_INDEX";
var CLICK_MENU_ITEM = "CLICK_MENU_ITEM";
var CLOSE_MENU = "CLOSE_MENU";
var OPEN_MENU_AT_FIRST_ITEM = "OPEN_MENU_AT_FIRST_ITEM";
var OPEN_MENU_AT_INDEX = "OPEN_MENU_AT_INDEX";
var OPEN_MENU_CLEARED = "OPEN_MENU_CLEARED";
var SEARCH_FOR_ITEM = "SEARCH_FOR_ITEM";
var SELECT_ITEM_AT_INDEX = "SELECT_ITEM_AT_INDEX";
var SET_BUTTON_ID = "SET_BUTTON_ID";
var MenuDescendantContext = createDescendantContext("MenuDescendantContext");
var MenuContext = createNamedContext("MenuContext", {});
var initialState = {
  // The button ID is needed for aria controls and can be set directly and
  // updated for top-level use via context. Otherwise a default is set by useId.
  // TODO: Consider deprecating direct ID in 1.0 in favor of id at the top level
  //       for passing deterministic IDs to descendent components.
  buttonId: null,
  // Whether or not the menu is expanded
  isExpanded: false,
  // When a user begins typing a character string, the selection will change if
  // a matching item is found
  typeaheadQuery: "",
  // The index of the current selected item. When the selection is cleared a
  // value of -1 is used.
  selectionIndex: -1
};
var Menu = function Menu2(_ref) {
  var id2 = _ref.id, children = _ref.children;
  var buttonRef = (0, import_react7.useRef)(null);
  var menuRef = (0, import_react7.useRef)(null);
  var popoverRef = (0, import_react7.useRef)(null);
  var _useDescendantsInit = useDescendantsInit(), descendants = _useDescendantsInit[0], setDescendants = _useDescendantsInit[1];
  var _useReducer = (0, import_react7.useReducer)(reducer, initialState), state = _useReducer[0], dispatch = _useReducer[1];
  var _id = useId(id2);
  var menuId = id2 || makeId("menu", _id);
  var buttonClickedRef = (0, import_react7.useRef)(false);
  var selectCallbacks = (0, import_react7.useRef)([]);
  var readyToSelect = (0, import_react7.useRef)(false);
  var context = {
    buttonRef,
    dispatch,
    menuId,
    menuRef,
    popoverRef,
    buttonClickedRef,
    readyToSelect,
    selectCallbacks,
    state
  };
  (0, import_react7.useEffect)(function() {
    if (state.isExpanded) {
      window.__REACH_DISABLE_TOOLTIPS = true;
      window.requestAnimationFrame(function() {
        focus(menuRef.current);
      });
    } else {
      window.__REACH_DISABLE_TOOLTIPS = false;
    }
  }, [state.isExpanded]);
  (0, import_react7.useEffect)(function() {
    return checkStyles("menu-button");
  }, []);
  return import_react7.default.createElement(DescendantProvider, {
    context: MenuDescendantContext,
    items: descendants,
    set: setDescendants
  }, import_react7.default.createElement(MenuContext.Provider, {
    value: context
  }, isFunction(children) ? children({
    isExpanded: state.isExpanded,
    // TODO: Remove in 1.0
    isOpen: state.isExpanded
  }) : children));
};
if (true) {
  Menu.displayName = "Menu";
  Menu.propTypes = {
    children: import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.node])
  };
}
var MenuButton = forwardRefWithAs(function MenuButton2(_ref2, forwardedRef) {
  var _ref2$as = _ref2.as, Comp = _ref2$as === void 0 ? "button" : _ref2$as, onKeyDown = _ref2.onKeyDown, onMouseDown = _ref2.onMouseDown, id2 = _ref2.id, props = _objectWithoutPropertiesLoose3(_ref2, ["as", "onKeyDown", "onMouseDown", "id"]);
  var _useContext = (0, import_react7.useContext)(MenuContext), buttonRef = _useContext.buttonRef, buttonClickedRef = _useContext.buttonClickedRef, menuId = _useContext.menuId, _useContext$state = _useContext.state, buttonId = _useContext$state.buttonId, isExpanded = _useContext$state.isExpanded, dispatch = _useContext.dispatch;
  var ref = useForkedRef(buttonRef, forwardedRef);
  var items = useDescendants(MenuDescendantContext);
  var firstNonDisabledIndex = (0, import_react7.useMemo)(function() {
    return items.findIndex(function(item) {
      return !item.disabled;
    });
  }, [items]);
  (0, import_react7.useEffect)(function() {
    var newButtonId = id2 != null ? id2 : menuId ? makeId("menu-button", menuId) : "menu-button";
    if (buttonId !== newButtonId) {
      dispatch({
        type: SET_BUTTON_ID,
        payload: newButtonId
      });
    }
  }, [buttonId, dispatch, id2, menuId]);
  function handleKeyDown(event) {
    switch (event.key) {
      case "ArrowDown":
      case "ArrowUp":
        event.preventDefault();
        dispatch({
          type: OPEN_MENU_AT_INDEX,
          payload: {
            index: firstNonDisabledIndex
          }
        });
        break;
      case "Enter":
      case " ":
        dispatch({
          type: OPEN_MENU_AT_INDEX,
          payload: {
            index: firstNonDisabledIndex
          }
        });
        break;
    }
  }
  function handleMouseDown(event) {
    if (!isExpanded) {
      buttonClickedRef.current = true;
    }
    if (isRightClick(event.nativeEvent)) {
      return;
    } else if (isExpanded) {
      dispatch({
        type: CLOSE_MENU,
        payload: {
          buttonRef
        }
      });
    } else {
      dispatch({
        type: OPEN_MENU_CLEARED
      });
    }
  }
  return import_react7.default.createElement(
    Comp,
    Object.assign({
      "aria-expanded": isExpanded ? true : void 0,
      "aria-haspopup": true,
      "aria-controls": menuId
    }, props, {
      ref,
      "data-reach-menu-button": "",
      id: buttonId || void 0,
      onKeyDown: wrapEvent(onKeyDown, handleKeyDown),
      onMouseDown: wrapEvent(onMouseDown, handleMouseDown),
      type: "button"
    })
  );
});
if (true) {
  MenuButton.displayName = "MenuButton";
  MenuButton.propTypes = {
    children: import_prop_types2.default.node
  };
}
var MenuItemImpl = forwardRefWithAs(function MenuItemImpl2(_ref3, forwardedRef) {
  var Comp = _ref3.as, indexProp = _ref3.index, _ref3$isLink = _ref3.isLink, isLink = _ref3$isLink === void 0 ? false : _ref3$isLink, onClick = _ref3.onClick, onDragStart = _ref3.onDragStart, onMouseDown = _ref3.onMouseDown, onMouseEnter = _ref3.onMouseEnter, onMouseLeave = _ref3.onMouseLeave, onMouseMove = _ref3.onMouseMove, onMouseUp = _ref3.onMouseUp, onSelect = _ref3.onSelect, disabled = _ref3.disabled, valueTextProp = _ref3.valueText, props = _objectWithoutPropertiesLoose3(_ref3, ["as", "index", "isLink", "onClick", "onDragStart", "onMouseDown", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseUp", "onSelect", "disabled", "valueText"]);
  var _useContext2 = (0, import_react7.useContext)(MenuContext), buttonRef = _useContext2.buttonRef, dispatch = _useContext2.dispatch, readyToSelect = _useContext2.readyToSelect, selectCallbacks = _useContext2.selectCallbacks, _useContext2$state = _useContext2.state, selectionIndex = _useContext2$state.selectionIndex, isExpanded = _useContext2$state.isExpanded;
  var ownRef = (0, import_react7.useRef)(null);
  var _useState = (0, import_react7.useState)(valueTextProp || ""), valueText = _useState[0], setValueText = _useState[1];
  var setValueTextFromDom = (0, import_react7.useCallback)(function(node) {
    if (node) {
      ownRef.current = node;
      if (!valueTextProp || node.textContent && valueText !== node.textContent) {
        setValueText(node.textContent);
      }
    }
  }, [valueText, valueTextProp]);
  var ref = useForkedRef(forwardedRef, setValueTextFromDom);
  var mouseEventStarted = (0, import_react7.useRef)(false);
  var index = useDescendant({
    element: ownRef.current,
    key: valueText,
    disabled,
    isLink
  }, MenuDescendantContext, indexProp);
  var isSelected = index === selectionIndex && !disabled;
  selectCallbacks.current[index] = onSelect;
  function select() {
    focus(buttonRef.current);
    onSelect && onSelect();
    dispatch({
      type: CLICK_MENU_ITEM
    });
  }
  function handleClick(event) {
    if (isLink && !isRightClick(event.nativeEvent)) {
      if (disabled) {
        event.preventDefault();
      } else {
        select();
      }
    }
  }
  function handleDragStart(event) {
    if (isLink) {
      event.preventDefault();
    }
  }
  function handleMouseDown(event) {
    if (isRightClick(event.nativeEvent))
      return;
    if (isLink) {
      mouseEventStarted.current = true;
    } else {
      event.preventDefault();
    }
  }
  function handleMouseEnter(event) {
    if (!isSelected && index != null && !disabled) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index
        }
      });
    }
  }
  function handleMouseLeave(event) {
    dispatch({
      type: CLEAR_SELECTION_INDEX
    });
  }
  function handleMouseMove() {
    readyToSelect.current = true;
    if (!isSelected && index != null && !disabled) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index
        }
      });
    }
  }
  function handleMouseUp(event) {
    if (!readyToSelect.current) {
      readyToSelect.current = true;
      return;
    }
    if (isRightClick(event.nativeEvent))
      return;
    if (isLink) {
      if (mouseEventStarted.current) {
        mouseEventStarted.current = false;
      } else if (ownRef.current) {
        ownRef.current.click();
      }
    } else {
      if (!disabled) {
        select();
      }
    }
  }
  (0, import_react7.useEffect)(function() {
    if (!isExpanded) {
      readyToSelect.current = false;
    }
  }, [isExpanded, readyToSelect]);
  (0, import_react7.useEffect)(function() {
    var ownerDocument = getOwnerDocument(ownRef.current) || document;
    var listener = function listener2() {
      return mouseEventStarted.current = false;
    };
    ownerDocument.addEventListener("mouseup", listener);
    return function() {
      return ownerDocument.removeEventListener("mouseup", listener);
    };
  }, []);
  return import_react7.default.createElement(Comp, Object.assign({
    role: "menuitem",
    id: useMenuItemId(index),
    tabIndex: -1
  }, props, {
    ref,
    "aria-disabled": disabled || void 0,
    "data-reach-menu-item": "",
    "data-selected": isSelected ? "" : void 0,
    "data-valuetext": valueText,
    onClick: wrapEvent(onClick, handleClick),
    onDragStart: wrapEvent(onDragStart, handleDragStart),
    onMouseDown: wrapEvent(onMouseDown, handleMouseDown),
    onMouseEnter: wrapEvent(onMouseEnter, handleMouseEnter),
    onMouseLeave: wrapEvent(onMouseLeave, handleMouseLeave),
    onMouseMove: wrapEvent(onMouseMove, handleMouseMove),
    onMouseUp: wrapEvent(onMouseUp, handleMouseUp)
  }));
});
var MenuItem = forwardRefWithAs(function MenuItem2(_ref4, forwardedRef) {
  var _ref4$as = _ref4.as, as = _ref4$as === void 0 ? "div" : _ref4$as, props = _objectWithoutPropertiesLoose3(_ref4, ["as"]);
  return import_react7.default.createElement(MenuItemImpl, Object.assign({}, props, {
    ref: forwardedRef,
    as
  }));
});
if (true) {
  MenuItem.displayName = "MenuItem";
  MenuItem.propTypes = {
    as: import_prop_types2.default.any,
    onSelect: import_prop_types2.default.func.isRequired
  };
}
var MenuItems = forwardRefWithAs(function MenuItems2(_ref5, forwardedRef) {
  var _ref5$as = _ref5.as, Comp = _ref5$as === void 0 ? "div" : _ref5$as, children = _ref5.children, id2 = _ref5.id, onKeyDown = _ref5.onKeyDown, props = _objectWithoutPropertiesLoose3(_ref5, ["as", "children", "id", "onKeyDown"]);
  var _useContext3 = (0, import_react7.useContext)(MenuContext), menuId = _useContext3.menuId, dispatch = _useContext3.dispatch, buttonRef = _useContext3.buttonRef, menuRef = _useContext3.menuRef, selectCallbacks = _useContext3.selectCallbacks, _useContext3$state = _useContext3.state, isExpanded = _useContext3$state.isExpanded, buttonId = _useContext3$state.buttonId, selectionIndex = _useContext3$state.selectionIndex, typeaheadQuery = _useContext3$state.typeaheadQuery;
  var menuItems = useDescendants(MenuDescendantContext);
  var ref = useForkedRef(menuRef, forwardedRef);
  (0, import_react7.useEffect)(function() {
    var match = findItemFromTypeahead(menuItems, typeaheadQuery);
    if (typeaheadQuery && match != null) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index: match
        }
      });
    }
    var timeout = window.setTimeout(function() {
      return typeaheadQuery && dispatch({
        type: SEARCH_FOR_ITEM,
        payload: ""
      });
    }, 1e3);
    return function() {
      return window.clearTimeout(timeout);
    };
  }, [dispatch, menuItems, typeaheadQuery]);
  var prevMenuItemsLength = usePrevious(menuItems.length);
  var prevSelected = usePrevious(menuItems[selectionIndex]);
  var prevSelectionIndex = usePrevious(selectionIndex);
  (0, import_react7.useEffect)(function() {
    if (selectionIndex > menuItems.length - 1) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index: menuItems.length - 1
        }
      });
    } else if (
      // Checks if
      //  - menu length has changed
      //  - selection index has not changed BUT selected item has changed
      //
      // This prevents any dynamic adding/removing of menu items from actually
      // changing a user's expected selection.
      prevMenuItemsLength !== menuItems.length && selectionIndex > -1 && prevSelected && prevSelectionIndex === selectionIndex && menuItems[selectionIndex] !== prevSelected
    ) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index: menuItems.findIndex(function(i) {
            return i.key === prevSelected.key;
          })
        }
      });
    }
  }, [dispatch, menuItems, prevMenuItemsLength, prevSelected, prevSelectionIndex, selectionIndex]);
  var handleKeyDown = wrapEvent(function handleKeyDown2(event) {
    var key = event.key;
    if (!isExpanded) {
      return;
    }
    switch (key) {
      case "Enter":
      case " ":
        var selected = menuItems.find(function(item) {
          return item.index === selectionIndex;
        });
        if (selected) {
          if (selected.isLink && selected.element) {
            selected.element.click();
          } else {
            event.preventDefault();
            focus(buttonRef.current);
            selectCallbacks.current[selected.index] && selectCallbacks.current[selected.index]();
            dispatch({
              type: CLICK_MENU_ITEM
            });
          }
        }
        break;
      case "Escape":
        focus(buttonRef.current);
        dispatch({
          type: CLOSE_MENU,
          payload: {
            buttonRef
          }
        });
        break;
      case "Tab":
        event.preventDefault();
        break;
      default:
        if (isString(key) && key.length === 1) {
          var query = typeaheadQuery + key.toLowerCase();
          dispatch({
            type: SEARCH_FOR_ITEM,
            payload: query
          });
        }
        break;
    }
  }, useDescendantKeyDown(MenuDescendantContext, {
    currentIndex: selectionIndex,
    orientation: "vertical",
    rotate: false,
    filter: function filter(item) {
      return !item.disabled;
    },
    callback: function callback(index) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index
        }
      });
    },
    key: "index"
  }));
  return (
    // TODO: Should probably file a but in jsx-a11y, but this is correct
    // according to https://www.w3.org/TR/wai-aria-practices-1.2/examples/menu-button/menu-button-actions-active-descendant.html
    // eslint-disable-next-line jsx-a11y/aria-activedescendant-has-tabindex
    import_react7.default.createElement(
      Comp,
      Object.assign({
        "aria-activedescendant": useMenuItemId(selectionIndex) || void 0,
        "aria-labelledby": buttonId || void 0,
        // The element that contains the menu items displayed by activating the
        // button has role menu.
        // https://www.w3.org/TR/wai-aria-practices-1.2/#menubutton
        role: "menu",
        tabIndex: -1
      }, props, {
        ref,
        "data-reach-menu-items": "",
        id: menuId,
        onKeyDown: wrapEvent(onKeyDown, handleKeyDown)
      }),
      children
    )
  );
});
if (true) {
  MenuItems.displayName = "MenuItems";
  MenuItems.propTypes = {
    children: import_prop_types2.default.node
  };
}
var MenuLink = forwardRefWithAs(function MenuLink2(_ref6, forwardedRef) {
  var _ref6$as = _ref6.as, as = _ref6$as === void 0 ? "a" : _ref6$as, component = _ref6.component, onSelect = _ref6.onSelect, props = _objectWithoutPropertiesLoose3(_ref6, ["as", "component", "onSelect"]);
  if (component) {
    console.warn("[@reach/menu-button]: Please use the `as` prop instead of `component`.");
  }
  return import_react7.default.createElement("div", {
    role: "none",
    tabIndex: -1
  }, import_react7.default.createElement(MenuItemImpl, Object.assign({}, props, {
    ref: forwardedRef,
    "data-reach-menu-link": "",
    as,
    isLink: true,
    onSelect: onSelect || noop
  })));
});
if (true) {
  MenuLink.displayName = "MenuLink";
  MenuLink.propTypes = {
    as: import_prop_types2.default.any,
    component: import_prop_types2.default.any
  };
}
var MenuList = (0, import_react7.forwardRef)(function MenuList2(_ref7, forwardedRef) {
  var _ref7$portal = _ref7.portal, portal = _ref7$portal === void 0 ? true : _ref7$portal, props = _objectWithoutPropertiesLoose3(_ref7, ["portal"]);
  return import_react7.default.createElement(MenuPopover, {
    portal
  }, import_react7.default.createElement(MenuItems, Object.assign({}, props, {
    ref: forwardedRef,
    "data-reach-menu-list": ""
  })));
});
if (true) {
  MenuList.displayName = "MenuList";
  MenuList.propTypes = {
    children: import_prop_types2.default.node.isRequired
  };
}
var MenuPopover = (0, import_react7.forwardRef)(function MenuPopover2(_ref8, forwardedRef) {
  var children = _ref8.children, _ref8$portal = _ref8.portal, portal = _ref8$portal === void 0 ? true : _ref8$portal, position = _ref8.position, props = _objectWithoutPropertiesLoose3(_ref8, ["children", "portal", "position"]);
  var _useContext4 = (0, import_react7.useContext)(MenuContext), buttonRef = _useContext4.buttonRef, buttonClickedRef = _useContext4.buttonClickedRef, dispatch = _useContext4.dispatch, menuRef = _useContext4.menuRef, popoverRef = _useContext4.popoverRef, isExpanded = _useContext4.state.isExpanded;
  var ref = useForkedRef(popoverRef, forwardedRef);
  (0, import_react7.useEffect)(function() {
    function listener(event) {
      if (buttonClickedRef.current) {
        buttonClickedRef.current = false;
      } else {
        if (isExpanded && popoverRef.current) {
          if (!popoverRef.current.contains(event.target)) {
            dispatch({
              type: CLOSE_MENU,
              payload: {
                buttonRef
              }
            });
          }
        }
      }
    }
    window.addEventListener("mousedown", listener);
    return function() {
      window.removeEventListener("mousedown", listener);
    };
  }, [buttonClickedRef, buttonRef, dispatch, isExpanded, menuRef, popoverRef]);
  var commonProps = _extends3({
    ref,
    // TODO: remove in 1.0
    "data-reach-menu": "",
    "data-reach-menu-popover": "",
    hidden: !isExpanded,
    children
  }, props);
  return portal ? import_react7.default.createElement(popover_esm_default, Object.assign({}, commonProps, {
    targetRef: buttonRef,
    position
  })) : import_react7.default.createElement("div", Object.assign({}, commonProps));
});
if (true) {
  MenuPopover.displayName = "MenuPopover";
  MenuPopover.propTypes = {
    children: import_prop_types2.default.node
  };
}
function useMenuButtonContext() {
  var _useContext5 = (0, import_react7.useContext)(MenuContext), isExpanded = _useContext5.state.isExpanded;
  return (0, import_react7.useMemo)(function() {
    return {
      isExpanded
    };
  }, [isExpanded]);
}
function findItemFromTypeahead(items, string) {
  if (string === void 0) {
    string = "";
  }
  if (!string) {
    return null;
  }
  var found = items.find(function(item) {
    var _item$element, _item$element$dataset, _item$element$dataset2;
    return item.disabled ? false : (_item$element = item.element) === null || _item$element === void 0 ? void 0 : (_item$element$dataset = _item$element.dataset) === null || _item$element$dataset === void 0 ? void 0 : (_item$element$dataset2 = _item$element$dataset.valuetext) === null || _item$element$dataset2 === void 0 ? void 0 : _item$element$dataset2.toLowerCase().startsWith(string);
  });
  return found ? items.indexOf(found) : null;
}
function useMenuItemId(index) {
  var _useContext6 = (0, import_react7.useContext)(MenuContext), menuId = _useContext6.menuId;
  return index != null && index > -1 ? makeId("option-" + index, menuId) : void 0;
}
function isRightClick(nativeEvent) {
  return nativeEvent.which === 3 || nativeEvent.button === 2;
}
function focus(element) {
  element && element.focus();
}
function reducer(state, action) {
  if (action === void 0) {
    action = {};
  }
  switch (action.type) {
    case CLICK_MENU_ITEM:
      return _extends3({}, state, {
        isExpanded: false,
        selectionIndex: -1
      });
    case CLOSE_MENU:
      return _extends3({}, state, {
        isExpanded: false,
        selectionIndex: -1
      });
    case OPEN_MENU_AT_FIRST_ITEM:
      return _extends3({}, state, {
        isExpanded: true,
        selectionIndex: 0
      });
    case OPEN_MENU_AT_INDEX:
      return _extends3({}, state, {
        isExpanded: true,
        selectionIndex: action.payload.index
      });
    case OPEN_MENU_CLEARED:
      return _extends3({}, state, {
        isExpanded: true,
        selectionIndex: -1
      });
    case SELECT_ITEM_AT_INDEX:
      if (action.payload.index >= 0) {
        return _extends3({}, state, {
          selectionIndex: action.payload.max != null ? Math.min(Math.max(action.payload.index, 0), action.payload.max) : Math.max(action.payload.index, 0)
        });
      }
      return state;
    case CLEAR_SELECTION_INDEX:
      return _extends3({}, state, {
        selectionIndex: -1
      });
    case SET_BUTTON_ID:
      return _extends3({}, state, {
        buttonId: action.payload
      });
    case SEARCH_FOR_ITEM:
      if (typeof action.payload !== "undefined") {
        return _extends3({}, state, {
          typeaheadQuery: action.payload
        });
      }
      return state;
    default:
      return state;
  }
}
export {
  Menu,
  MenuButton,
  MenuItem,
  MenuItems,
  MenuLink,
  MenuList,
  MenuPopover,
  useMenuButtonContext
};
//# sourceMappingURL=@reach_menu-button.js.map
