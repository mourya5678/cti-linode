{"version":3,"file":"ldclient-common.cjs.js","sources":["../src/errors.js","../node_modules/base64-js/index.js","../node_modules/fast-deep-equal/index.js","../src/utils.js","../node_modules/uuid/lib/bytesToUuid.js","../node_modules/uuid/lib/rng-browser.js","../node_modules/uuid/v1.js","../src/loggers.js","../src/messages.js","../src/configuration.js","../src/headers.js","../src/EventSender.js","../src/EventSummarizer.js","../src/UserFilter.js","../src/EventProcessor.js","../src/EventEmitter.js","../src/InitializationState.js","../src/PersistentFlagStore.js","../src/PersistentStorage.js","../src/Stream.js","../src/promiseCoalescer.js","../src/Requestor.js","../src/Identity.js","../src/UserValidator.js","../src/diagnosticEvents.js","../src/SafeInspector.js","../src/InspectorManager.js","../src/index.js"],"sourcesContent":["function createCustomError(name) {\n  function CustomError(message, code) {\n    Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);\n    this.message = message;\n    this.code = code;\n  }\n\n  CustomError.prototype = new Error();\n  CustomError.prototype.name = name;\n  CustomError.prototype.constructor = CustomError;\n\n  return CustomError;\n}\n\nexport const LDUnexpectedResponseError = createCustomError('LaunchDarklyUnexpectedResponseError');\nexport const LDInvalidEnvironmentIdError = createCustomError('LaunchDarklyInvalidEnvironmentIdError');\nexport const LDInvalidUserError = createCustomError('LaunchDarklyInvalidUserError');\nexport const LDInvalidEventKeyError = createCustomError('LaunchDarklyInvalidEventKeyError');\nexport const LDInvalidArgumentError = createCustomError('LaunchDarklyInvalidArgumentError');\nexport const LDFlagFetchError = createCustomError('LaunchDarklyFlagFetchError');\nexport const LDInvalidDataError = createCustomError('LaunchDarklyInvalidDataError');\n\nexport function isHttpErrorRecoverable(status) {\n  if (status >= 400 && status < 500) {\n    return status === 400 || status === 408 || status === 429;\n  }\n  return true;\n}\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","'use strict';\n\nvar isArray = Array.isArray;\nvar keyList = Object.keys;\nvar hasProp = Object.prototype.hasOwnProperty;\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var arrA = isArray(a)\n      , arrB = isArray(b)\n      , i\n      , length\n      , key;\n\n    if (arrA && arrB) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n    if (arrA != arrB) return false;\n\n    var dateA = a instanceof Date\n      , dateB = b instanceof Date;\n    if (dateA != dateB) return false;\n    if (dateA && dateB) return a.getTime() == b.getTime();\n\n    var regexpA = a instanceof RegExp\n      , regexpB = b instanceof RegExp;\n    if (regexpA != regexpB) return false;\n    if (regexpA && regexpB) return a.toString() == b.toString();\n\n    var keys = keyList(a);\n    length = keys.length;\n\n    if (length !== keyList(b).length)\n      return false;\n\n    for (i = length; i-- !== 0;)\n      if (!hasProp.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      key = keys[i];\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  return a!==a && b!==b;\n};\n","import * as base64 from 'base64-js';\nimport fastDeepEqual from 'fast-deep-equal';\n\nconst userAttrsToStringify = ['key', 'secondary', 'ip', 'country', 'email', 'firstName', 'lastName', 'avatar', 'name'];\n\nexport function appendUrlPath(baseUrl, path) {\n  // Ensure that URL concatenation is done correctly regardless of whether the\n  // base URL has a trailing slash or not.\n  const trimBaseUrl = baseUrl.endsWith('/') ? baseUrl.substring(0, baseUrl.length - 1) : baseUrl;\n  return trimBaseUrl + (path.startsWith('/') ? '' : '/') + path;\n}\n\n// See http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html\nexport function btoa(s) {\n  const escaped = unescape(encodeURIComponent(s));\n  return base64.fromByteArray(stringToBytes(escaped));\n}\n\nfunction stringToBytes(s) {\n  const b = [];\n  for (let i = 0; i < s.length; i++) {\n    b.push(s.charCodeAt(i));\n  }\n  return b;\n}\n\nexport function base64URLEncode(s) {\n  return (\n    btoa(s)\n      // eslint-disable-next-line\n      .replace(/=/g, '')\n      .replace(/\\+/g, '-')\n      .replace(/\\//g, '_')\n  );\n}\n\nexport function clone(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nexport function deepEquals(a, b) {\n  return fastDeepEqual(a, b);\n}\n\n// Events emitted in LDClient's initialize method will happen before the consumer\n// can register a listener, so defer them to next tick.\nexport function onNextTick(cb) {\n  setTimeout(cb, 0);\n}\n\n/**\n * Wrap a promise to invoke an optional callback upon resolution or rejection.\n *\n * This function assumes the callback follows the Node.js callback type: (err, value) => void\n *\n * If a callback is provided:\n *   - if the promise is resolved, invoke the callback with (null, value)\n *   - if the promise is rejected, invoke the callback with (error, null)\n *\n * @param {Promise<any>} promise\n * @param {Function} callback\n * @returns Promise<any> | undefined\n */\nexport function wrapPromiseCallback(promise, callback) {\n  const ret = promise.then(\n    value => {\n      if (callback) {\n        setTimeout(() => {\n          callback(null, value);\n        }, 0);\n      }\n      return value;\n    },\n    error => {\n      if (callback) {\n        setTimeout(() => {\n          callback(error, null);\n        }, 0);\n      } else {\n        return Promise.reject(error);\n      }\n    }\n  );\n\n  return !callback ? ret : undefined;\n}\n\n/**\n * Takes a map of flag keys to values, and returns the more verbose structure used by the\n * client stream.\n */\nexport function transformValuesToVersionedValues(flags) {\n  const ret = {};\n  for (const key in flags) {\n    if (objectHasOwnProperty(flags, key)) {\n      ret[key] = { value: flags[key], version: 0 };\n    }\n  }\n  return ret;\n}\n\n/**\n * Converts the internal flag state map to a simple map of flag keys to values.\n */\nexport function transformVersionedValuesToValues(flagsState) {\n  const ret = {};\n  for (const key in flagsState) {\n    if (objectHasOwnProperty(flagsState, key)) {\n      ret[key] = flagsState[key].value;\n    }\n  }\n  return ret;\n}\n\n/**\n * Returns an array of event groups each of which can be safely URL-encoded\n * without hitting the safe maximum URL length of certain browsers.\n *\n * @param {number} maxLength maximum URL length targeted\n * @param {Array[Object}]} events queue of events to divide\n * @returns Array[Array[Object]]\n */\nexport function chunkUserEventsForUrl(maxLength, events) {\n  const allEvents = events.slice(0);\n  const allChunks = [];\n  let remainingSpace = maxLength;\n  let chunk;\n\n  while (allEvents.length > 0) {\n    chunk = [];\n\n    while (remainingSpace > 0) {\n      const event = allEvents.shift();\n      if (!event) {\n        break;\n      }\n      remainingSpace = remainingSpace - base64URLEncode(JSON.stringify(event)).length;\n      // If we are over the max size, put this one back on the queue\n      // to try in the next round, unless this event alone is larger\n      // than the limit, in which case, screw it, and try it anyway.\n      if (remainingSpace < 0 && chunk.length > 0) {\n        allEvents.unshift(event);\n      } else {\n        chunk.push(event);\n      }\n    }\n\n    remainingSpace = maxLength;\n    allChunks.push(chunk);\n  }\n\n  return allChunks;\n}\n\nexport function getLDUserAgentString(platform) {\n  const version = platform.version || VERSION;\n  return platform.userAgent + '/' + version;\n}\n\nexport function extend(...objects) {\n  return objects.reduce((acc, obj) => ({ ...acc, ...obj }), {});\n}\n\nexport function objectHasOwnProperty(object, name) {\n  return Object.prototype.hasOwnProperty.call(object, name);\n}\n\nexport function sanitizeUser(user) {\n  if (!user) {\n    return user;\n  }\n  let newUser;\n  for (const i in userAttrsToStringify) {\n    const attr = userAttrsToStringify[i];\n    const value = user[attr];\n    if (value !== undefined && typeof value !== 'string') {\n      newUser = newUser || { ...user };\n      newUser[attr] = String(value);\n    }\n  }\n  return newUser || user;\n}\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]]\n  ]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/uuidjs/uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n","const logLevels = ['debug', 'info', 'warn', 'error', 'none'];\n\n/**\n * A simple logger that writes to stderr.\n */\nexport function commonBasicLogger(options, formatFn) {\n  if (options && options.destination && typeof options.destination !== 'function') {\n    throw new Error('destination for basicLogger was set to a non-function');\n  }\n\n  function toConsole(methodName) {\n    // The global console variable is not guaranteed to be defined at all times in all browsers:\n    // https://www.beyondjava.net/console-log-surprises-with-internet-explorer-11-and-edge\n    return function(line) {\n      if (console && console[methodName]) {\n        console[methodName].call(console, line);\n      }\n    };\n  }\n  const destinations =\n    options && options.destination\n      ? [options.destination, options.destination, options.destination, options.destination]\n      : [toConsole('log'), toConsole('info'), toConsole('warn'), toConsole('error')];\n  const prependLevelToMessage = !!(options && options.destination); // if we're writing to console.warn, etc. we don't need the prefix\n  const prefix =\n    !options || options.prefix === undefined || options.prefix === null ? '[LaunchDarkly] ' : options.prefix;\n\n  let minLevel = 1; // default is 'info'\n  if (options && options.level) {\n    for (let i = 0; i < logLevels.length; i++) {\n      if (logLevels[i] === options.level) {\n        minLevel = i;\n      }\n    }\n  }\n\n  function write(levelIndex, levelName, args) {\n    if (args.length < 1) {\n      return;\n    }\n    let line;\n    const fullPrefix = prependLevelToMessage ? levelName + ': ' + prefix : prefix;\n    if (args.length === 1 || !formatFn) {\n      line = fullPrefix + args[0];\n    } else {\n      const tempArgs = [...args];\n      tempArgs[0] = fullPrefix + tempArgs[0];\n      line = formatFn(...tempArgs);\n    }\n    try {\n      destinations[levelIndex](line);\n    } catch (err) {\n      console &&\n        console.log &&\n        console.log(\"[LaunchDarkly] Configured logger's \" + levelName + ' method threw an exception: ' + err);\n    }\n  }\n\n  const logger = {};\n  for (let i = 0; i < logLevels.length; i++) {\n    const levelName = logLevels[i];\n    if (levelName !== 'none') {\n      if (i < minLevel) {\n        logger[levelName] = () => {};\n      } else {\n        const levelIndex = i;\n        logger[levelName] = function() {\n          // can't use arrow function with \"arguments\"\n          write(levelIndex, levelName, arguments);\n        };\n      }\n    }\n  }\n\n  return logger;\n}\n\nexport function validateLogger(logger) {\n  logLevels.forEach(level => {\n    if (level !== 'none' && (!logger[level] || typeof logger[level] !== 'function')) {\n      throw new Error('Provided logger instance must support logger.' + level + '(...) method');\n      // Note that the SDK normally does not throw exceptions to the application, but that rule\n      // does not apply to LDClient.init() which will throw an exception if the parameters are so\n      // invalid that we cannot proceed with creating the client. An invalid logger meets those\n      // criteria since the SDK calls the logger during nearly all of its operations.\n    }\n  });\n}\n\n// Deprecated equivalent to commonBasicLogger\nexport function createConsoleLogger(level, maybePrefix) {\n  return commonBasicLogger({ level, prefix: maybePrefix });\n}\n","import * as errors from './errors';\n\nfunction errorString(err) {\n  if (err && err.message) {\n    return err.message;\n  }\n  if (typeof err === 'string' || err instanceof String) {\n    return err;\n  }\n  return JSON.stringify(err);\n}\n\nexport const clientInitialized = function() {\n  return 'LaunchDarkly client initialized';\n};\n\nconst docLink =\n  ' Please see https://docs.launchdarkly.com/sdk/client-side/javascript#initializing-the-client for instructions on SDK initialization.';\n\nexport const clientNotReady = function() {\n  return 'LaunchDarkly client is not ready';\n};\n\nexport const eventCapacityExceeded = function() {\n  return 'Exceeded event queue capacity. Increase capacity to avoid dropping events.';\n};\n\nexport const eventWithoutUser = function() {\n  return 'Be sure to call `identify` in the LaunchDarkly client: https://docs.launchdarkly.com/sdk/features/identify#javascript';\n};\n\nexport const invalidContentType = function(contentType) {\n  return 'Expected application/json content type but got \"' + contentType + '\"';\n};\n\nexport const invalidKey = function() {\n  return 'Event key must be a string';\n};\n\nexport const localStorageUnavailable = function(err) {\n  return 'local storage is unavailable: ' + errorString(err);\n};\n\nexport const networkError = e => 'network error' + (e ? ' (' + e + ')' : '');\n\n// We should remove unknownCustomEventKey in the future - see comments in track() in index.js\nexport const unknownCustomEventKey = function(key) {\n  return 'Custom event \"' + key + '\" does not exist';\n};\n\nexport const environmentNotFound = function() {\n  return 'Environment not found. Double check that you specified a valid environment/client-side ID.' + docLink;\n};\n\nexport const environmentNotSpecified = function() {\n  return 'No environment/client-side ID was specified.' + docLink;\n};\n\nexport const errorFetchingFlags = function(err) {\n  return 'Error fetching flag settings: ' + errorString(err);\n};\n\nexport const userNotSpecified = function() {\n  return 'No user specified.' + docLink;\n};\n\nexport const invalidUser = function() {\n  return 'Invalid user specified.' + docLink;\n};\n\nexport const invalidData = function() {\n  return 'Invalid data received from LaunchDarkly; connection may have been interrupted';\n};\n\nexport const bootstrapOldFormat = function() {\n  return (\n    'LaunchDarkly client was initialized with bootstrap data that did not include flag metadata. ' +\n    'Events may not be sent correctly.' +\n    docLink\n  );\n};\n\nexport const bootstrapInvalid = function() {\n  return 'LaunchDarkly bootstrap data is not available because the back end could not read the flags.';\n};\n\nexport const deprecated = function(oldName, newName) {\n  if (newName) {\n    return '\"' + oldName + '\" is deprecated, please use \"' + newName + '\"';\n  }\n  return '\"' + oldName + '\" is deprecated';\n};\n\nexport const httpErrorMessage = function(status, context, retryMessage) {\n  return (\n    'Received error ' +\n    status +\n    (status === 401 ? ' (invalid SDK key)' : '') +\n    ' for ' +\n    context +\n    ' - ' +\n    (errors.isHttpErrorRecoverable(status) ? retryMessage : 'giving up permanently')\n  );\n};\n\nexport const httpUnavailable = function() {\n  return 'Cannot make HTTP requests in this environment.' + docLink;\n};\n\nexport const identifyDisabled = function() {\n  return 'identify() has no effect here; it must be called on the main client instance';\n};\n\nexport const streamClosing = function() {\n  return 'Closing stream connection';\n};\n\nexport const streamConnecting = function(url) {\n  return 'Opening stream connection to ' + url;\n};\n\nexport const streamError = function(err, streamReconnectDelay) {\n  return (\n    'Error on stream connection: ' +\n    errorString(err) +\n    ', will continue retrying after ' +\n    streamReconnectDelay +\n    ' milliseconds.'\n  );\n};\n\nexport const unrecoverableStreamError = function(err) {\n  return `Error on stream connection ${errorString(err)}, giving up permanently`;\n};\n\nexport const unknownOption = name => 'Ignoring unknown config option \"' + name + '\"';\n\nexport const wrongOptionType = (name, expectedType, actualType) =>\n  'Config option \"' + name + '\" should be of type ' + expectedType + ', got ' + actualType + ', using default value';\n\nexport const wrongOptionTypeBoolean = (name, actualType) =>\n  'Config option \"' + name + '\" should be a boolean, got ' + actualType + ', converting to boolean';\n\nexport const optionBelowMinimum = (name, value, minimum) =>\n  'Config option \"' + name + '\" was set to ' + value + ', changing to minimum value of ' + minimum;\n\nexport const debugPolling = function(url) {\n  return 'polling for feature flags at ' + url;\n};\n\nexport const debugStreamPing = function() {\n  return 'received ping message from stream';\n};\n\nexport const debugStreamPut = function() {\n  return 'received streaming update for all flags';\n};\n\nexport const debugStreamPatch = function(key) {\n  return 'received streaming update for flag \"' + key + '\"';\n};\n\nexport const debugStreamPatchIgnored = function(key) {\n  return 'received streaming update for flag \"' + key + '\" but ignored due to version check';\n};\n\nexport const debugStreamDelete = function(key) {\n  return 'received streaming deletion for flag \"' + key + '\"';\n};\n\nexport const debugStreamDeleteIgnored = function(key) {\n  return 'received streaming deletion for flag \"' + key + '\" but ignored due to version check';\n};\n\nexport const debugEnqueueingEvent = function(kind) {\n  return 'enqueueing \"' + kind + '\" event';\n};\n\nexport const debugPostingEvents = function(count) {\n  return 'sending ' + count + ' events';\n};\n\nexport const debugPostingDiagnosticEvent = function(event) {\n  return 'sending diagnostic event (' + event.kind + ')';\n};\n\nexport const invalidTagValue = name => `Config option \"${name}\" must only contain letters, numbers, ., _ or -.`;\n\nexport const invalidInspector = (type, name) => `an inspector: \"${name}\" of an invalid type (${type}) was configured`;\n\nexport const inspectorMethodError = (type, name) => `an inspector: \"${name}\" of type: \"${type}\" generated an exception`;\n\nexport const tagValueTooLong = name => `Value of \"${name}\" was longer than 64 characters and was discarded.`;\n","import * as errors from './errors';\nimport { validateLogger } from './loggers';\nimport * as messages from './messages';\nimport * as utils from './utils';\n\n// baseOptionDefs should contain an entry for each supported configuration option in the common package.\n// Each entry can have three properties:\n// - \"default\": the default value if any\n// - \"type\": a type constraint used if the type can't be inferred from the default value). The allowable\n//   values are \"boolean\", \"string\", \"number\", \"array\", \"object\", \"function\", or several of these OR'd\n//   together with \"|\" (\"function|object\").\n// - \"minimum\": minimum value if any for numeric properties\n//\n// The extraOptionDefs parameter to validate() uses the same format.\nexport const baseOptionDefs = {\n  baseUrl: { default: 'https://app.launchdarkly.com' },\n  streamUrl: { default: 'https://clientstream.launchdarkly.com' },\n  eventsUrl: { default: 'https://events.launchdarkly.com' },\n  sendEvents: { default: true },\n  streaming: { type: 'boolean' }, // default for this is undefined, which is different from false\n  sendLDHeaders: { default: true },\n  requestHeaderTransform: { type: 'function' },\n  inlineUsersInEvents: { default: false },\n  allowFrequentDuplicateEvents: { default: false },\n  sendEventsOnlyForVariation: { default: false },\n  useReport: { default: false },\n  evaluationReasons: { default: false },\n  eventCapacity: { default: 100, minimum: 1 },\n  flushInterval: { default: 2000, minimum: 2000 },\n  samplingInterval: { default: 0, minimum: 0 },\n  streamReconnectDelay: { default: 1000, minimum: 0 },\n  allAttributesPrivate: { default: false },\n  privateAttributeNames: { default: [] },\n  bootstrap: { type: 'string|object' },\n  diagnosticRecordingInterval: { default: 900000, minimum: 2000 },\n  diagnosticOptOut: { default: false },\n  wrapperName: { type: 'string' },\n  wrapperVersion: { type: 'string' },\n  stateProvider: { type: 'object' }, // not a public option, used internally\n  autoAliasingOptOut: { default: false },\n  application: { validator: applicationConfigValidator },\n  inspectors: { default: [] },\n};\n\n/**\n * Expression to validate characters that are allowed in tag keys and values.\n */\nconst allowedTagCharacters = /^(\\w|\\.|-)+$/;\n\n/**\n * Verify that a value meets the requirements for a tag value.\n * @param {string} tagValue\n * @param {Object} logger\n */\nfunction validateTagValue(name, tagValue, logger) {\n  if (typeof tagValue !== 'string' || !tagValue.match(allowedTagCharacters)) {\n    logger.warn(messages.invalidTagValue(name));\n    return undefined;\n  }\n  if (tagValue.length > 64) {\n    logger.warn(messages.tagValueTooLong(name));\n    return undefined;\n  }\n  return tagValue;\n}\n\nfunction applicationConfigValidator(name, value, logger) {\n  const validated = {};\n  if (value.id) {\n    validated.id = validateTagValue(`${name}.id`, value.id, logger);\n  }\n  if (value.version) {\n    validated.version = validateTagValue(`${name}.version`, value.version, logger);\n  }\n  return validated;\n}\n\nexport function validate(options, emitter, extraOptionDefs, logger) {\n  const optionDefs = utils.extend({ logger: { default: logger } }, baseOptionDefs, extraOptionDefs);\n\n  const deprecatedOptions = {\n    // eslint-disable-next-line camelcase\n    all_attributes_private: 'allAttributesPrivate',\n    // eslint-disable-next-line camelcase\n    private_attribute_names: 'privateAttributeNames',\n    samplingInterval: null,\n    // The property name is the deprecated name, and the property value is the preferred name if\n    // any, or null/undefined if there is no replacement. This should be removed, along with\n    // the option, in the next major version.\n    allowFrequentDuplicateEvents: undefined,\n  };\n\n  function checkDeprecatedOptions(config) {\n    const opts = config;\n    Object.keys(deprecatedOptions).forEach(oldName => {\n      if (opts[oldName] !== undefined) {\n        const newName = deprecatedOptions[oldName];\n        logger && logger.warn(messages.deprecated(oldName, newName));\n        if (newName) {\n          if (opts[newName] === undefined) {\n            opts[newName] = opts[oldName];\n          }\n          delete opts[oldName];\n        }\n      }\n    });\n  }\n\n  function applyDefaults(config) {\n    // This works differently from utils.extend() in that it *will not* override a default value\n    // if the provided value is explicitly set to null. This provides backward compatibility\n    // since in the past we only used the provided values if they were truthy.\n    const ret = utils.extend({}, config);\n    Object.keys(optionDefs).forEach(name => {\n      if (ret[name] === undefined || ret[name] === null) {\n        ret[name] = optionDefs[name] && optionDefs[name].default;\n      }\n    });\n    return ret;\n  }\n\n  function validateTypesAndNames(config) {\n    const ret = utils.extend({}, config);\n    const typeDescForValue = value => {\n      if (value === null) {\n        return 'any';\n      }\n      if (value === undefined) {\n        return undefined;\n      }\n      if (Array.isArray(value)) {\n        return 'array';\n      }\n      const t = typeof value;\n      if (t === 'boolean' || t === 'string' || t === 'number' || t === 'function') {\n        return t;\n      }\n      return 'object';\n    };\n    Object.keys(config).forEach(name => {\n      const value = config[name];\n      if (value !== null && value !== undefined) {\n        const optionDef = optionDefs[name];\n        if (optionDef === undefined) {\n          reportArgumentError(messages.unknownOption(name));\n        } else {\n          const expectedType = optionDef.type || typeDescForValue(optionDef.default);\n          const validator = optionDef.validator;\n          if (validator) {\n            const validated = validator(name, config[name], logger);\n            if (validated !== undefined) {\n              ret[name] = validated;\n            } else {\n              delete ret[name];\n            }\n          } else if (expectedType !== 'any') {\n            const allowedTypes = expectedType.split('|');\n            const actualType = typeDescForValue(value);\n            if (allowedTypes.indexOf(actualType) < 0) {\n              if (expectedType === 'boolean') {\n                ret[name] = !!value;\n                reportArgumentError(messages.wrongOptionTypeBoolean(name, actualType));\n              } else {\n                reportArgumentError(messages.wrongOptionType(name, expectedType, actualType));\n                ret[name] = optionDef.default;\n              }\n            } else {\n              if (actualType === 'number' && optionDef.minimum !== undefined && value < optionDef.minimum) {\n                reportArgumentError(messages.optionBelowMinimum(name, value, optionDef.minimum));\n                ret[name] = optionDef.minimum;\n              }\n            }\n          }\n        }\n      }\n    });\n    return ret;\n  }\n\n  function reportArgumentError(message) {\n    utils.onNextTick(() => {\n      emitter && emitter.maybeReportError(new errors.LDInvalidArgumentError(message));\n    });\n  }\n\n  let config = utils.extend({}, options || {});\n\n  checkDeprecatedOptions(config);\n\n  config = applyDefaults(config);\n  config = validateTypesAndNames(config);\n  validateLogger(config.logger);\n\n  return config;\n}\n\n/**\n * Get tags for the specified configuration.\n *\n * If any additional tags are added to the configuration, then the tags from\n * this method should be extended with those.\n * @param {Object} config The already valiated configuration.\n * @returns {Object} The tag configuration.\n */\nexport function getTags(config) {\n  const tags = {};\n  if (config) {\n    if (config.application && config.application.id !== undefined && config.application.id !== null) {\n      tags['application-id'] = [config.application.id];\n    }\n    if (config.application && config.application.version !== undefined && config.application.id !== null) {\n      tags['application-version'] = [config.application.version];\n    }\n  }\n\n  return tags;\n}\n","import { getLDUserAgentString } from './utils';\nimport { getTags } from './configuration';\n\nexport function getLDHeaders(platform, options) {\n  if (options && !options.sendLDHeaders) {\n    return {};\n  }\n  const h = {\n    'X-LaunchDarkly-User-Agent': getLDUserAgentString(platform),\n  };\n  if (options && options.wrapperName) {\n    h['X-LaunchDarkly-Wrapper'] = options.wrapperVersion\n      ? options.wrapperName + '/' + options.wrapperVersion\n      : options.wrapperName;\n  }\n  const tags = getTags(options);\n  const tagKeys = Object.keys(tags);\n  if (tagKeys.length) {\n    h['x-launchdarkly-tags'] = tagKeys\n      .sort()\n      .map(\n        key => (Array.isArray(tags[key]) ? tags[key].sort().map(value => `${key}/${value}`) : [`${key}/${tags[key]}`])\n      )\n      .reduce((flattened, item) => flattened.concat(item), [])\n      .join(' ');\n  }\n  return h;\n}\n\nexport function transformHeaders(headers, options) {\n  if (!options || !options.requestHeaderTransform) {\n    return headers;\n  }\n  return options.requestHeaderTransform({ ...headers });\n}\n","import * as errors from './errors';\nimport * as utils from './utils';\nimport uuidv1 from 'uuid/v1';\nimport { getLDHeaders, transformHeaders } from './headers';\n\nconst MAX_URL_LENGTH = 2000;\n\nexport default function EventSender(platform, environmentId, options) {\n  const imageUrlPath = '/a/' + environmentId + '.gif';\n  const baseHeaders = utils.extend({ 'Content-Type': 'application/json' }, getLDHeaders(platform, options));\n  const httpFallbackPing = platform.httpFallbackPing; // this will be set for us if we're in the browser SDK\n  const sender = {};\n\n  function getResponseInfo(result) {\n    const ret = { status: result.status };\n    const dateStr = result.header('date');\n    if (dateStr) {\n      const time = Date.parse(dateStr);\n      if (time) {\n        ret.serverTime = time;\n      }\n    }\n    return ret;\n  }\n\n  sender.sendChunk = (events, url, isDiagnostic, usePost) => {\n    const jsonBody = JSON.stringify(events);\n    const payloadId = isDiagnostic ? null : uuidv1();\n\n    function doPostRequest(canRetry) {\n      const headers = isDiagnostic\n        ? baseHeaders\n        : utils.extend({}, baseHeaders, {\n            'X-LaunchDarkly-Event-Schema': '3',\n            'X-LaunchDarkly-Payload-ID': payloadId,\n          });\n      return platform\n        .httpRequest('POST', url, transformHeaders(headers, options), jsonBody)\n        .promise.then(result => {\n          if (!result) {\n            // This was a response from a fire-and-forget request, so we won't have a status.\n            return;\n          }\n          if (result.status >= 400 && errors.isHttpErrorRecoverable(result.status) && canRetry) {\n            return doPostRequest(false);\n          } else {\n            return getResponseInfo(result);\n          }\n        })\n        .catch(() => {\n          if (canRetry) {\n            return doPostRequest(false);\n          }\n          return Promise.reject();\n        });\n    }\n\n    if (usePost) {\n      return doPostRequest(true).catch(() => {});\n    } else {\n      httpFallbackPing && httpFallbackPing(url + imageUrlPath + '?d=' + utils.base64URLEncode(jsonBody));\n      return Promise.resolve(); // we don't wait for this request to complete, it's just a one-way ping\n    }\n  };\n\n  sender.sendEvents = function(events, url, isDiagnostic) {\n    if (!platform.httpRequest) {\n      return Promise.resolve();\n    }\n    const canPost = platform.httpAllowsPost();\n    let chunks;\n    if (canPost) {\n      // no need to break up events into chunks if we can send a POST\n      chunks = [events];\n    } else {\n      chunks = utils.chunkUserEventsForUrl(MAX_URL_LENGTH - url.length, events);\n    }\n    const results = [];\n    for (let i = 0; i < chunks.length; i++) {\n      results.push(sender.sendChunk(chunks[i], url, isDiagnostic, canPost));\n    }\n    return Promise.all(results);\n  };\n\n  return sender;\n}\n","export default function EventSummarizer() {\n  const es = {};\n\n  let startDate = 0,\n    endDate = 0,\n    counters = {};\n\n  es.summarizeEvent = function(event) {\n    if (event.kind === 'feature') {\n      const counterKey =\n        event.key +\n        ':' +\n        (event.variation !== null && event.variation !== undefined ? event.variation : '') +\n        ':' +\n        (event.version !== null && event.version !== undefined ? event.version : '');\n      const counterVal = counters[counterKey];\n      if (counterVal) {\n        counterVal.count = counterVal.count + 1;\n      } else {\n        counters[counterKey] = {\n          count: 1,\n          key: event.key,\n          variation: event.variation,\n          version: event.version,\n          value: event.value,\n          default: event.default,\n        };\n      }\n      if (startDate === 0 || event.creationDate < startDate) {\n        startDate = event.creationDate;\n      }\n      if (event.creationDate > endDate) {\n        endDate = event.creationDate;\n      }\n    }\n  };\n\n  es.getSummary = function() {\n    const flagsOut = {};\n    let empty = true;\n    for (const i in counters) {\n      const c = counters[i];\n      let flag = flagsOut[c.key];\n      if (!flag) {\n        flag = {\n          default: c.default,\n          counters: [],\n        };\n        flagsOut[c.key] = flag;\n      }\n      const counterOut = {\n        value: c.value,\n        count: c.count,\n      };\n      if (c.variation !== undefined && c.variation !== null) {\n        counterOut.variation = c.variation;\n      }\n      if (c.version) {\n        counterOut.version = c.version;\n      } else {\n        counterOut.unknown = true;\n      }\n      flag.counters.push(counterOut);\n      empty = false;\n    }\n    return empty\n      ? null\n      : {\n          startDate,\n          endDate,\n          features: flagsOut,\n        };\n  };\n\n  es.clearSummary = function() {\n    startDate = 0;\n    endDate = 0;\n    counters = {};\n  };\n\n  return es;\n}\n","import * as utils from './utils';\n\n/**\n * The UserFilter object transforms user objects into objects suitable to be sent as JSON to\n * the server, hiding any private user attributes.\n *\n * @param {Object} the LaunchDarkly client configuration object\n **/\nexport default function UserFilter(config) {\n  const filter = {};\n  const allAttributesPrivate = config.allAttributesPrivate;\n  const privateAttributeNames = config.privateAttributeNames || [];\n  const ignoreAttrs = { key: true, custom: true, anonymous: true };\n  const allowedTopLevelAttrs = {\n    key: true,\n    secondary: true,\n    ip: true,\n    country: true,\n    email: true,\n    firstName: true,\n    lastName: true,\n    avatar: true,\n    name: true,\n    anonymous: true,\n    custom: true,\n  };\n\n  filter.filterUser = function(user) {\n    if (!user) {\n      return null;\n    }\n    const userPrivateAttrs = user.privateAttributeNames || [];\n\n    const isPrivateAttr = function(name) {\n      return (\n        !ignoreAttrs[name] &&\n        (allAttributesPrivate || userPrivateAttrs.indexOf(name) !== -1 || privateAttributeNames.indexOf(name) !== -1)\n      );\n    };\n    const filterAttrs = function(props, isAttributeAllowed) {\n      return Object.keys(props).reduce(\n        (acc, name) => {\n          const ret = acc;\n          if (isAttributeAllowed(name)) {\n            if (isPrivateAttr(name)) {\n              // add to hidden list\n              ret[1][name] = true;\n            } else {\n              ret[0][name] = props[name];\n            }\n          }\n          return ret;\n        },\n        [{}, {}]\n      );\n    };\n    const result = filterAttrs(user, key => allowedTopLevelAttrs[key]);\n    const filteredProps = result[0];\n    let removedAttrs = result[1];\n    if (user.custom) {\n      const customResult = filterAttrs(user.custom, () => true);\n      filteredProps.custom = customResult[0];\n      removedAttrs = utils.extend({}, removedAttrs, customResult[1]);\n    }\n    const removedAttrNames = Object.keys(removedAttrs);\n    if (removedAttrNames.length) {\n      removedAttrNames.sort();\n      filteredProps.privateAttrs = removedAttrNames;\n    }\n    return filteredProps;\n  };\n  return filter;\n}\n","import EventSender from './EventSender';\nimport EventSummarizer from './EventSummarizer';\nimport UserFilter from './UserFilter';\nimport * as errors from './errors';\nimport * as messages from './messages';\nimport * as utils from './utils';\n\nexport default function EventProcessor(\n  platform,\n  options,\n  environmentId,\n  diagnosticsAccumulator = null,\n  emitter = null,\n  sender = null\n) {\n  const processor = {};\n  const eventSender = sender || EventSender(platform, environmentId, options);\n  const mainEventsUrl = utils.appendUrlPath(options.eventsUrl, '/events/bulk/' + environmentId);\n  const summarizer = EventSummarizer();\n  const userFilter = UserFilter(options);\n  const inlineUsers = options.inlineUsersInEvents;\n  const samplingInterval = options.samplingInterval;\n  const eventCapacity = options.eventCapacity;\n  const flushInterval = options.flushInterval;\n  const logger = options.logger;\n  let queue = [];\n  let lastKnownPastTime = 0;\n  let disabled = false;\n  let exceededCapacity = false;\n  let flushTimer;\n\n  function shouldSampleEvent() {\n    return samplingInterval === 0 || Math.floor(Math.random() * samplingInterval) === 0;\n  }\n\n  function shouldDebugEvent(e) {\n    if (e.debugEventsUntilDate) {\n      // The \"last known past time\" comes from the last HTTP response we got from the server.\n      // In case the client's time is set wrong, at least we know that any expiration date\n      // earlier than that point is definitely in the past.  If there's any discrepancy, we\n      // want to err on the side of cutting off event debugging sooner.\n      return e.debugEventsUntilDate > lastKnownPastTime && e.debugEventsUntilDate > new Date().getTime();\n    }\n    return false;\n  }\n\n  // Transform an event from its internal format to the format we use when sending a payload.\n  function makeOutputEvent(e) {\n    const ret = utils.extend({}, e);\n    if (e.kind === 'alias') {\n      // alias events do not require any transformation\n      return ret;\n    }\n    if (inlineUsers || e.kind === 'identify') {\n      // identify events always have an inline user\n      ret.user = userFilter.filterUser(e.user);\n    } else {\n      ret.userKey = e.user.key;\n      delete ret['user'];\n    }\n    if (e.kind === 'feature') {\n      delete ret['trackEvents'];\n      delete ret['debugEventsUntilDate'];\n    }\n    return ret;\n  }\n\n  function addToOutbox(event) {\n    if (queue.length < eventCapacity) {\n      queue.push(event);\n      exceededCapacity = false;\n    } else {\n      if (!exceededCapacity) {\n        exceededCapacity = true;\n        logger.warn(messages.eventCapacityExceeded());\n      }\n      if (diagnosticsAccumulator) {\n        // For diagnostic events, we track how many times we had to drop an event due to exceeding the capacity.\n        diagnosticsAccumulator.incrementDroppedEvents();\n      }\n    }\n  }\n\n  processor.enqueue = function(event) {\n    if (disabled) {\n      return;\n    }\n    let addFullEvent = false;\n    let addDebugEvent = false;\n\n    // Add event to the summary counters if appropriate\n    summarizer.summarizeEvent(event);\n\n    // Decide whether to add the event to the payload. Feature events may be added twice, once for\n    // the event (if tracked) and once for debugging.\n    if (event.kind === 'feature') {\n      if (shouldSampleEvent()) {\n        addFullEvent = !!event.trackEvents;\n        addDebugEvent = shouldDebugEvent(event);\n      }\n    } else {\n      addFullEvent = shouldSampleEvent();\n    }\n\n    if (addFullEvent) {\n      addToOutbox(makeOutputEvent(event));\n    }\n    if (addDebugEvent) {\n      const debugEvent = utils.extend({}, event, { kind: 'debug' });\n      debugEvent.user = userFilter.filterUser(debugEvent.user);\n      delete debugEvent['trackEvents'];\n      delete debugEvent['debugEventsUntilDate'];\n      addToOutbox(debugEvent);\n    }\n  };\n\n  processor.flush = function() {\n    if (disabled) {\n      return Promise.resolve();\n    }\n    const eventsToSend = queue;\n    const summary = summarizer.getSummary();\n    summarizer.clearSummary();\n    if (summary) {\n      summary.kind = 'summary';\n      eventsToSend.push(summary);\n    }\n    if (diagnosticsAccumulator) {\n      // For diagnostic events, we record how many events were in the queue at the last flush (since \"how\n      // many events happened to be in the queue at the moment we decided to send a diagnostic event\" would\n      // not be a very useful statistic).\n      diagnosticsAccumulator.setEventsInLastBatch(eventsToSend.length);\n    }\n    if (eventsToSend.length === 0) {\n      return Promise.resolve();\n    }\n    queue = [];\n    logger.debug(messages.debugPostingEvents(eventsToSend.length));\n    return eventSender.sendEvents(eventsToSend, mainEventsUrl).then(responseInfo => {\n      if (responseInfo) {\n        if (responseInfo.serverTime) {\n          lastKnownPastTime = responseInfo.serverTime;\n        }\n        if (!errors.isHttpErrorRecoverable(responseInfo.status)) {\n          disabled = true;\n        }\n        if (responseInfo.status >= 400) {\n          utils.onNextTick(() => {\n            emitter.maybeReportError(\n              new errors.LDUnexpectedResponseError(\n                messages.httpErrorMessage(responseInfo.status, 'event posting', 'some events were dropped')\n              )\n            );\n          });\n        }\n      }\n    });\n  };\n\n  processor.start = function() {\n    const flushTick = () => {\n      processor.flush();\n      flushTimer = setTimeout(flushTick, flushInterval);\n    };\n    flushTimer = setTimeout(flushTick, flushInterval);\n  };\n\n  processor.stop = function() {\n    clearTimeout(flushTimer);\n  };\n\n  return processor;\n}\n","export default function EventEmitter(logger) {\n  const emitter = {};\n  const events = {};\n\n  const listeningTo = event => !!events[event];\n\n  emitter.on = function(event, handler, context) {\n    events[event] = events[event] || [];\n    events[event] = events[event].concat({\n      handler: handler,\n      context: context,\n    });\n  };\n\n  emitter.off = function(event, handler, context) {\n    if (!events[event]) {\n      return;\n    }\n    for (let i = 0; i < events[event].length; i++) {\n      if (events[event][i].handler === handler && events[event][i].context === context) {\n        events[event] = events[event].slice(0, i).concat(events[event].slice(i + 1));\n      }\n    }\n  };\n\n  emitter.emit = function(event) {\n    if (!events[event]) {\n      return;\n    }\n    // Copy the list of handlers before iterating, in case any handler adds or removes another handler.\n    // Any such changes should not affect what we do here-- we want to notify every handler that existed\n    // at the moment that the event was fired.\n    const copiedHandlers = events[event].slice(0);\n    for (let i = 0; i < copiedHandlers.length; i++) {\n      copiedHandlers[i].handler.apply(copiedHandlers[i].context, Array.prototype.slice.call(arguments, 1));\n    }\n  };\n\n  emitter.getEvents = function() {\n    return Object.keys(events);\n  };\n\n  emitter.getEventListenerCount = function(event) {\n    return events[event] ? events[event].length : 0;\n  };\n\n  emitter.maybeReportError = function(error) {\n    if (!error) {\n      return;\n    }\n    if (listeningTo('error')) {\n      this.emit('error', error);\n    } else {\n      (logger || console).error(error.message);\n    }\n  };\n  return emitter;\n}\n","// This file provides an abstraction of the client's startup state.\n//\n// Startup can either succeed or fail exactly once; calling signalSuccess() or signalFailure()\n// after that point has no effect.\n//\n// On success, we fire both an \"initialized\" event and a \"ready\" event. Both the waitForInitialization()\n// promise and the waitUntilReady() promise are resolved in this case.\n//\n// On failure, we fire both a \"failed\" event (with the error as a parameter) and a \"ready\" event.\n// The waitForInitialization() promise is rejected, but the waitUntilReady() promise is resolved.\n//\n// To complicate things, we must *not* create the waitForInitialization() promise unless it is\n// requested, because otherwise failures would cause an *unhandled* rejection which can be a\n// serious problem in some environments. So we use a somewhat roundabout system for tracking the\n// initialization state and lazily creating this promise.\n\nconst readyEvent = 'ready',\n  successEvent = 'initialized',\n  failureEvent = 'failed';\n\nfunction InitializationStateTracker(eventEmitter) {\n  let succeeded = false,\n    failed = false,\n    failureValue = null,\n    initializationPromise = null;\n\n  const readyPromise = new Promise(resolve => {\n    const onReady = () => {\n      eventEmitter.off(readyEvent, onReady); // we can't use \"once\" because it's not available on some JS platforms\n      resolve();\n    };\n    eventEmitter.on(readyEvent, onReady);\n  }).catch(() => {}); // this Promise should never be rejected, but the catch handler is a safety measure\n\n  return {\n    getInitializationPromise: () => {\n      if (initializationPromise) {\n        return initializationPromise;\n      }\n      if (succeeded) {\n        return Promise.resolve();\n      }\n      if (failed) {\n        return Promise.reject(failureValue);\n      }\n      initializationPromise = new Promise((resolve, reject) => {\n        const onSuccess = () => {\n          eventEmitter.off(successEvent, onSuccess);\n          resolve();\n        };\n        const onFailure = err => {\n          eventEmitter.off(failureEvent, onFailure);\n          reject(err);\n        };\n        eventEmitter.on(successEvent, onSuccess);\n        eventEmitter.on(failureEvent, onFailure);\n      });\n      return initializationPromise;\n    },\n\n    getReadyPromise: () => readyPromise,\n\n    signalSuccess: () => {\n      if (!succeeded && !failed) {\n        succeeded = true;\n        eventEmitter.emit(successEvent);\n        eventEmitter.emit(readyEvent);\n      }\n    },\n\n    signalFailure: err => {\n      if (!succeeded && !failed) {\n        failed = true;\n        failureValue = err;\n        eventEmitter.emit(failureEvent, err);\n        eventEmitter.emit(readyEvent);\n      }\n      eventEmitter.maybeReportError(err); // the \"error\" event can be emitted more than once, unlike the others\n    },\n  };\n}\n\nmodule.exports = InitializationStateTracker;\n","import * as utils from './utils';\n\nexport default function PersistentFlagStore(storage, environment, hash, ident) {\n  const store = {};\n\n  function getFlagsKey() {\n    let key = '';\n    const user = ident.getUser();\n    if (user) {\n      key = hash || utils.btoa(JSON.stringify(user));\n    }\n    return 'ld:' + environment + ':' + key;\n  }\n\n  // Returns a Promise which will be resolved with a parsed JSON value if a stored value was available,\n  // or resolved with null if there was no value or if storage was not available.\n  store.loadFlags = () =>\n    storage.get(getFlagsKey()).then(dataStr => {\n      if (dataStr === null || dataStr === undefined) {\n        return null;\n      }\n      try {\n        let data = JSON.parse(dataStr);\n        if (data) {\n          const schema = data.$schema;\n          if (schema === undefined || schema < 1) {\n            data = utils.transformValuesToVersionedValues(data);\n          } else {\n            delete data['$schema'];\n          }\n        }\n        return data;\n      } catch (ex) {\n        return store.clearFlags().then(() => null);\n      }\n    });\n\n  // Resolves with true if successful, or false if storage is unavailable. Never rejects.\n  store.saveFlags = flags => {\n    const data = utils.extend({}, flags, { $schema: 1 });\n    return storage.set(getFlagsKey(), JSON.stringify(data));\n  };\n\n  // Resolves with true if successful, or false if storage is unavailable. Never rejects.\n  store.clearFlags = () => storage.clear(getFlagsKey());\n\n  return store;\n}\n","import * as messages from './messages';\n\n// The localStorageProvider is provided by the platform object. It should have the following\n// methods, each of which should return a Promise:\n// - get(key): Gets the string value, if any, for the given key\n// - set(key, value): Stores a string value for the given key\n// - remove(key): Removes the given key\n//\n// Storage is just a light wrapper of the localStorageProvider, adding error handling and\n// ensuring that we don't call it if it's unavailable. The get method will simply resolve\n// with an undefined value if there is an error or if there is no localStorageProvider.\n// None of the promises returned by Storage will ever be rejected.\n//\n// It is always possible that the underlying platform storage mechanism might fail or be\n// disabled. If so, it's likely that it will keep failing, so we will only log one warning\n// instead of repetitive warnings.\nexport default function PersistentStorage(localStorageProvider, logger) {\n  const storage = {};\n  let loggedError = false;\n\n  const logError = err => {\n    if (!loggedError) {\n      loggedError = true;\n      logger.warn(messages.localStorageUnavailable(err));\n    }\n  };\n\n  storage.isEnabled = () => !!localStorageProvider;\n\n  // Resolves with a value, or undefined if storage is unavailable. Never rejects.\n  storage.get = key =>\n    new Promise(resolve => {\n      if (!localStorageProvider) {\n        resolve(undefined);\n        return;\n      }\n      localStorageProvider\n        .get(key)\n        .then(resolve)\n        .catch(err => {\n          logError(err);\n          resolve(undefined);\n        });\n    });\n\n  // Resolves with true if successful, or false if storage is unavailable. Never rejects.\n  storage.set = (key, value) =>\n    new Promise(resolve => {\n      if (!localStorageProvider) {\n        resolve(false);\n        return;\n      }\n      localStorageProvider\n        .set(key, value)\n        .then(() => resolve(true))\n        .catch(err => {\n          logError(err);\n          resolve(false);\n        });\n    });\n\n  // Resolves with true if successful, or false if storage is unavailable. Never rejects.\n  storage.clear = key =>\n    new Promise(resolve => {\n      if (!localStorageProvider) {\n        resolve(false);\n        return;\n      }\n      localStorageProvider\n        .clear(key)\n        .then(() => resolve(true))\n        .catch(err => {\n          logError(err);\n          resolve(false);\n        });\n    });\n\n  return storage;\n}\n","import * as messages from './messages';\nimport { appendUrlPath, base64URLEncode, objectHasOwnProperty } from './utils';\nimport { getLDHeaders, transformHeaders } from './headers';\nimport { isHttpErrorRecoverable } from './errors';\n\n// The underlying event source implementation is abstracted via the platform object, which should\n// have these three properties:\n// eventSourceFactory(): a function that takes a URL and optional config object and returns an object\n//   with the same methods as the regular HTML5 EventSource object. The properties in the config\n//   object are those supported by the launchdarkly-eventsource package; browser EventSource\n//   implementations don't have any config options.\n// eventSourceIsActive(): a function that takes an EventSource-compatible object and returns true if\n//   it is in an active state (connected or connecting).\n// eventSourceAllowsReport: true if REPORT is supported.\n\n// The read timeout for the stream is a fixed value that is set to be slightly longer than the expected\n// interval between heartbeats from the LaunchDarkly streaming server. If this amount of time elapses\n// with no new data, the connection will be cycled.\nconst streamReadTimeoutMillis = 5 * 60 * 1000; // 5 minutes\nconst maxRetryDelay = 30 * 1000; // Maximum retry delay 30 seconds.\nconst jitterRatio = 0.5; // Delay should be 50%-100% of calculated time.\n\nexport default function Stream(platform, config, environment, diagnosticsAccumulator) {\n  const baseUrl = config.streamUrl;\n  const logger = config.logger;\n  const stream = {};\n  const evalUrlPrefix = appendUrlPath(baseUrl, '/eval/' + environment);\n  const useReport = config.useReport;\n  const withReasons = config.evaluationReasons;\n  const baseReconnectDelay = config.streamReconnectDelay;\n  const headers = getLDHeaders(platform, config);\n  let firstConnectionErrorLogged = false;\n  let es = null;\n  let reconnectTimeoutReference = null;\n  let connectionAttemptStartTime;\n  let user = null;\n  let hash = null;\n  let handlers = null;\n  let retryCount = 0;\n\n  function backoff() {\n    const delay = baseReconnectDelay * Math.pow(2, retryCount);\n    return delay > maxRetryDelay ? maxRetryDelay : delay;\n  }\n\n  function jitter(computedDelayMillis) {\n    return computedDelayMillis - Math.trunc(Math.random() * jitterRatio * computedDelayMillis);\n  }\n\n  function getNextRetryDelay() {\n    const delay = jitter(backoff());\n    retryCount += 1;\n    return delay;\n  }\n\n  stream.connect = function(newUser, newHash, newHandlers) {\n    user = newUser;\n    hash = newHash;\n    handlers = {};\n    for (const key in newHandlers || {}) {\n      handlers[key] = function(e) {\n        // Reset the state for logging the first connection error so that the first\n        // connection error following a successful connection will once again be logged.\n        // We will decorate *all* handlers to do this to keep this abstraction agnostic\n        // for different stream implementations.\n        firstConnectionErrorLogged = false;\n        logConnectionResult(true);\n        newHandlers[key] && newHandlers[key](e);\n      };\n    }\n    tryConnect();\n  };\n\n  stream.disconnect = function() {\n    clearTimeout(reconnectTimeoutReference);\n    reconnectTimeoutReference = null;\n    closeConnection();\n  };\n\n  stream.isConnected = function() {\n    return !!(es && platform.eventSourceIsActive && platform.eventSourceIsActive(es));\n  };\n\n  function handleError(err) {\n    // The event source may not produce a status. But the LaunchDarkly\n    // polyfill can. If we can get the status, then we should stop retrying\n    // on certain error codes.\n    if (err.status && typeof err.status === 'number' && !isHttpErrorRecoverable(err.status)) {\n      // If we encounter an unrecoverable condition, then we do not want to\n      // retry anymore.\n      closeConnection();\n      logger.error(messages.unrecoverableStreamError(err));\n      // Ensure any pending retry attempts are not done.\n      if (reconnectTimeoutReference) {\n        clearTimeout(reconnectTimeoutReference);\n        reconnectTimeoutReference = null;\n      }\n      return;\n    }\n\n    const delay = getNextRetryDelay();\n\n    if (!firstConnectionErrorLogged) {\n      logger.warn(messages.streamError(err, delay));\n      firstConnectionErrorLogged = true;\n    }\n    logConnectionResult(false);\n    closeConnection();\n    tryConnect(delay);\n  }\n\n  function tryConnect(delay) {\n    if (!reconnectTimeoutReference) {\n      if (delay) {\n        reconnectTimeoutReference = setTimeout(openConnection, delay);\n      } else {\n        openConnection();\n      }\n    }\n  }\n\n  function openConnection() {\n    reconnectTimeoutReference = null;\n    let url;\n    let query = '';\n    const options = { headers, readTimeoutMillis: streamReadTimeoutMillis };\n    if (platform.eventSourceFactory) {\n      if (hash !== null && hash !== undefined) {\n        query = 'h=' + hash;\n      }\n      if (useReport) {\n        if (platform.eventSourceAllowsReport) {\n          url = evalUrlPrefix;\n          options.method = 'REPORT';\n          options.headers['Content-Type'] = 'application/json';\n          options.body = JSON.stringify(user);\n        } else {\n          // if we can't do REPORT, fall back to the old ping-based stream\n          url = appendUrlPath(baseUrl, '/ping/' + environment);\n          query = '';\n        }\n      } else {\n        url = evalUrlPrefix + '/' + base64URLEncode(JSON.stringify(user));\n      }\n      options.headers = transformHeaders(options.headers, config);\n      if (withReasons) {\n        query = query + (query ? '&' : '') + 'withReasons=true';\n      }\n      url = url + (query ? '?' : '') + query;\n\n      closeConnection();\n      logger.info(messages.streamConnecting(url));\n      logConnectionStarted();\n\n      es = platform.eventSourceFactory(url, options);\n      for (const key in handlers) {\n        if (objectHasOwnProperty(handlers, key)) {\n          es.addEventListener(key, handlers[key]);\n        }\n      }\n\n      es.onerror = handleError;\n\n      es.onopen = () => {\n        // If the connection is a success, then reset the retryCount.\n        retryCount = 0;\n      };\n    }\n  }\n\n  function closeConnection() {\n    if (es) {\n      logger.info(messages.streamClosing());\n      es.close();\n      es = null;\n    }\n  }\n\n  function logConnectionStarted() {\n    connectionAttemptStartTime = new Date().getTime();\n  }\n\n  function logConnectionResult(success) {\n    if (connectionAttemptStartTime && diagnosticsAccumulator) {\n      diagnosticsAccumulator.recordStreamInit(\n        connectionAttemptStartTime,\n        !success,\n        new Date().getTime() - connectionAttemptStartTime\n      );\n    }\n    connectionAttemptStartTime = null;\n  }\n\n  return stream;\n}\n","// This function allows a series of Promises to be coalesced such that only the most recently\n// added one actually matters. For instance, if several HTTP requests are made to the same\n// endpoint and we want to ensure that whoever made each one always gets the latest data, each\n// can be passed to addPromise (on the same coalescer) and each caller can wait on the\n// coalescer.resultPromise; all three will then receive the result (or error) from the *last*\n// request, and the results of the first two will be discarded.\n//\n// The cancelFn callback, if present, will be called whenever an existing promise is being\n// discarded. This can be used for instance to abort an HTTP request that's now obsolete.\n//\n// The finallyFn callback, if present, is called on completion of the whole thing. This is\n// different from calling coalescer.resultPromise.finally() because it is executed before any\n// other handlers. Its purpose is to tell the caller that this coalescer should no longer be used.\n\nexport default function promiseCoalescer(finallyFn) {\n  let currentPromise;\n  let currentCancelFn;\n  let finalResolve;\n  let finalReject;\n\n  const coalescer = {};\n\n  coalescer.addPromise = (p, cancelFn) => {\n    currentPromise = p;\n    currentCancelFn && currentCancelFn();\n    currentCancelFn = cancelFn;\n\n    p.then(\n      result => {\n        if (currentPromise === p) {\n          finalResolve(result);\n          finallyFn && finallyFn();\n        }\n      },\n      error => {\n        if (currentPromise === p) {\n          finalReject(error);\n          finallyFn && finallyFn();\n        }\n      }\n    );\n  };\n\n  coalescer.resultPromise = new Promise((resolve, reject) => {\n    finalResolve = resolve;\n    finalReject = reject;\n  });\n\n  return coalescer;\n}\n","import * as utils from './utils';\nimport * as errors from './errors';\nimport * as messages from './messages';\nimport promiseCoalescer from './promiseCoalescer';\nimport { transformHeaders, getLDHeaders } from './headers';\n\nconst jsonContentType = 'application/json';\n\nfunction getResponseError(result) {\n  if (result.status === 404) {\n    return new errors.LDInvalidEnvironmentIdError(messages.environmentNotFound());\n  } else {\n    return new errors.LDFlagFetchError(messages.errorFetchingFlags(result.statusText || String(result.status)));\n  }\n}\n\nexport default function Requestor(platform, options, environment) {\n  const baseUrl = options.baseUrl;\n  const useReport = options.useReport;\n  const withReasons = options.evaluationReasons;\n  const logger = options.logger;\n\n  const requestor = {};\n\n  const activeRequests = {}; // map of URLs to promiseCoalescers\n\n  function fetchJSON(endpoint, body) {\n    if (!platform.httpRequest) {\n      return new Promise((resolve, reject) => {\n        reject(new errors.LDFlagFetchError(messages.httpUnavailable()));\n      });\n    }\n\n    const method = body ? 'REPORT' : 'GET';\n    const headers = getLDHeaders(platform, options);\n    if (body) {\n      headers['Content-Type'] = jsonContentType;\n    }\n\n    let coalescer = activeRequests[endpoint];\n    if (!coalescer) {\n      coalescer = promiseCoalescer(() => {\n        // this will be called once there are no more active requests for the same endpoint\n        delete activeRequests[endpoint];\n      });\n      activeRequests[endpoint] = coalescer;\n    }\n\n    const req = platform.httpRequest(method, endpoint, transformHeaders(headers, options), body);\n    const p = req.promise.then(\n      result => {\n        if (result.status === 200) {\n          // We're using substring here because using startsWith would require a polyfill in IE.\n          if (\n            result.header('content-type') &&\n            result.header('content-type').substring(0, jsonContentType.length) === jsonContentType\n          ) {\n            return JSON.parse(result.body);\n          } else {\n            const message = messages.invalidContentType(result.header('content-type') || '');\n            return Promise.reject(new errors.LDFlagFetchError(message));\n          }\n        } else {\n          return Promise.reject(getResponseError(result));\n        }\n      },\n      e => Promise.reject(new errors.LDFlagFetchError(messages.networkError(e)))\n    );\n    coalescer.addPromise(p, () => {\n      // this will be called if another request for the same endpoint supersedes this one\n      req.cancel && req.cancel();\n    });\n    return coalescer.resultPromise;\n  }\n\n  // Performs a GET request to an arbitrary path under baseUrl. Returns a Promise which will resolve\n  // with the parsed JSON response, or will be rejected if the request failed.\n  requestor.fetchJSON = function(path) {\n    return fetchJSON(utils.appendUrlPath(baseUrl, path), null);\n  };\n\n  // Requests the current state of all flags for the given user from LaunchDarkly. Returns a Promise\n  // which will resolve with the parsed JSON response, or will be rejected if the request failed.\n  requestor.fetchFlagSettings = function(user, hash) {\n    let data;\n    let endpoint;\n    let query = '';\n    let body;\n\n    if (useReport) {\n      endpoint = [baseUrl, '/sdk/evalx/', environment, '/user'].join('');\n      body = JSON.stringify(user);\n    } else {\n      data = utils.base64URLEncode(JSON.stringify(user));\n      endpoint = [baseUrl, '/sdk/evalx/', environment, '/users/', data].join('');\n    }\n    if (hash) {\n      query = 'h=' + hash;\n    }\n    if (withReasons) {\n      query = query + (query ? '&' : '') + 'withReasons=true';\n    }\n    endpoint = endpoint + (query ? '?' : '') + query;\n    logger.debug(messages.debugPolling(endpoint));\n\n    return fetchJSON(endpoint, body);\n  };\n\n  return requestor;\n}\n","import * as utils from './utils';\n\nexport default function Identity(initialUser, onChange) {\n  const ident = {};\n  let user;\n\n  ident.setUser = function(u) {\n    const previousUser = user && utils.clone(user);\n    user = utils.sanitizeUser(u);\n    if (user && onChange) {\n      onChange(utils.clone(user), previousUser);\n    }\n  };\n\n  ident.getUser = function() {\n    return user ? utils.clone(user) : null;\n  };\n\n  if (initialUser) {\n    ident.setUser(initialUser);\n  }\n\n  return ident;\n}\n","import uuidv1 from 'uuid/v1';\n\nimport * as errors from './errors';\nimport * as messages from './messages';\nimport * as utils from './utils';\n\n// Transforms the user object if necessary to make sure it has a valid key.\n// 1. If a key is present, but is not a string, change it to a string.\n// 2. If no key is present, and \"anonymous\" is true, use a UUID as a key. This is cached in local\n// storage if possible.\n// 3. If there is no key (or no user object), return an error.\n\nconst ldUserIdKey = 'ld:$anonUserId';\n\nexport default function UserValidator(persistentStorage) {\n  function getCachedUserId() {\n    return persistentStorage.get(ldUserIdKey);\n  }\n\n  function setCachedUserId(id) {\n    return persistentStorage.set(ldUserIdKey, id);\n  }\n\n  const ret = {};\n\n  // Validates the user, returning a Promise that resolves to the validated user, or rejects if there is an error.\n  ret.validateUser = user => {\n    if (!user) {\n      return Promise.reject(new errors.LDInvalidUserError(messages.userNotSpecified()));\n    }\n\n    const userOut = utils.clone(user);\n    if (userOut.key !== null && userOut.key !== undefined) {\n      userOut.key = userOut.key.toString();\n      return Promise.resolve(userOut);\n    }\n    if (userOut.anonymous) {\n      return getCachedUserId().then(cachedId => {\n        if (cachedId) {\n          userOut.key = cachedId;\n          return userOut;\n        } else {\n          const id = uuidv1();\n          userOut.key = id;\n          return setCachedUserId(id).then(() => userOut);\n        }\n      });\n    } else {\n      return Promise.reject(new errors.LDInvalidUserError(messages.invalidUser()));\n    }\n  };\n\n  return ret;\n}\n","const uuidv1 = require('uuid/v1');\n// Note that in the diagnostic events spec, these IDs are to be generated with UUID v4. However,\n// in JS we were already using v1 for unique user keys, so to avoid bringing in two packages we\n// will use v1 here as well.\n\nconst { baseOptionDefs } = require('./configuration');\nconst messages = require('./messages');\nconst { appendUrlPath } = require('./utils');\n\nfunction DiagnosticId(sdkKey) {\n  const ret = {\n    diagnosticId: uuidv1(),\n  };\n  if (sdkKey) {\n    ret.sdkKeySuffix = sdkKey.length > 6 ? sdkKey.substring(sdkKey.length - 6) : sdkKey;\n  }\n  return ret;\n}\n\n// A stateful object holding statistics that will go into diagnostic events.\n\nfunction DiagnosticsAccumulator(startTime) {\n  let dataSinceDate, droppedEvents, eventsInLastBatch, streamInits;\n\n  function reset(time) {\n    dataSinceDate = time;\n    droppedEvents = 0;\n    eventsInLastBatch = 0;\n    streamInits = [];\n  }\n\n  reset(startTime);\n\n  return {\n    getProps: () => ({\n      dataSinceDate,\n      droppedEvents,\n      eventsInLastBatch,\n      streamInits,\n      // omit deduplicatedUsers for the JS SDKs because they don't deduplicate users\n    }),\n    setProps: props => {\n      dataSinceDate = props.dataSinceDate;\n      droppedEvents = props.droppedEvents || 0;\n      eventsInLastBatch = props.eventsInLastBatch || 0;\n      streamInits = props.streamInits || [];\n    },\n    incrementDroppedEvents: () => {\n      droppedEvents++;\n    },\n    setEventsInLastBatch: n => {\n      eventsInLastBatch = n;\n    },\n    recordStreamInit: (timestamp, failed, durationMillis) => {\n      const info = { timestamp, failed, durationMillis };\n      streamInits.push(info);\n    },\n    reset,\n  };\n}\n\n// An object that maintains information that will go into diagnostic events, and knows how to format\n// those events. It is instantiated by the SDK client, and shared with the event processor.\n//\n// The JS-based SDKs have two modes for diagnostic events. By default, the behavior is basically the\n// same as the server-side SDKs: a \"diagnostic-init\" event is sent on startup, and then \"diagnostic\"\n// events with operating statistics are sent periodically. However, in a browser environment this is\n// undesirable because the page may be reloaded frequently. In that case, setting the property\n// \"platform.diagnosticUseCombinedEvent\" to true enables an alternate mode in which a combination of\n// both kinds of event is sent at intervals, relative to the last time this was done (if any) which\n// is cached in local storage.\n\nfunction DiagnosticsManager(\n  platform,\n  persistentStorage,\n  accumulator,\n  eventSender,\n  environmentId,\n  config,\n  diagnosticId\n) {\n  const combinedMode = !!platform.diagnosticUseCombinedEvent;\n  const localStorageKey = 'ld:' + environmentId + ':$diagnostics';\n  const diagnosticEventsUrl = appendUrlPath(config.eventsUrl, '/events/diagnostic/' + environmentId);\n  const periodicInterval = config.diagnosticRecordingInterval;\n  const acc = accumulator;\n  const initialEventSamplingInterval = 4; // used only in combined mode - see start()\n  let streamingEnabled = !!config.streaming;\n  let eventSentTime;\n  let periodicTimer;\n  const manager = {};\n\n  function makeInitProperties() {\n    return {\n      sdk: makeSdkData(),\n      configuration: makeConfigData(),\n      platform: platform.diagnosticPlatformData,\n    };\n  }\n\n  // Send a diagnostic event and do not wait for completion.\n  function sendDiagnosticEvent(event) {\n    config.logger && config.logger.debug(messages.debugPostingDiagnosticEvent(event));\n    eventSender\n      .sendEvents(event, diagnosticEventsUrl, true)\n      .then(() => undefined)\n      .catch(() => undefined);\n  }\n\n  function loadProperties(callback) {\n    if (!persistentStorage.isEnabled()) {\n      return callback(false); // false indicates that local storage is not available\n    }\n    persistentStorage\n      .get(localStorageKey)\n      .then(data => {\n        if (data) {\n          try {\n            const props = JSON.parse(data);\n            acc.setProps(props);\n            eventSentTime = props.dataSinceDate;\n          } catch (e) {\n            // disregard malformed cached data\n          }\n        }\n        callback(true);\n      })\n      .catch(() => {\n        callback(false);\n      });\n  }\n\n  function saveProperties() {\n    if (persistentStorage.isEnabled()) {\n      const props = { ...acc.getProps() };\n      persistentStorage.set(localStorageKey, JSON.stringify(props));\n    }\n  }\n\n  // Creates the initial event that is sent by the event processor when the SDK starts up. This will not\n  // be repeated during the lifetime of the SDK client. In combined mode, we don't send this.\n  function createInitEvent() {\n    return {\n      kind: 'diagnostic-init',\n      id: diagnosticId,\n      creationDate: acc.getProps().dataSinceDate,\n      ...makeInitProperties(),\n    };\n  }\n\n  // Creates a periodic event containing time-dependent stats, and resets the state of the manager with\n  // regard to those stats. In combined mode (browser SDK) this also contains the configuration data.\n  function createPeriodicEventAndReset() {\n    const currentTime = new Date().getTime();\n    let ret = {\n      kind: combinedMode ? 'diagnostic-combined' : 'diagnostic',\n      id: diagnosticId,\n      creationDate: currentTime,\n      ...acc.getProps(),\n    };\n    if (combinedMode) {\n      ret = { ...ret, ...makeInitProperties() };\n    }\n    acc.reset(currentTime);\n    return ret;\n  }\n\n  function sendPeriodicEvent() {\n    sendDiagnosticEvent(createPeriodicEventAndReset());\n    periodicTimer = setTimeout(sendPeriodicEvent, periodicInterval);\n    eventSentTime = new Date().getTime();\n    if (combinedMode) {\n      saveProperties();\n    }\n  }\n\n  function makeSdkData() {\n    const sdkData = { ...platform.diagnosticSdkData };\n    if (config.wrapperName) {\n      sdkData.wrapperName = config.wrapperName;\n    }\n    if (config.wrapperVersion) {\n      sdkData.wrapperVersion = config.wrapperVersion;\n    }\n    return sdkData;\n  }\n\n  function makeConfigData() {\n    const configData = {\n      customBaseURI: config.baseUrl !== baseOptionDefs.baseUrl.default,\n      customStreamURI: config.streamUrl !== baseOptionDefs.streamUrl.default,\n      customEventsURI: config.eventsUrl !== baseOptionDefs.eventsUrl.default,\n      eventsCapacity: config.eventCapacity,\n      eventsFlushIntervalMillis: config.flushInterval,\n      reconnectTimeMillis: config.streamReconnectDelay,\n      streamingDisabled: !streamingEnabled,\n      allAttributesPrivate: !!config.allAttributesPrivate,\n      inlineUsersInEvents: !!config.inlineUsersInEvents,\n      diagnosticRecordingIntervalMillis: config.diagnosticRecordingInterval,\n      // The following extra properties are only provided by client-side JS SDKs:\n      usingSecureMode: !!config.hash,\n      bootstrapMode: !!config.bootstrap,\n      fetchGoalsDisabled: !config.fetchGoals,\n      sendEventsOnlyForVariation: !!config.sendEventsOnlyForVariation,\n      autoAliasingOptOut: !!config.autoAliasingOptOut,\n    };\n    // Client-side JS SDKs do not have the following properties which other SDKs have:\n    // connectTimeoutMillis\n    // pollingIntervalMillis\n    // samplingInterval\n    // socketTimeoutMillis\n    // startWaitMillis\n    // userKeysCapacity\n    // userKeysFlushIntervalMillis\n    // usingProxy\n    // usingProxyAuthenticator\n    // usingRelayDaemon\n\n    return configData;\n  }\n\n  // Called when the SDK is starting up. Either send an init event immediately, or, in the alternate\n  // mode, check for cached local storage properties and send an event only if we haven't done so\n  // recently.\n  manager.start = () => {\n    if (combinedMode) {\n      loadProperties(localStorageAvailable => {\n        if (localStorageAvailable) {\n          const nextEventTime = (eventSentTime || 0) + periodicInterval;\n          const timeNow = new Date().getTime();\n          if (timeNow >= nextEventTime) {\n            sendPeriodicEvent();\n          } else {\n            periodicTimer = setTimeout(sendPeriodicEvent, nextEventTime - timeNow);\n          }\n        } else {\n          // We don't have the ability to cache anything in local storage, so we don't know if we\n          // recently sent an event before this page load, but we would still prefer not to send one\n          // on *every* page load. So, as a rough heuristic, we'll decide semi-randomly.\n          if (Math.floor(Math.random() * initialEventSamplingInterval) === 0) {\n            sendPeriodicEvent();\n          } else {\n            periodicTimer = setTimeout(sendPeriodicEvent, periodicInterval);\n          }\n        }\n      });\n    } else {\n      sendDiagnosticEvent(createInitEvent());\n      periodicTimer = setTimeout(sendPeriodicEvent, periodicInterval);\n    }\n  };\n\n  manager.stop = () => {\n    periodicTimer && clearTimeout(periodicTimer);\n  };\n\n  // Called when streaming mode is turned on or off dynamically.\n  manager.setStreaming = enabled => {\n    streamingEnabled = enabled;\n  };\n\n  return manager;\n}\n\nmodule.exports = {\n  DiagnosticId,\n  DiagnosticsAccumulator,\n  DiagnosticsManager,\n};\n","import * as messages from './messages';\n\n/**\n * Wrap an inspector ensuring that calling its methods are safe.\n * @param {object} inspector Inspector to wrap.\n */\nexport default function SafeInspector(inspector, logger) {\n  let errorLogged = false;\n  const wrapper = {\n    type: inspector.type,\n    name: inspector.name,\n  };\n\n  wrapper.method = (...args) => {\n    try {\n      inspector.method(...args);\n    } catch {\n      // If something goes wrong in an inspector we want to log that something\n      // went wrong. We don't want to flood the logs, so we only log something\n      // the first time that something goes wrong.\n      // We do not include the exception in the log, because we do not know what\n      // kind of data it may contain.\n      if (!errorLogged) {\n        errorLogged = true;\n        logger.warn(messages.inspectorMethodError(wrapper.type, wrapper.name));\n      }\n      // Prevent errors.\n    }\n  };\n\n  return wrapper;\n}\n","import * as messages from './messages';\nimport SafeInspector from './SafeInspector';\nimport { onNextTick } from './utils';\n\n/**\n * The types of supported inspectors.\n */\nexport const InspectorTypes = {\n  flagUsed: 'flag-used',\n  flagDetailsChanged: 'flag-details-changed',\n  flagDetailChanged: 'flag-detail-changed',\n  clientIdentityChanged: 'client-identity-changed',\n};\n\nObject.freeze(InspectorTypes);\n\n/**\n * Manages dispatching of inspection data to registered inspectors.\n */\nexport function InspectorManager(inspectors, logger) {\n  const manager = {};\n\n  /**\n   * Collection of inspectors keyed by type.\n   * @type {{[type: string]: object[]}}\n   */\n  const inspectorsByType = {\n    [InspectorTypes.flagUsed]: [],\n    [InspectorTypes.flagDetailsChanged]: [],\n    [InspectorTypes.flagDetailChanged]: [],\n    [InspectorTypes.clientIdentityChanged]: [],\n  };\n\n  const safeInspectors = inspectors?.map(inspector => SafeInspector(inspector, logger));\n\n  safeInspectors.forEach(safeInspector => {\n    // Only add inspectors of supported types.\n    if (Object.prototype.hasOwnProperty.call(inspectorsByType, safeInspector.type)) {\n      inspectorsByType[safeInspector.type].push(safeInspector);\n    } else {\n      logger.warn(messages.invalidInspector(safeInspector.type, safeInspector.name));\n    }\n  });\n\n  /**\n   * Check if there is an inspector of a specific type registered.\n   *\n   * @param {string} type The type of the inspector to check.\n   * @returns True if there are any inspectors of that type registered.\n   */\n  manager.hasListeners = type => inspectorsByType[type]?.length;\n\n  /**\n   * Notify registered inspectors of a flag being used.\n   *\n   * The notification itself will be dispatched asynchronously.\n   *\n   * @param {string} flagKey The key for the flag.\n   * @param {Object} detail The LDEvaluationDetail for the flag.\n   * @param {Object} user The LDUser for the flag.\n   */\n  manager.onFlagUsed = (flagKey, detail, user) => {\n    if (inspectorsByType[InspectorTypes.flagUsed].length) {\n      onNextTick(() => {\n        inspectorsByType[InspectorTypes.flagUsed].forEach(inspector => inspector.method(flagKey, detail, user));\n      });\n    }\n  };\n\n  /**\n   * Notify registered inspectors that the flags have been replaced.\n   *\n   * The notification itself will be dispatched asynchronously.\n   *\n   * @param {Record<string, Object>} flags The current flags as a Record<string, LDEvaluationDetail>.\n   */\n  manager.onFlags = flags => {\n    if (inspectorsByType[InspectorTypes.flagDetailsChanged].length) {\n      onNextTick(() => {\n        inspectorsByType[InspectorTypes.flagDetailsChanged].forEach(inspector => inspector.method(flags));\n      });\n    }\n  };\n\n  /**\n   * Notify registered inspectors that a flag value has changed.\n   *\n   * The notification itself will be dispatched asynchronously.\n   *\n   * @param {string} flagKey The key for the flag that changed.\n   * @param {Object} flag An `LDEvaluationDetail` for the flag.\n   */\n  manager.onFlagChanged = (flagKey, flag) => {\n    if (inspectorsByType[InspectorTypes.flagDetailChanged].length) {\n      onNextTick(() => {\n        inspectorsByType[InspectorTypes.flagDetailChanged].forEach(inspector => inspector.method(flagKey, flag));\n      });\n    }\n  };\n\n  /**\n   * Notify the registered inspectors that the user identity has changed.\n   *\n   * The notification itself will be dispatched asynchronously.\n   *\n   * @param {Object} user The `LDUser` which is now identified.\n   */\n  manager.onIdentityChanged = user => {\n    if (inspectorsByType[InspectorTypes.clientIdentityChanged].length) {\n      onNextTick(() => {\n        inspectorsByType[InspectorTypes.clientIdentityChanged].forEach(inspector => inspector.method(user));\n      });\n    }\n  };\n\n  return manager;\n}\n","import EventProcessor from './EventProcessor';\nimport EventEmitter from './EventEmitter';\nimport EventSender from './EventSender';\nimport InitializationStateTracker from './InitializationState';\nimport PersistentFlagStore from './PersistentFlagStore';\nimport PersistentStorage from './PersistentStorage';\nimport Stream from './Stream';\nimport Requestor from './Requestor';\nimport Identity from './Identity';\nimport UserValidator from './UserValidator';\nimport * as configuration from './configuration';\nimport * as diagnostics from './diagnosticEvents';\nimport { commonBasicLogger, createConsoleLogger } from './loggers';\nimport * as utils from './utils';\nimport * as errors from './errors';\nimport * as messages from './messages';\nimport { InspectorManager, InspectorTypes } from './InspectorManager';\n\nconst changeEvent = 'change';\nconst internalChangeEvent = 'internal-change';\n\n// This is called by the per-platform initialize functions to create the base client object that we\n// may also extend with additional behavior. It returns an object with these properties:\n//   client: the actual client object\n//   options: the configuration (after any appropriate defaults have been applied)\n// If we need to give the platform-specific clients access to any internals here, we should add those\n// as properties of the return object, not public properties of the client.\n//\n// For definitions of the API in the platform object, see stubPlatform.js in the test code.\n\nexport function initialize(env, user, specifiedOptions, platform, extraOptionDefs) {\n  const logger = createLogger();\n  const emitter = EventEmitter(logger);\n  const initializationStateTracker = InitializationStateTracker(emitter);\n  const options = configuration.validate(specifiedOptions, emitter, extraOptionDefs, logger);\n  const inspectorManager = InspectorManager(options.inspectors, logger);\n  const sendEvents = options.sendEvents;\n  let environment = env;\n  let hash = options.hash;\n\n  const persistentStorage = PersistentStorage(platform.localStorage, logger);\n\n  const eventSender = EventSender(platform, environment, options);\n\n  const diagnosticsEnabled = options.sendEvents && !options.diagnosticOptOut;\n  const diagnosticId = diagnosticsEnabled ? diagnostics.DiagnosticId(environment) : null;\n  const diagnosticsAccumulator = diagnosticsEnabled ? diagnostics.DiagnosticsAccumulator(new Date().getTime()) : null;\n  const diagnosticsManager = diagnosticsEnabled\n    ? diagnostics.DiagnosticsManager(\n        platform,\n        persistentStorage,\n        diagnosticsAccumulator,\n        eventSender,\n        environment,\n        options,\n        diagnosticId\n      )\n    : null;\n\n  const stream = Stream(platform, options, environment, diagnosticsAccumulator);\n\n  const events =\n    options.eventProcessor ||\n    EventProcessor(platform, options, environment, diagnosticsAccumulator, emitter, eventSender);\n\n  const requestor = Requestor(platform, options, environment);\n\n  let flags = {};\n  let useLocalStorage;\n  let streamActive;\n  let streamForcedState = options.streaming;\n  let subscribedToChangeEvents;\n  let inited = false;\n  let closed = false;\n  let firstEvent = true;\n\n  // The \"stateProvider\" object is used in the Electron SDK, to allow one client instance to take partial\n  // control of another. If present, it has the following contract:\n  // - getInitialState() returns the initial client state if it is already available. The state is an\n  //   object whose properties are \"environment\", \"user\", and \"flags\".\n  // - on(\"init\", listener) triggers an event when the initial client state becomes available, passing\n  //   the state object to the listener.\n  // - on(\"update\", listener) triggers an event when flag values change and/or the current user changes.\n  //   The parameter is an object that *may* contain \"user\" and/or \"flags\".\n  // - enqueueEvent(event) accepts an analytics event object and returns true if the stateProvider will\n  //   be responsible for delivering it, or false if we still should deliver it ourselves.\n  const stateProvider = options.stateProvider;\n\n  const ident = Identity(null, onIdentifyChange);\n  const userValidator = UserValidator(persistentStorage);\n  const persistentFlagStore = persistentStorage.isEnabled()\n    ? new PersistentFlagStore(persistentStorage, environment, hash, ident, logger)\n    : null;\n\n  function createLogger() {\n    if (specifiedOptions && specifiedOptions.logger) {\n      return specifiedOptions.logger;\n    }\n    return (extraOptionDefs && extraOptionDefs.logger && extraOptionDefs.logger.default) || createConsoleLogger('warn');\n  }\n\n  function readFlagsFromBootstrap(data) {\n    // If the bootstrap data came from an older server-side SDK, we'll have just a map of keys to values.\n    // Newer SDKs that have an allFlagsState method will provide an extra \"$flagsState\" key that contains\n    // the rest of the metadata we want. We do it this way for backward compatibility with older JS SDKs.\n    const keys = Object.keys(data);\n    const metadataKey = '$flagsState';\n    const validKey = '$valid';\n    const metadata = data[metadataKey];\n    if (!metadata && keys.length) {\n      logger.warn(messages.bootstrapOldFormat());\n    }\n    if (data[validKey] === false) {\n      logger.warn(messages.bootstrapInvalid());\n    }\n    const ret = {};\n    keys.forEach(key => {\n      if (key !== metadataKey && key !== validKey) {\n        let flag = { value: data[key] };\n        if (metadata && metadata[key]) {\n          flag = utils.extend(flag, metadata[key]);\n        } else {\n          flag.version = 0;\n        }\n        ret[key] = flag;\n      }\n    });\n    return ret;\n  }\n\n  function shouldEnqueueEvent() {\n    return sendEvents && !closed && !platform.isDoNotTrack();\n  }\n\n  function enqueueEvent(event) {\n    if (!environment) {\n      // We're in paired mode and haven't been initialized with an environment or user yet\n      return;\n    }\n    if (stateProvider && stateProvider.enqueueEvent && stateProvider.enqueueEvent(event)) {\n      return; // it'll be handled elsewhere\n    }\n    if (event.kind !== 'alias') {\n      if (!event.user) {\n        if (firstEvent) {\n          logger.warn(messages.eventWithoutUser());\n          firstEvent = false;\n        }\n        return;\n      }\n      firstEvent = false;\n    }\n    if (shouldEnqueueEvent()) {\n      logger.debug(messages.debugEnqueueingEvent(event.kind));\n      events.enqueue(event);\n    }\n  }\n\n  function notifyInspectionFlagUsed(key, detail) {\n    if (inspectorManager.hasListeners(InspectorTypes.flagUsed)) {\n      inspectorManager.onFlagUsed(key, detail, ident.getUser());\n    }\n  }\n\n  function notifyInspectionIdentityChanged() {\n    if (inspectorManager.hasListeners(InspectorTypes.clientIdentityChanged)) {\n      inspectorManager.onIdentityChanged(ident.getUser());\n    }\n  }\n\n  function notifyInspectionFlagChanged(data, newFlag) {\n    if (inspectorManager.hasListeners(InspectorTypes.flagDetailChanged)) {\n      inspectorManager.onFlagChanged(data.key, getFlagDetail(newFlag));\n    }\n  }\n\n  function notifyInspectionFlagsChanged() {\n    if (inspectorManager.hasListeners(InspectorTypes.flagDetailsChanged)) {\n      inspectorManager.onFlags(\n        Object.entries(flags)\n          .map(([key, value]) => ({ key, detail: getFlagDetail(value) }))\n          .reduce((acc, cur) => {\n            // eslint-disable-next-line no-param-reassign\n            acc[cur.key] = cur.detail;\n            return acc;\n          }, {})\n      );\n    }\n  }\n\n  function onIdentifyChange(user, previousUser) {\n    sendIdentifyEvent(user);\n    if (!options.autoAliasingOptOut && previousUser && previousUser.anonymous && user && !user.anonymous) {\n      alias(user, previousUser);\n    }\n    notifyInspectionIdentityChanged();\n  }\n\n  function sendIdentifyEvent(user) {\n    if (stateProvider) {\n      // In paired mode, the other client is responsible for sending identify events\n      return;\n    }\n    if (user) {\n      enqueueEvent({\n        kind: 'identify',\n        key: user.key,\n        user: user,\n        creationDate: new Date().getTime(),\n      });\n    }\n  }\n\n  function sendFlagEvent(key, detail, defaultValue, includeReason) {\n    const user = ident.getUser();\n    const now = new Date();\n    const value = detail ? detail.value : null;\n\n    const event = {\n      kind: 'feature',\n      key: key,\n      user: user,\n      value: value,\n      variation: detail ? detail.variationIndex : null,\n      default: defaultValue,\n      creationDate: now.getTime(),\n    };\n    if (user && user.anonymous) {\n      event.contextKind = userContextKind(user);\n    }\n    const flag = flags[key];\n    if (flag) {\n      event.version = flag.flagVersion ? flag.flagVersion : flag.version;\n      event.trackEvents = flag.trackEvents;\n      event.debugEventsUntilDate = flag.debugEventsUntilDate;\n    }\n    if ((includeReason || (flag && flag.trackReason)) && detail) {\n      event.reason = detail.reason;\n    }\n\n    enqueueEvent(event);\n  }\n\n  function identify(user, newHash, onDone) {\n    if (closed) {\n      return utils.wrapPromiseCallback(Promise.resolve({}), onDone);\n    }\n    if (stateProvider) {\n      // We're being controlled by another client instance, so only that instance is allowed to change the user\n      logger.warn(messages.identifyDisabled());\n      return utils.wrapPromiseCallback(Promise.resolve(utils.transformVersionedValuesToValues(flags)), onDone);\n    }\n    const clearFirst = useLocalStorage && persistentFlagStore ? persistentFlagStore.clearFlags() : Promise.resolve();\n    return utils.wrapPromiseCallback(\n      clearFirst\n        .then(() => userValidator.validateUser(user))\n        .then(realUser =>\n          requestor\n            .fetchFlagSettings(realUser, newHash)\n            // the following then() is nested within this one so we can use realUser from the previous closure\n            .then(requestedFlags => {\n              const flagValueMap = utils.transformVersionedValuesToValues(requestedFlags);\n              ident.setUser(realUser);\n              hash = newHash;\n              if (requestedFlags) {\n                return replaceAllFlags(requestedFlags).then(() => flagValueMap);\n              } else {\n                return flagValueMap;\n              }\n            })\n        )\n        .then(flagValueMap => {\n          if (streamActive) {\n            connectStream();\n          }\n          return flagValueMap;\n        })\n        .catch(err => {\n          emitter.maybeReportError(err);\n          return Promise.reject(err);\n        }),\n      onDone\n    );\n  }\n\n  function getUser() {\n    return ident.getUser();\n  }\n\n  function flush(onDone) {\n    return utils.wrapPromiseCallback(sendEvents ? events.flush() : Promise.resolve(), onDone);\n  }\n\n  function variation(key, defaultValue) {\n    return variationDetailInternal(key, defaultValue, true, false, false).value;\n  }\n\n  function variationDetail(key, defaultValue) {\n    return variationDetailInternal(key, defaultValue, true, true, false);\n  }\n\n  function variationDetailInternal(key, defaultValue, sendEvent, includeReasonInEvent, isAllFlags) {\n    let detail;\n\n    if (flags && utils.objectHasOwnProperty(flags, key) && flags[key] && !flags[key].deleted) {\n      const flag = flags[key];\n      detail = getFlagDetail(flag);\n      if (flag.value === null || flag.value === undefined) {\n        detail.value = defaultValue;\n      }\n    } else {\n      detail = { value: defaultValue, variationIndex: null, reason: { kind: 'ERROR', errorKind: 'FLAG_NOT_FOUND' } };\n    }\n\n    if (sendEvent) {\n      sendFlagEvent(key, detail, defaultValue, includeReasonInEvent);\n    }\n\n    // For the all flags case `onFlags` will be called instead.\n    if (!isAllFlags) {\n      notifyInspectionFlagUsed(key, detail);\n    }\n\n    return detail;\n  }\n\n  function getFlagDetail(flag) {\n    return {\n      value: flag.value,\n      variationIndex: flag.variation === undefined ? null : flag.variation,\n      reason: flag.reason || null,\n    };\n    // Note, the logic above ensures that variationIndex and reason will always be null rather than\n    // undefined if we don't have values for them. That's just to avoid subtle errors that depend on\n    // whether an object was JSON-encoded with null properties omitted or not.\n  }\n\n  function allFlags() {\n    const results = {};\n\n    if (!flags) {\n      return results;\n    }\n\n    for (const key in flags) {\n      if (utils.objectHasOwnProperty(flags, key) && !flags[key].deleted) {\n        results[key] = variationDetailInternal(key, null, !options.sendEventsOnlyForVariation, false, true).value;\n      }\n    }\n\n    return results;\n  }\n\n  function userContextKind(user) {\n    return user.anonymous ? 'anonymousUser' : 'user';\n  }\n\n  function alias(user, previousUser) {\n    if (stateProvider) {\n      // In paired mode, the other client is responsible for sending alias events\n      return;\n    }\n\n    if (!user || !previousUser) {\n      return;\n    }\n\n    enqueueEvent({\n      kind: 'alias',\n      key: user.key,\n      contextKind: userContextKind(user),\n      previousKey: previousUser.key,\n      previousContextKind: userContextKind(previousUser),\n      creationDate: new Date().getTime(),\n    });\n  }\n\n  function track(key, data, metricValue) {\n    if (typeof key !== 'string') {\n      emitter.maybeReportError(new errors.LDInvalidEventKeyError(messages.unknownCustomEventKey(key)));\n      return;\n    }\n\n    // The following logic was used only for the JS browser SDK (js-client-sdk) and\n    // is no longer needed as of version 2.9.13 of that SDK. The other client-side\n    // JS-based SDKs did not define customEventFilter, and now none of them do. We\n    // can remove this in the next major version of the common code, when it's OK to\n    // make breaking changes to our internal API contracts.\n    if (platform.customEventFilter && !platform.customEventFilter(key)) {\n      logger.warn(messages.unknownCustomEventKey(key));\n    }\n\n    const user = ident.getUser();\n    const e = {\n      kind: 'custom',\n      key: key,\n      user: user,\n      url: platform.getCurrentUrl(),\n      creationDate: new Date().getTime(),\n    };\n    if (user && user.anonymous) {\n      e.contextKind = userContextKind(user);\n    }\n    // Note, check specifically for null/undefined because it is legal to set these fields to a falsey value.\n    if (data !== null && data !== undefined) {\n      e.data = data;\n    }\n    if (metricValue !== null && metricValue !== undefined) {\n      e.metricValue = metricValue;\n    }\n    enqueueEvent(e);\n  }\n\n  function connectStream() {\n    streamActive = true;\n    if (!ident.getUser()) {\n      return;\n    }\n    const tryParseData = jsonData => {\n      try {\n        return JSON.parse(jsonData);\n      } catch (err) {\n        emitter.maybeReportError(new errors.LDInvalidDataError(messages.invalidData()));\n        return undefined;\n      }\n    };\n    stream.connect(ident.getUser(), hash, {\n      ping: function() {\n        logger.debug(messages.debugStreamPing());\n        const userAtTimeOfPingEvent = ident.getUser();\n        requestor\n          .fetchFlagSettings(userAtTimeOfPingEvent, hash)\n          .then(requestedFlags => {\n            // Check whether the current user is still the same - we don't want to overwrite the flags if\n            // the application has called identify() while this request was in progress\n            if (utils.deepEquals(userAtTimeOfPingEvent, ident.getUser())) {\n              replaceAllFlags(requestedFlags || {});\n            }\n          })\n          .catch(err => {\n            emitter.maybeReportError(new errors.LDFlagFetchError(messages.errorFetchingFlags(err)));\n          });\n      },\n      put: function(e) {\n        const data = tryParseData(e.data);\n        if (!data) {\n          return;\n        }\n        logger.debug(messages.debugStreamPut());\n        replaceAllFlags(data);\n        // Don't wait for this Promise to be resolved; note that replaceAllFlags is guaranteed\n        // never to have an unhandled rejection\n      },\n      patch: function(e) {\n        const data = tryParseData(e.data);\n        if (!data) {\n          return;\n        }\n        // If both the flag and the patch have a version property, then the patch version must be\n        // greater than the flag version for us to accept the patch.  If either one has no version\n        // then the patch always succeeds.\n        const oldFlag = flags[data.key];\n        if (!oldFlag || !oldFlag.version || !data.version || oldFlag.version < data.version) {\n          logger.debug(messages.debugStreamPatch(data.key));\n          const mods = {};\n          const newFlag = utils.extend({}, data);\n          delete newFlag['key'];\n          flags[data.key] = newFlag;\n          const newDetail = getFlagDetail(newFlag);\n          if (oldFlag) {\n            mods[data.key] = { previous: oldFlag.value, current: newDetail };\n          } else {\n            mods[data.key] = { current: newDetail };\n          }\n          handleFlagChanges(mods); // don't wait for this Promise to be resolved\n          notifyInspectionFlagChanged(data, newFlag);\n        } else {\n          logger.debug(messages.debugStreamPatchIgnored(data.key));\n        }\n      },\n      delete: function(e) {\n        const data = tryParseData(e.data);\n        if (!data) {\n          return;\n        }\n        if (!flags[data.key] || flags[data.key].version < data.version) {\n          logger.debug(messages.debugStreamDelete(data.key));\n          const mods = {};\n          if (flags[data.key] && !flags[data.key].deleted) {\n            mods[data.key] = { previous: flags[data.key].value };\n          }\n          flags[data.key] = { version: data.version, deleted: true };\n          notifyInspectionFlagChanged(data, flags[data.key]);\n          handleFlagChanges(mods); // don't wait for this Promise to be resolved\n        } else {\n          logger.debug(messages.debugStreamDeleteIgnored(data.key));\n        }\n      },\n    });\n  }\n\n  function disconnectStream() {\n    if (streamActive) {\n      stream.disconnect();\n      streamActive = false;\n    }\n  }\n\n  // Returns a Promise which will be resolved when we have completely updated the internal flags state,\n  // dispatched all change events, and updated local storage if appropriate. This Promise is guaranteed\n  // never to have an unhandled rejection.\n  function replaceAllFlags(newFlags) {\n    const changes = {};\n\n    if (!newFlags) {\n      return Promise.resolve();\n    }\n\n    for (const key in flags) {\n      if (utils.objectHasOwnProperty(flags, key) && flags[key]) {\n        if (newFlags[key] && !utils.deepEquals(newFlags[key].value, flags[key].value)) {\n          changes[key] = { previous: flags[key].value, current: getFlagDetail(newFlags[key]) };\n        } else if (!newFlags[key] || newFlags[key].deleted) {\n          changes[key] = { previous: flags[key].value };\n        }\n      }\n    }\n    for (const key in newFlags) {\n      if (utils.objectHasOwnProperty(newFlags, key) && newFlags[key] && (!flags[key] || flags[key].deleted)) {\n        changes[key] = { current: getFlagDetail(newFlags[key]) };\n      }\n    }\n\n    flags = { ...newFlags };\n\n    notifyInspectionFlagsChanged();\n\n    return handleFlagChanges(changes).catch(() => {}); // swallow any exceptions from this Promise\n  }\n\n  // Returns a Promise which will be resolved when we have dispatched all change events and updated\n  // local storage if appropriate.\n  function handleFlagChanges(changes) {\n    const keys = Object.keys(changes);\n\n    if (keys.length > 0) {\n      const changeEventParams = {};\n      keys.forEach(key => {\n        const current = changes[key].current;\n        const value = current ? current.value : undefined;\n        const previous = changes[key].previous;\n        emitter.emit(changeEvent + ':' + key, value, previous);\n        changeEventParams[key] = current ? { current: value, previous: previous } : { previous: previous };\n      });\n\n      emitter.emit(changeEvent, changeEventParams);\n      emitter.emit(internalChangeEvent, flags);\n\n      // By default, we send feature evaluation events whenever we have received new flag values -\n      // the client has in effect evaluated these flags just by receiving them. This can be suppressed\n      // by setting \"sendEventsOnlyForVariation\". Also, if we have a stateProvider, we don't send these\n      // events because we assume they have already been sent by the other client that gave us the flags\n      // (when it received them in the first place).\n      if (!options.sendEventsOnlyForVariation && !stateProvider) {\n        keys.forEach(key => {\n          sendFlagEvent(key, changes[key].current);\n        });\n      }\n    }\n\n    if (useLocalStorage && persistentFlagStore) {\n      return persistentFlagStore.saveFlags(flags);\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  function on(event, handler, context) {\n    if (isChangeEventKey(event)) {\n      subscribedToChangeEvents = true;\n      if (inited) {\n        updateStreamingState();\n      }\n      emitter.on(event, handler, context);\n    } else {\n      emitter.on(...arguments);\n    }\n  }\n\n  function off(event) {\n    emitter.off(...arguments);\n    if (isChangeEventKey(event)) {\n      let haveListeners = false;\n      emitter.getEvents().forEach(key => {\n        if (isChangeEventKey(key) && emitter.getEventListenerCount(key) > 0) {\n          haveListeners = true;\n        }\n      });\n      if (!haveListeners) {\n        subscribedToChangeEvents = false;\n        if (streamActive && streamForcedState === undefined) {\n          disconnectStream();\n        }\n      }\n    }\n  }\n\n  function setStreaming(state) {\n    const newState = state === null ? undefined : state;\n    if (newState !== streamForcedState) {\n      streamForcedState = newState;\n      updateStreamingState();\n    }\n  }\n\n  function updateStreamingState() {\n    const shouldBeStreaming = streamForcedState || (subscribedToChangeEvents && streamForcedState === undefined);\n    if (shouldBeStreaming && !streamActive) {\n      connectStream();\n    } else if (!shouldBeStreaming && streamActive) {\n      disconnectStream();\n    }\n    if (diagnosticsManager) {\n      diagnosticsManager.setStreaming(shouldBeStreaming);\n    }\n  }\n\n  function isChangeEventKey(event) {\n    return event === changeEvent || event.substr(0, changeEvent.length + 1) === changeEvent + ':';\n  }\n\n  if (typeof options.bootstrap === 'string' && options.bootstrap.toUpperCase() === 'LOCALSTORAGE') {\n    if (persistentFlagStore) {\n      useLocalStorage = true;\n    } else {\n      logger.warn(messages.localStorageUnavailable());\n    }\n  }\n\n  if (typeof options.bootstrap === 'object') {\n    // Set the flags as soon as possible before we get into any async code, so application code can read\n    // them even if the ready event has not yet fired.\n    flags = readFlagsFromBootstrap(options.bootstrap);\n  }\n\n  if (stateProvider) {\n    // The stateProvider option is used in the Electron SDK, to allow a client instance in the main process\n    // to control another client instance (i.e. this one) in the renderer process. We can't predict which\n    // one will start up first, so the initial state may already be available for us or we may have to wait\n    // to receive it.\n    const state = stateProvider.getInitialState();\n    if (state) {\n      initFromStateProvider(state);\n    } else {\n      stateProvider.on('init', initFromStateProvider);\n    }\n    stateProvider.on('update', updateFromStateProvider);\n  } else {\n    finishInit().catch(signalFailedInit);\n  }\n\n  function finishInit() {\n    if (!env) {\n      return Promise.reject(new errors.LDInvalidEnvironmentIdError(messages.environmentNotSpecified()));\n    }\n    return userValidator.validateUser(user).then(realUser => {\n      ident.setUser(realUser);\n      if (typeof options.bootstrap === 'object') {\n        // flags have already been set earlier\n        return signalSuccessfulInit();\n      } else if (useLocalStorage) {\n        return finishInitWithLocalStorage();\n      } else {\n        return finishInitWithPolling();\n      }\n    });\n  }\n\n  function finishInitWithLocalStorage() {\n    return persistentFlagStore.loadFlags().then(storedFlags => {\n      if (storedFlags === null || storedFlags === undefined) {\n        flags = {};\n        return requestor\n          .fetchFlagSettings(ident.getUser(), hash)\n          .then(requestedFlags => replaceAllFlags(requestedFlags || {}))\n          .then(signalSuccessfulInit)\n          .catch(err => {\n            const initErr = new errors.LDFlagFetchError(messages.errorFetchingFlags(err));\n            signalFailedInit(initErr);\n          });\n      } else {\n        // We're reading the flags from local storage. Signal that we're ready,\n        // then update localStorage for the next page load. We won't signal changes or update\n        // the in-memory flags unless you subscribe for changes\n        flags = storedFlags;\n        utils.onNextTick(signalSuccessfulInit);\n\n        return requestor\n          .fetchFlagSettings(ident.getUser(), hash)\n          .then(requestedFlags => replaceAllFlags(requestedFlags))\n          .catch(err => emitter.maybeReportError(err));\n      }\n    });\n  }\n\n  function finishInitWithPolling() {\n    return requestor\n      .fetchFlagSettings(ident.getUser(), hash)\n      .then(requestedFlags => {\n        flags = requestedFlags || {};\n\n        notifyInspectionFlagsChanged();\n        // Note, we don't need to call updateSettings here because local storage and change events are not relevant\n        signalSuccessfulInit();\n      })\n      .catch(err => {\n        flags = {};\n        signalFailedInit(err);\n      });\n  }\n\n  function initFromStateProvider(state) {\n    environment = state.environment;\n    ident.setUser(state.user);\n    flags = { ...state.flags };\n    utils.onNextTick(signalSuccessfulInit);\n  }\n\n  function updateFromStateProvider(state) {\n    if (state.user) {\n      ident.setUser(state.user);\n    }\n    if (state.flags) {\n      replaceAllFlags(state.flags); // don't wait for this Promise to be resolved\n    }\n  }\n\n  function signalSuccessfulInit() {\n    logger.info(messages.clientInitialized());\n    inited = true;\n    updateStreamingState();\n    initializationStateTracker.signalSuccess();\n  }\n\n  function signalFailedInit(err) {\n    initializationStateTracker.signalFailure(err);\n  }\n\n  function start() {\n    if (sendEvents) {\n      if (diagnosticsManager) {\n        diagnosticsManager.start();\n      }\n      events.start();\n    }\n  }\n\n  function close(onDone) {\n    if (closed) {\n      return utils.wrapPromiseCallback(Promise.resolve(), onDone);\n    }\n    const finishClose = () => {\n      closed = true;\n      flags = {};\n    };\n    const p = Promise.resolve()\n      .then(() => {\n        disconnectStream();\n        if (diagnosticsManager) {\n          diagnosticsManager.stop();\n        }\n        if (sendEvents) {\n          events.stop();\n          return events.flush();\n        }\n      })\n      .then(finishClose)\n      .catch(finishClose);\n    return utils.wrapPromiseCallback(p, onDone);\n  }\n\n  function getFlagsInternal() {\n    // used by Electron integration\n    return flags;\n  }\n\n  const client = {\n    waitForInitialization: () => initializationStateTracker.getInitializationPromise(),\n    waitUntilReady: () => initializationStateTracker.getReadyPromise(),\n    identify: identify,\n    getUser: getUser,\n    variation: variation,\n    variationDetail: variationDetail,\n    track: track,\n    alias: alias,\n    on: on,\n    off: off,\n    setStreaming: setStreaming,\n    flush: flush,\n    allFlags: allFlags,\n    close: close,\n  };\n\n  return {\n    client: client, // The client object containing all public methods.\n    options: options, // The validated configuration object, including all defaults.\n    emitter: emitter, // The event emitter which can be used to log errors or trigger events.\n    ident: ident, // The Identity object that manages the current user.\n    logger: logger, // The logging abstraction.\n    requestor: requestor, // The Requestor object.\n    start: start, // Starts the client once the environment is ready.\n    enqueueEvent: enqueueEvent, // Puts an analytics event in the queue, if event sending is enabled.\n    getFlagsInternal: getFlagsInternal, // Returns flag data structure with all details.\n    getEnvironmentId: () => environment, // Gets the environment ID (this may have changed since initialization, if we have a state provider)\n    internalChangeEventName: internalChangeEvent, // This event is triggered whenever we have new flag state.\n  };\n}\n\nexport const version = VERSION;\nexport { commonBasicLogger };\nexport { createConsoleLogger };\nexport { errors };\nexport { messages };\nexport { utils };\n"],"names":["createCustomError","name","CustomError","message","code","Error","captureStackTrace","this","constructor","prototype","LDUnexpectedResponseError","LDInvalidEnvironmentIdError","LDInvalidUserError","LDInvalidEventKeyError","LDInvalidArgumentError","LDFlagFetchError","LDInvalidDataError","isHttpErrorRecoverable","status","fromByteArray","lookup","revLookup","i","len","length","charCodeAt","tripletToBase64","num","encodeChunk","uint8","start","end","tmp","output","push","join","extraBytes","parts","len2","isArray","Array","keyList","Object","keys","hasProp","hasOwnProperty","equal","a","b","key","arrA","arrB","dateA","Date","dateB","getTime","regexpA","RegExp","regexpB","toString","call","userAttrsToStringify","appendUrlPath","baseUrl","path","endsWith","substring","startsWith","btoa","s","escaped","unescape","encodeURIComponent","base64","stringToBytes","base64URLEncode","replace","clone","obj","JSON","parse","stringify","deepEquals","fastDeepEqual","onNextTick","cb","setTimeout","wrapPromiseCallback","promise","callback","ret","then","value","error","Promise","reject","undefined","transformValuesToVersionedValues","flags","objectHasOwnProperty","version","transformVersionedValuesToValues","flagsState","chunkUserEventsForUrl","maxLength","events","chunk","allEvents","slice","allChunks","remainingSpace","event","shift","unshift","getLDUserAgentString","platform","userAgent","extend","objects","reduce","acc","object","sanitizeUser","user","newUser","attr","String","rnds8","rnds","getRandomValues","crypto","bind","window","msCrypto","Uint8Array","module","r","Math","random","byteToHex","substr","bytesToUuid","buf","offset","bth","_nodeId","_clockseq","_lastMSecs","_lastNSecs","v1","options","node","clockseq","msecs","seedBytes","rng","nsecs","dt","tl","tmh","n","logLevels","commonBasicLogger","formatFn","destination","toConsole","methodName","line","console","destinations","prependLevelToMessage","prefix","minLevel","level","logger","levelIndex","levelName","write","args","arguments","fullPrefix","tempArgs","err","log","_loop","validateLogger","forEach","createConsoleLogger","maybePrefix","errorString","clientInitialized","docLink","clientNotReady","eventCapacityExceeded","eventWithoutUser","invalidContentType","contentType","invalidKey","localStorageUnavailable","networkError","e","unknownCustomEventKey","environmentNotFound","environmentNotSpecified","errorFetchingFlags","userNotSpecified","invalidUser","invalidData","bootstrapOldFormat","bootstrapInvalid","deprecated","oldName","newName","httpErrorMessage","context","retryMessage","errors","httpUnavailable","identifyDisabled","streamClosing","streamConnecting","url","streamError","streamReconnectDelay","unrecoverableStreamError","unknownOption","wrongOptionType","expectedType","actualType","wrongOptionTypeBoolean","optionBelowMinimum","minimum","debugPolling","debugStreamPing","debugStreamPut","debugStreamPatch","debugStreamPatchIgnored","debugStreamDelete","debugStreamDeleteIgnored","debugEnqueueingEvent","kind","debugPostingEvents","count","debugPostingDiagnosticEvent","invalidTagValue","invalidInspector","type","inspectorMethodError","tagValueTooLong","baseOptionDefs","default","streamUrl","eventsUrl","sendEvents","streaming","sendLDHeaders","requestHeaderTransform","inlineUsersInEvents","allowFrequentDuplicateEvents","sendEventsOnlyForVariation","useReport","evaluationReasons","eventCapacity","flushInterval","samplingInterval","allAttributesPrivate","privateAttributeNames","bootstrap","diagnosticRecordingInterval","diagnosticOptOut","wrapperName","wrapperVersion","stateProvider","autoAliasingOptOut","application","validator","applicationConfigValidator","inspectors","allowedTagCharacters","validateTagValue","tagValue","match","warn","messages","validated","id","validate","emitter","extraOptionDefs","optionDefs","utils","deprecatedOptions","all_attributes_private","private_attribute_names","reportArgumentError","maybeReportError","opts","config","typeDescForValue","t","optionDef","allowedTypes","split","indexOf","getTags","tags","getLDHeaders","h","X-LaunchDarkly-User-Agent","tagKeys","sort","map","flattened","item","concat","transformHeaders","headers","MAX_URL_LENGTH","EventSender","environmentId","imageUrlPath","baseHeaders","Content-Type","httpFallbackPing","sender","sendChunk","isDiagnostic","usePost","jsonBody","payloadId","uuidv1","doPostRequest","canRetry","X-LaunchDarkly-Event-Schema","X-LaunchDarkly-Payload-ID","httpRequest","result","dateStr","header","serverTime","time","catch","resolve","canPost","httpAllowsPost","chunks","results","all","EventSummarizer","es","startDate","endDate","counters","summarizeEvent","counterKey","counterVal","variation","creationDate","getSummary","flagsOut","empty","c","flag","counterOut","unknown","features","clearSummary","UserFilter","filter","ignoreAttrs","custom","anonymous","allowedTopLevelAttrs","secondary","ip","country","email","firstName","lastName","avatar","filterUser","userPrivateAttrs","isPrivateAttr","filteredProps","removedAttrs","customResult","filterAttrs","props","isAttributeAllowed","removedAttrNames","privateAttrs","EventProcessor","flushTimer","diagnosticsAccumulator","processor","eventSender","mainEventsUrl","summarizer","userFilter","inlineUsers","queue","lastKnownPastTime","disabled","exceededCapacity","shouldSampleEvent","floor","addToOutbox","incrementDroppedEvents","enqueue","addDebugEvent","debugEvent","addFullEvent","trackEvents","debugEventsUntilDate","userKey","flush","eventsToSend","summary","setEventsInLastBatch","debug","responseInfo","flushTick","stop","clearTimeout","EventEmitter","on","handler","off","emit","copiedHandlers","apply","getEvents","getEventListenerCount","readyEvent","successEvent","failureEvent","InitializationStateTracker","eventEmitter","succeeded","failed","failureValue","initializationPromise","readyPromise","onReady","getInitializationPromise","onFailure","onSuccess","getReadyPromise","signalSuccess","signalFailure","PersistentFlagStore","storage","environment","hash","ident","store","getFlagsKey","getUser","loadFlags","get","dataStr","schema","data","$schema","ex","clearFlags","saveFlags","set","clear","PersistentStorage","localStorageProvider","logError","loggedError","isEnabled","streamReadTimeoutMillis","maxRetryDelay","jitterRatio","Stream","connectionAttemptStartTime","stream","evalUrlPrefix","withReasons","baseReconnectDelay","firstConnectionErrorLogged","reconnectTimeoutReference","handlers","retryCount","getNextRetryDelay","delay","pow","computedDelayMillis","trunc","handleError","closeConnection","logConnectionResult","tryConnect","openConnection","query","readTimeoutMillis","eventSourceFactory","eventSourceAllowsReport","method","body","info","addEventListener","onerror","onopen","close","success","recordStreamInit","connect","newHash","newHandlers","disconnect","isConnected","eventSourceIsActive","promiseCoalescer","finallyFn","currentPromise","currentCancelFn","finalResolve","finalReject","coalescer","p","cancelFn","resultPromise","jsonContentType","getResponseError","statusText","Requestor","requestor","activeRequests","fetchJSON","endpoint","req","addPromise","cancel","fetchFlagSettings","Identity","initialUser","onChange","u","previousUser","setUser","ldUserIdKey","UserValidator","persistentStorage","validateUser","userOut","cachedId","require$$0","require$$1","DiagnosticId","sdkKey","diagnosticId","sdkKeySuffix","DiagnosticsAccumulator","startTime","dataSinceDate","droppedEvents","eventsInLastBatch","streamInits","reset","getProps","setProps","timestamp","durationMillis","DiagnosticsManager","accumulator","eventSentTime","periodicTimer","combinedMode","diagnosticUseCombinedEvent","localStorageKey","diagnosticEventsUrl","periodicInterval","streamingEnabled","manager","makeInitProperties","sdk","sdkData","diagnosticSdkData","configuration","customBaseURI","customStreamURI","customEventsURI","eventsCapacity","eventsFlushIntervalMillis","reconnectTimeMillis","streamingDisabled","diagnosticRecordingIntervalMillis","usingSecureMode","bootstrapMode","fetchGoalsDisabled","fetchGoals","diagnosticPlatformData","sendDiagnosticEvent","sendPeriodicEvent","currentTime","localStorageAvailable","timeNow","nextEventTime","setStreaming","enabled","SafeInspector","inspector","errorLogged","wrapper","InspectorTypes","flagUsed","flagDetailsChanged","flagDetailChanged","clientIdentityChanged","InspectorManager","inspectorsByType","safeInspector","hasListeners","_inspectorsByType$typ","onFlagUsed","flagKey","detail","onFlags","onFlagChanged","onIdentityChanged","freeze","changeEvent","internalChangeEvent","initialize","env","specifiedOptions","useLocalStorage","streamActive","subscribedToChangeEvents","metadataKey","metadata","initializationStateTracker","inspectorManager","localStorage","diagnosticsEnabled","diagnostics","diagnosticsManager","eventProcessor","streamForcedState","inited","closed","firstEvent","enqueueEvent","alias","userValidator","persistentFlagStore","isDoNotTrack","notifyInspectionFlagChanged","newFlag","getFlagDetail","notifyInspectionFlagsChanged","entries","cur","sendFlagEvent","defaultValue","includeReason","now","variationIndex","contextKind","userContextKind","flagVersion","trackReason","reason","variationDetailInternal","sendEvent","includeReasonInEvent","isAllFlags","deleted","errorKind","previousKey","previousContextKind","connectStream","tryParseData","jsonData","ping","userAtTimeOfPingEvent","requestedFlags","replaceAllFlags","put","patch","oldFlag","mods","newDetail","previous","current","handleFlagChanges","delete","disconnectStream","newFlags","changes","changeEventParams","updateStreamingState","shouldBeStreaming","isChangeEventKey","initFromStateProvider","state","signalSuccessfulInit","signalFailedInit","toUpperCase","_typeof","getInitialState","realUser","storedFlags","client","waitForInitialization","waitUntilReady","identify","onDone","flagValueMap","variationDetail","track","metricValue","customEventFilter","getCurrentUrl","haveListeners","newState","allFlags","finishClose","getFlagsInternal","getEnvironmentId","internalChangeEventName"],"mappings":"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"}